Found 1274 issues

src/main/java/org/modeshape/jcr/query/optimize/RemoveEmptyAccessNodes.java:40: error: NULL_DEREFERENCE
  object returned by `access.getProperty(org.modeshape.jcr.query.plan.PlanNode$Property.ACCESS_NO_RESULTS,java.lang.Boolean)` could be null and is dereferenced at line 40.
  38.           // Find all access nodes ...
  39.           for (PlanNode access : plan.findAllAtOrBelow(Type.ACCESS)) {
  40. >             if (access.getProperty(Property.ACCESS_NO_RESULTS, Boolean.class)) {
  41.                   // This node has conflicting constraints and will never return any results ...
  42.   

src/main/java/org/modeshape/jcr/query/optimize/RaiseVariableName.java:42: error: NULL_DEREFERENCE
  object `left` last assigned on line 41 could be null and is dereferenced by call to `raiseVariableName(...)` at line 42.
  40.               // Check the left ...
  41.               PlanNode left = depQuery.getFirstChild();
  42. >             raiseVariableName(left);
  43.   
  44.               // Check the right ...

src/main/java/org/modeshape/jcr/query/optimize/RaiseVariableName.java:46: error: NULL_DEREFERENCE
  object `right` last assigned on line 45 could be null and is dereferenced by call to `raiseVariableName(...)` at line 46.
  44.               // Check the right ...
  45.               PlanNode right = depQuery.getLastChild();
  46. >             raiseVariableName(right);
  47.           }
  48.           return plan;

src/main/java/org/modeshape/jcr/query/optimize/RightOuterToLeftOuterJoins.java:44: error: NULL_DEREFERENCE
  object `left` last assigned on line 43 could be null and is dereferenced at line 44.
  42.                   // Swap the information ...
  43.                   PlanNode left = joinNode.getFirstChild();
  44. >                 left.removeFromParent(); // right is now the first child ...
  45.                   left.setParent(joinNode);
  46.                   joinNode.setProperty(Property.JOIN_TYPE, JoinType.LEFT_OUTER);

src/main/java/org/modeshape/jcr/query/optimize/AddJoinConditionColumnsToSources.java:58: error: NULL_DEREFERENCE
  object `left` last assigned on line 56 could be null and is dereferenced at line 58.
  56.                   PlanNode left = joinNode.getFirstChild();
  57.                   PlanNode right = joinNode.getLastChild();
  58. >                 if (left.getSelectors().contains(selector1)) {
  59.                       addEquiJoinColumn(context, left, joinColumn1);
  60.                       addEquiJoinColumn(context, right, joinColumn2);

src/main/java/org/modeshape/jcr/query/optimize/ReorderSortAndRemoveDuplicates.java:42: error: NULL_DEREFERENCE
  object returned by `distinct.getFirstChild()` could be null and is dereferenced at line 42.
  40.           for (PlanNode distinct : plan.findAllAtOrBelow(Traversal.PRE_ORDER, Type.DUP_REMOVE)) {
  41.               // If there is a SORT below the DUP_REMOVE, then swap them...
  42. >             if (distinct.getFirstChild().getType() == Type.SORT) {
  43.                   // Swap them so that duplicate removal happens first (it's lower in the plan) ...
  44.                   PlanNode parent = distinct.getParent();

src/main/java/org/modeshape/jcr/query/optimize/PushProjects.java:55: error: NULL_DEREFERENCE
  object `child` last assigned on line 54 could be null and is dereferenced at line 55.
  53.               assert parentOfProject.getChildCount() == 1; // should only have one child ...
  54.               PlanNode child = parentOfProject.getFirstChild(); // should only have one child ...
  55. >             if (child.is(Type.PROJECT)) {
  56.                   // Check to see if there is a PROJECT above the access node ...
  57.                   PlanNode accessParent = access.getParent();

src/main/java/org/modeshape/jcr/query/optimize/JoinOrder.java:62: error: NULL_DEREFERENCE
  object `first` last assigned on line 61 could be null and is dereferenced at line 62.
  60.               if (swapChildren) {
  61.                   PlanNode first = join.getFirstChild();
  62. >                 first.removeFromParent();
  63.                   join.addLastChild(first);
  64.                   if (joinType == JoinType.LEFT_OUTER){

src/main/java/org/modeshape/jcr/query/optimize/JoinOrder.java:51: error: NULL_DEREFERENCE
  object returned by `join.getFirstChild()` could be null and is dereferenced at line 51.
  49.                   SelectorName ancestorSelector = condition.ancestorSelectorName();
  50.                   // The ancestor needs to be on the left side of the join ...
  51. >                 swapChildren = !join.getFirstChild().getSelectors().contains(ancestorSelector);
  52.               } else if (joinCondition instanceof ChildNodeJoinCondition) {
  53.                   ChildNodeJoinCondition condition = (ChildNodeJoinCondition)joinCondition;

src/main/java/org/modeshape/jcr/query/optimize/JoinOrder.java:56: error: NULL_DEREFERENCE
  object returned by `join.getFirstChild()` could be null and is dereferenced at line 56.
  54.                   SelectorName parentSelector = condition.parentSelectorName();
  55.                   // The ancestor needs to be on the left side of the join ...
  56. >                 swapChildren = !join.getFirstChild().getSelectors().contains(parentSelector);
  57.               }
  58.   

src/main/java/org/modeshape/jcr/query/optimize/CopyCriteria.java:92: error: NULL_DEREFERENCE
  object `left` last assigned on line 90 could be null and is dereferenced by call to `copySelectNodes(...)` at line 92.
  90.                   PlanNode left = join.getFirstChild();
  91.                   PlanNode right = join.getLastChild();
  92. >                 copySelectNodes(context, left, right);
  93.                   copySelectNodes(context, right, left);
  94.               }

src/main/java/org/modeshape/jcr/query/optimize/CopyCriteria.java:92: error: NULL_DEREFERENCE
  object `right` last assigned on line 91 could be null and is dereferenced by call to `copySelectNodes(...)` at line 92.
  90.                   PlanNode left = join.getFirstChild();
  91.                   PlanNode right = join.getLastChild();
  92. >                 copySelectNodes(context, left, right);
  93.                   copySelectNodes(context, right, left);
  94.               }

src/main/java/org/modeshape/jcr/query/optimize/RewritePathAndNameCriteria.java:58: error: NULL_DEREFERENCE
  object `constraint` last assigned on line 57 could be null and is dereferenced by call to `rewriteCriteria(...)` at line 58.
  56.           for (PlanNode node : plan.findAllAtOrBelow(Type.SELECT)) {
  57.               Constraint constraint = node.getProperty(Property.SELECT_CRITERIA, Constraint.class);
  58. >             Constraint newConstraint = rewriteCriteria(context, constraint);
  59.               if (constraint != newConstraint) {
  60.                   node.getSelectors().clear();

src/main/java/org/modeshape/jcr/JcrVersionNode.java:59: error: NULL_DEREFERENCE
  object returned by `getProperty(org.modeshape.jcr.JcrLexicon.CREATED)` could be null and is dereferenced at line 59.
  57.       @Override
  58.       public Calendar getCreated() throws RepositoryException {
  59. >         return getProperty(JcrLexicon.CREATED).getDate();
  60.       }
  61.   

src/main/java/org/modeshape/jcr/query/optimize/RewritePseudoColumns.java:65: error: NULL_DEREFERENCE
  object `condition` last assigned on line 64 could be null and is dereferenced by call to `rewrite(...)` at line 65.
  63.           for (PlanNode join : plan.findAllAtOrBelow(Traversal.PRE_ORDER, Type.JOIN)) {
  64.               JoinCondition condition = join.getProperty(Property.JOIN_CONDITION, JoinCondition.class);
  65. >             JoinCondition newCondition = rewrite(context, condition);
  66.               if (newCondition != condition) {
  67.                   join.setProperty(Property.JOIN_CONDITION, newCondition);

src/main/java/org/modeshape/connector/filesystem/JsonSidecarExtraPropertyStore.java:64: error: RESOURCE_LEAK
  resource of type `java.io.FileInputStream` acquired by call to `FileInputStream(...)` at line 64 is not released after line 64.
  62.           if (!sidecarFile.exists()) return NO_PROPERTIES;
  63.           try {
  64. >             Document document = read(new FileInputStream(sidecarFile));
  65.               Map<Name, Property> results = new HashMap<Name, Property>();
  66.               translator.getProperties(document, results);

src/main/java/org/modeshape/jcr/value/binary/SharedLockingInputStream.java:81: error: RESOURCE_LEAK
  resource of type `java.io.FileInputStream` acquired by call to `FileInputStream(...)` at line 76 is not released after line 81.
**Note**: potential exception at line 78
  79.                       SharedLockingInputStream.this.eofReached = false;
  80.                   }
  81. >                 return null;
  82.               }
  83.           });

src/main/java/org/modeshape/jcr/InfinispanUtil.java:99: error: NULL_DEREFERENCE
  object `result` last assigned on line 76 could be null and is dereferenced by call to `combine(...)` at line 99.
  97.                           // We got some keys, so this future is done and should be removed from our list ...
  98.                           futureIter.remove();
  99. >                         result = combiner.combine(result, value);
  100.                       } catch (TimeoutException e) {
  101.                           // continue;

src/main/java/org/modeshape/jcr/BackupDocumentWriter.java:89: error: RESOURCE_LEAK
  resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 88 is not released after line 89.
  87.                   currentFile = new File(parentDirectory, filename);
  88.                   OutputStream fileStream = new FileOutputStream(currentFile);
  89. >                 if (compress) fileStream = new GZIPOutputStream(fileStream);
  90.                   stream = new BufferedOutputStream(fileStream);
  91.               }

src/main/java/org/modeshape/connector/filesystem/JsonSidecarExtraPropertyStore.java:84: error: RESOURCE_LEAK
  resource of type `java.io.FileInputStream` acquired by call to `FileInputStream(...)` at line 84 is not released after line 84.
  82.                   document = Schematic.newDocument();
  83.               } else {
  84. >                 Document existing = read(new FileInputStream(sidecarFile));
  85.                   document = Schematic.newDocument(existing);
  86.               }

src/main/java/org/modeshape/connector/filesystem/JsonSidecarExtraPropertyStore.java:95: error: RESOURCE_LEAK
  resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 95 is not released after line 95.
  93.                   }
  94.               }
  95. >             write(document, new FileOutputStream(sidecarFile));
  96.           } catch (IOException e) {
  97.               throw new DocumentStoreException(id, e);

src/main/java/org/modeshape/jcr/query/optimize/RewriteIdentityJoins.java:87: error: NULL_DEREFERENCE
  object returned by `joinNode.getFirstChild()` could be null and is dereferenced at line 87.
  85.               JoinCondition condition = joinNode.getProperty(Property.JOIN_CONDITION, JoinCondition.class);
  86.               if (condition instanceof EquiJoinCondition) {
  87. >                 PlanNode leftNode = joinNode.getFirstChild().findAtOrBelow(Type.SOURCE);
  88.                   PlanNode rightNode = joinNode.getLastChild().findAtOrBelow(Type.SOURCE);
  89.                   assert leftNode != null;

src/main/java/org/modeshape/jcr/query/optimize/RewriteIdentityJoins.java:88: error: NULL_DEREFERENCE
  object returned by `joinNode.getLastChild()` could be null and is dereferenced at line 88.
  86.               if (condition instanceof EquiJoinCondition) {
  87.                   PlanNode leftNode = joinNode.getFirstChild().findAtOrBelow(Type.SOURCE);
  88. >                 PlanNode rightNode = joinNode.getLastChild().findAtOrBelow(Type.SOURCE);
  89.                   assert leftNode != null;
  90.                   assert rightNode != null;

src/main/java/org/modeshape/jcr/value/binary/FileSystemBinaryStore.java:97: error: RESOURCE_LEAK
  resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 97 is not released after line 97.
  95.               HashingInputStream hashingStream = SecureHash.createHashingStream(Algorithm.SHA_1, stream);
  96.               tmpFile = File.createTempFile(TEMP_FILE_PREFIX, TEMP_FILE_SUFFIX);
  97. >             IoUtil.write(hashingStream, new BufferedOutputStream(new FileOutputStream(tmpFile)),
  98.                            AbstractBinaryStore.MEDIUM_BUFFER_SIZE);
  99.               hashingStream.close();

src/main/java/org/modeshape/jcr/BackupDocumentReader.java:108: error: RESOURCE_LEAK
  resource of type `java.io.FileInputStream` acquired by call to `FileInputStream(...)` at line 107 is not released after line 108.
  106.           if (!currentFile.canRead() || !currentFile.isFile()) return null;
  107.           InputStream fileStream = new FileInputStream(currentFile);
  108. >         if (compressed) fileStream = new GZIPInputStream(fileStream);
  109.           return new BufferedInputStream(fileStream);
  110.       }

src/main/java/org/modeshape/connector/filesystem/JsonSidecarExtraPropertyStore.java:115: error: RESOURCE_LEAK
  resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 115 is not released after line 115.
  113.                   translator.setProperty(document, property, null, null);
  114.               }
  115. >             write(document, new FileOutputStream(sidecarFile));
  116.           } catch (IOException e) {
  117.               throw new DocumentStoreException(id, e);

src/main/java/org/modeshape/jcr/query/JcrQuery.java:130: error: RESOURCE_LEAK
  resource of type `org.modeshape.jcr.query.engine.process.RestartableSequence$QueueBufferSupplier` acquired by call to `JcrQueryResult(...)` at line 130 is not released after line 130.
**Note**: potential exception at line 130
  128.               return new JcrSqlQueryResult(context, statement, result, hints.restartable, hints.rowsKeptInMemory);
  129.           }
  130. >         return new JcrQueryResult(context, statement, result, hints.restartable, hints.rowsKeptInMemory);
  131.       }
  132.   

src/main/java/org/modeshape/jcr/CndImporter.java:121: error: NULL_DEREFERENCE
  object returned by `CndImporter.context.getValueFactories()` could be null and is dereferenced at line 121.
  119.           this.context = context.with(this.localRegistry);
  120.           this.valueFactory = new JcrValueFactory(this.context);
  121. >         this.nameFactory = this.context.getValueFactories().getNameFactory();
  122.           this.stringFactory = this.context.getValueFactories().getStringFactory();
  123.           this.nodeTypes = new LinkedList<NodeTypeDefinition>();

src/main/java/org/modeshape/jcr/query/optimize/ChooseJoinAlgorithm.java:140: error: NULL_DEREFERENCE
  object `condition` last assigned on line 121 could be null and is dereferenced by call to `createOrderBysForJoinCondition(...)` at line 140.
  138.                   List<Object> leftSortBy = new LinkedList<Object>();
  139.                   List<Object> rightSortBy = new LinkedList<Object>();
  140. >                 createOrderBysForJoinCondition(condition, leftSelectors, leftSortBy, rightSelectors, rightSortBy);
  141.   
  142.                   PlanNode leftSort = new PlanNode(Type.SORT, leftSelectors);

src/main/java/org/modeshape/jcr/query/optimize/ChooseJoinAlgorithm.java:136: error: NULL_DEREFERENCE
  object returned by `joinNode.getFirstChild()` could be null and is dereferenced at line 136.
  134.                   // We can try to use the merge join, but we need to sort and remove remove duplicates ...
  135.                   // on the left and right children of the join ...
  136. >                 Set<SelectorName> leftSelectors = joinNode.getFirstChild().getSelectors();
  137.                   Set<SelectorName> rightSelectors = joinNode.getLastChild().getSelectors();
  138.                   List<Object> leftSortBy = new LinkedList<Object>();

src/main/java/org/modeshape/jcr/query/optimize/ChooseJoinAlgorithm.java:137: error: NULL_DEREFERENCE
  object returned by `joinNode.getLastChild()` could be null and is dereferenced at line 137.
  135.                   // on the left and right children of the join ...
  136.                   Set<SelectorName> leftSelectors = joinNode.getFirstChild().getSelectors();
  137. >                 Set<SelectorName> rightSelectors = joinNode.getLastChild().getSelectors();
  138.                   List<Object> leftSortBy = new LinkedList<Object>();
  139.                   List<Object> rightSortBy = new LinkedList<Object>();

src/main/java/org/modeshape/jcr/federation/FederatedDocumentChanges.java:126: error: NULL_DEREFERENCE
  object `childrenMap` last assigned on line 125 could be null and is dereferenced at line 126.
  124.           for (String orderedBefore : sessionChildrenInsertedBeforeAnotherChild.keySet()) {
  125.               LinkedHashMap<String, Name> childrenMap = sessionChildrenInsertedBeforeAnotherChild.get(orderedBefore);
  126. >             for (String childId : childrenMap.keySet()) {
  127.                   sessionRemovedChildren.remove(childId);
  128.               }

src/main/java/org/modeshape/jcr/JcrVersionNode.java:128: error: NULL_DEREFERENCE
  object returned by `other.getProperty(org.modeshape.jcr.JcrLexicon.SUCCESSORS)` could be null and is dereferenced at line 128.
  126.           if (!other.hasProperty(JcrLexicon.SUCCESSORS)) return false;
  127.   
  128. >         Value[] successors = other.getProperty(JcrLexicon.SUCCESSORS).getValues();
  129.   
  130.           String id = getIdentifier();

src/main/java/org/modeshape/jcr/Connectors.java:138: error: NULL_DEREFERENCE
  object returned by `session.getWorkspace()` could be null and is dereferenced at line 138.
  136.               JcrSession session = repository.loginInternalSession(workspaceName);
  137.               try {
  138. >                 FederationManager federationManager = session.getWorkspace().getFederationManager();
  139.                   List<RepositoryConfiguration.ProjectionConfiguration> projections = current.getProjectionConfigurationsForWorkspace(workspaceName);
  140.                   for (RepositoryConfiguration.ProjectionConfiguration projectionCfg : projections) {

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:163: error: NULL_DEREFERENCE
  object returned by `getProperty(org.modeshape.jcr.JcrLexicon.VERSIONABLE_UUID)` could be null and is dereferenced at line 163.
  161.       @Override
  162.       public String getVersionableUUID() throws RepositoryException {
  163. >         return getProperty(JcrLexicon.VERSIONABLE_UUID).getString();
  164.       }
  165.   

src/main/java/org/modeshape/jcr/value/binary/FileSystemBinaryStore.java:187: error: RESOURCE_LEAK
  resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 187 is not released after line 187.
  185.           try {
  186.               if (!trashFile.exists() || !trashFile.canRead()) {
  187. >                 IoUtil.write("", new BufferedOutputStream(new FileOutputStream(trashFile)));
  188.               }
  189.               return trashFile;

src/main/java/org/modeshape/jcr/query/plan/PlanUtil.java:178: error: NULL_DEREFERENCE
  object `node` last assigned on line 175 could be null and is dereferenced at line 178.
  176.           }
  177.           // See if there are any PROJECT nodes below this node ...
  178. >         List<PlanNode> projects = node.findAllFirstNodesAtOrBelow(Type.PROJECT);
  179.           if (!projects.isEmpty()) {
  180.               List<String> types = new ArrayList<String>(columns.size());

src/main/java/org/modeshape/jcr/query/optimize/RewriteIdentityJoins.java:183: error: NULL_DEREFERENCE
  object `leftChild` last assigned on line 181 could be null and is dereferenced at line 183.
  181.           PlanNode leftChild = joinNode.getFirstChild();
  182.           joinNode.extractFromParent();
  183. >         PlanNode leftSource = leftChild.findAtOrBelow(Type.SOURCE);
  184.   
  185.           // Combine the right PROJECT node with that on the left ...

src/main/java/org/modeshape/jcr/query/optimize/RewriteIdentityJoins.java:177: error: NULL_DEREFERENCE
  object `rightChild` last assigned on line 176 could be null and is dereferenced at line 177.
  175.           // Remove the right source node from the join node ...
  176.           PlanNode rightChild = joinNode.getLastChild();
  177. >         rightChild.removeFromParent();
  178.           PlanNode rightSource = rightChild.findAtOrBelow(Type.SOURCE);
  179.   

src/main/java/org/modeshape/jcr/RepositoryQueryManager.java:177: error: RESOURCE_LEAK
  resource of type `org.modeshape.jcr.query.BufferManager` acquired by call to `BufferManager(...)` at line 177 is not released after line 177.
  175.                                      Map<String, Object> variables ) {
  176.           final QueryEngine queryEngine = queryEngine();
  177. >         final QueryContext queryContext = queryEngine.createQueryContext(context, repositoryCache, workspaceNames,
  178.                                                                            overriddenNodeCachesByWorkspaceName, schemata,
  179.                                                                            indexDefns, nodeTypes, new BufferManager(context),

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:210: error: NULL_DEREFERENCE
  object `predecessors` last assigned on line 203 could be null and is dereferenced at line 210.
  208.           // Remove the reference to the dead version from the successors property of all the predecessors
  209.           Set<JcrValue> addedValues = new HashSet<>();
  210. >         for (Value predecessorValue : predecessors.getValues()) {
  211.               addedValues.clear();
  212.               List<JcrValue> newNodeSuccessors = new ArrayList<>();

src/main/java/org/modeshape/jcr/Sequencers.java:205: error: NULL_DEREFERENCE
  object returned by `session.getWorkspace()` could be null and is dereferenced at line 205.
  203.               // Get a session that we'll pass to the sequencers to use for registering namespaces and node types
  204.               session = repository.loginInternalSession();
  205. >             NamespaceRegistry registry = session.getWorkspace().getNamespaceRegistry();
  206.               NodeTypeManager nodeTypeManager = session.getWorkspace().getNodeTypeManager();
  207.   

src/main/java/org/modeshape/jcr/xml/NodeImportXmlHandler.java:214: error: NULL_DEREFERENCE
  object returned by `localContext.getValueFactories()` could be null and is dereferenced at line 214.
  212.   
  213.           // Set up references to frequently-used objects in the context ...
  214. >         this.nameFactory = localContext.getValueFactories().getNameFactory();
  215.           this.pathFactory = localContext.getValueFactories().getPathFactory();
  216.           this.namespaceRegistry = localContext.getNamespaceRegistry();

src/main/java/org/modeshape/jcr/JcrQueryManager.java:203: error: NULL_DEREFERENCE
  object returned by `nodeType.getInternalName()` could be null and is dereferenced at line 203.
  201.           // Check the type of the node ...
  202.           JcrNodeType nodeType = jcrNode.getPrimaryNodeType();
  203. >         if (!nodeType.getInternalName().equals(JcrNtLexicon.QUERY)) {
  204.               NamespaceRegistry registry = session.context().getNamespaceRegistry();
  205.               throw new InvalidQueryException(JcrI18n.notStoredQuery.text(jcrNode.path().getString(registry)));

src/main/java/org/modeshape/jcr/JcrValue.java:280: error: NULL_DEREFERENCE
  object returned by `getDate()` could be null and is dereferenced at line 280.
  278.                           return this.getDecimal().equals(that.getDecimal());
  279.                       case PropertyType.DATE:
  280. >                         return this.getDate().equals(that.getDate());
  281.                       case PropertyType.PATH:
  282.                           return this.getString().equals(that.getString());

src/main/java/org/modeshape/jcr/JcrValue.java:278: error: NULL_DEREFERENCE
  object returned by `getDecimal()` could be null and is dereferenced at line 278.
  276.                           return this.getLong() == that.getLong();
  277.                       case PropertyType.DECIMAL:
  278. >                         return this.getDecimal().equals(that.getDecimal());
  279.                       case PropertyType.DATE:
  280.                           return this.getDate().equals(that.getDate());

src/main/java/org/modeshape/jcr/JcrDocumentViewExporter.java:222: error: NULL_DEREFERENCE
  object returned by `value.getBinary()` could be null and is dereferenced at line 222.
  220.           if (PropertyType.BINARY == propertyType) {
  221.               try {
  222. >                 Base64.InputStream is = new Base64.InputStream(value.getBinary().getStream(), Base64.ENCODE);
  223.                   return IoUtil.read(is);
  224.               } catch (IOException ioe) {

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:228: error: RESOURCE_LEAK
  resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 228 is not released after line 228.
  226.               SecureHash.HashingInputStream hashingStream = SecureHash.createHashingStream(SecureHash.Algorithm.SHA_1, inputStream);
  227.               tmpFile = File.createTempFile("ms-ispn-binstore", "hashing");
  228. >             IoUtil.write(hashingStream, new BufferedOutputStream(new FileOutputStream(tmpFile)),
  229.                            AbstractBinaryStore.MEDIUM_BUFFER_SIZE);
  230.               final BinaryKey binaryKey = new BinaryKey(hashingStream.getHash());

src/main/java/org/modeshape/jcr/query/optimize/PushSelectCriteria.java:227: error: NULL_DEREFERENCE
  object `joinType` last assigned on line 225 could be null and is dereferenced at line 227.
  225.           JoinType joinType = (JoinType)joinNode.getProperty(Property.JOIN_TYPE);
  226.   
  227. >         switch (joinType) {
  228.               case CROSS:
  229.                   joinNode.setProperty(Property.JOIN_TYPE, JoinType.INNER);

src/main/java/org/modeshape/jcr/Connectors.java:252: error: NULL_DEREFERENCE
  object `systemRoot` last assigned on line 251 could be null and is dereferenced at line 252.
  250.       private CachedNode getSystemNode( SessionCache systemSession ) {
  251.           CachedNode systemRoot = systemSession.getNode(systemSession.getRootKey());
  252. >         ChildReference systemNodeRef = systemRoot.getChildReferences(systemSession).getChild(JcrLexicon.SYSTEM);
  253.           assert systemNodeRef != null;
  254.           return systemSession.getNode(systemNodeRef.getKey());

src/main/java/org/modeshape/jcr/Upgrades.java:262: error: NULL_DEREFERENCE
  object returned by `session.getWorkspace()` could be null and is dereferenced at line 262.
  260.                       JcrSession session = runningState.loginInternalSession(workspaceName);
  261.                       try {
  262. >                         JcrQueryManager queryManager = session.getWorkspace().getQueryManager();
  263.                           Query query = queryManager.createQuery(
  264.                                   "select [jcr:name] from [" + ModeShapeLexicon.ACCESS_CONTROLLABLE_STRING + "]",

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:256: error: NULL_DEREFERENCE
  object returned by `getParentKey(cache)` could be null and is dereferenced by call to `getChildReference(...)` at line 256.
  254.           return currentReferences.supportsGetChildReferenceByKey() ?
  255.                  currentReferences.getChild(key) :
  256. >                cache.getChildReference(getParentKey(cache), key);
  257.       }
  258.   

src/main/java/org/modeshape/jcr/Connectors.java:264: error: NULL_DEREFERENCE
  object returned by `session.getWorkspace()` could be null and is dereferenced at line 264.
  262.               // Get a session that we'll pass to the connectors to use for registering namespaces and node types
  263.               session = repository.loginInternalSession();
  264. >             NamespaceRegistry registry = session.getWorkspace().getNamespaceRegistry();
  265.               NodeTypeManager nodeTypeManager = session.getWorkspace().getNodeTypeManager();
  266.   

src/main/java/org/modeshape/jcr/value/binary/FileLocks.java:279: error: RESOURCE_LEAK
  resource of type `java.io.RandomAccessFile` acquired by call to `RandomAccessFile(...)` at line 275 is not released after line 279.
  277.                   // Create a exclusive (non-shared) lock that does not allow other readers ...
  278.                   if (block) {
  279. >                     fileLock = channel.lock(0, Long.MAX_VALUE, false);
  280.                   } else {
  281.                       fileLock = channel.tryLock(0, Long.MAX_VALUE, false);

src/main/java/org/modeshape/jcr/value/binary/FileLocks.java:307: error: RESOURCE_LEAK
  resource of type `java.io.RandomAccessFile` acquired by call to `RandomAccessFile(...)` at line 303 is not released after line 307.
  305.                       // Create a shared lock that allows other readers ...
  306.                       if (block) {
  307. >                         fileLock = channel.lock(0, Long.MAX_VALUE, true);
  308.                       } else {
  309.                           fileLock = channel.tryLock(0, Long.MAX_VALUE, true);

src/main/java/org/modeshape/jcr/query/plan/PlanUtil.java:308: error: NULL_DEREFERENCE
  object `columns` last assigned on line 307 could be null and is dereferenced at line 308.
  306.               case PROJECT:
  307.                   List<Column> columns = planNode.getPropertyAsList(Property.PROJECT_COLUMNS, Column.class);
  308. >                 for (int i = 0; i != columns.size(); ++i) {
  309.                       Column column = columns.get(i);
  310.                       SelectorName replacement = rewrittenSelectors.get(column.selectorName());

src/main/java/org/modeshape/jcr/query/optimize/PushSelectCriteria.java:342: error: NULL_DEREFERENCE
  object returned by `node.getFirstChild()` could be null and is dereferenced at line 342.
  340.               } else if (node.getType() == Type.LIMIT) {
  341.                   // Don't push below a LIMIT above a SORT ...
  342. >                 if (node.getChildCount() == 1 && node.getFirstChild().getType() == Type.SORT) {
  343.                       return node;
  344.                   }

src/main/java/org/modeshape/jcr/JcrNodeType.java:344: error: NULL_DEREFERENCE
  object `null` is dereferenced by call to `canRemoveItem(...)` at line 344.
  342.           CheckArg.isNotNull(itemName, "itemName");
  343.           Name childName = context.getValueFactories().getNameFactory().create(itemName);
  344. >         return nodeTypes().canRemoveItem(this.name, null, childName, true);
  345.       }
  346.   

src/main/java/org/modeshape/jcr/cache/document/DocumentTranslator.java:346: error: NULL_DEREFERENCE
  object returned by `getProperty(document,org.modeshape.jcr.JcrLexicon.PRIMARY_TYPE)` could be null and is dereferenced at line 346.
  344.   
  345.       public String getPrimaryTypeName( Document document ) {
  346. >         return strings.create(getProperty(document, JcrLexicon.PRIMARY_TYPE).getFirstValue());
  347.       }
  348.   

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:373: error: NULL_DEREFERENCE
  object returned by `properties()` could be null and is dereferenced at line 373.
  371.       @Override
  372.       public int getPropertyCount( NodeCache cache ) {
  373. >         if (propertiesFullyLoaded) return properties().size();
  374.           WorkspaceCache wsCache = workspaceCache(cache);
  375.           return wsCache.translator().countProperties(document(wsCache));

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:381: error: NULL_DEREFERENCE
  object `props` last assigned on line 380 could be null and is dereferenced at line 381.
  379.       public boolean hasProperties( NodeCache cache ) {
  380.           Map<Name, Property> props = properties();
  381. >         if (!props.isEmpty()) return true;
  382.           if (propertiesFullyLoaded) return false;
  383.           WorkspaceCache wsCache = workspaceCache(cache);

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:387: error: NULL_DEREFERENCE
  object `parent` last assigned on line 386 could be null and is dereferenced at line 387.
  385.               for (NodeKey parentKey : additionalParents.getAdditions()) {
  386.                   CachedNode parent = cache.getNode(parentKey);
  387. >                 if (parent.getPath(cache).isAtOrBelow(path)) {
  388.                       return true;
  389.                   }

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:391: error: NULL_DEREFERENCE
  object `props` last assigned on line 390 could be null and is dereferenced at line 391.
  389.                                   NodeCache cache ) {
  390.           Map<Name, Property> props = properties();
  391. >         if (props.containsKey(name)) return true;
  392.           if (propertiesFullyLoaded) return false;
  393.           WorkspaceCache wsCache = workspaceCache(cache);

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:401: error: NULL_DEREFERENCE
  object `props` last assigned on line 400 could be null and is dereferenced at line 401.
  399.                                    NodeCache cache ) {
  400.           Map<Name, Property> props = properties();
  401. >         Property property = props.get(name);
  402.           if (property == null && !propertiesFullyLoaded) {
  403.               WorkspaceCache wsCache = workspaceCache(cache);

src/main/java/org/modeshape/jcr/query/QueryBuilder.java:412: error: NULL_DEREFERENCE
  object `oldName` last assigned on line 408 could be null and is dereferenced by call to `equals(...)` at line 412.
  410.           for (int i = 0; i != columns.size(); ++i) {
  411.               Column old = columns.get(i);
  412. >             if (old.selectorName().equals(oldName)) {
  413.                   columns.set(i, new Column(allNodes.aliasOrName(), old.getPropertyName(), old.getColumnName()));
  414.               }

src/main/java/org/modeshape/jcr/value/binary/FileSystemBinaryStore.java:421: error: RESOURCE_LEAK
  resource of type `java.io.RandomAccessFile` acquired to `raf` by call to `RandomAccessFile(...)` at line 409 is not released after line 421.
**Note**: potential exception at line 410
  419.                   }
  420.               }
  421. >         } catch (IOException e) {
  422.               throw new BinaryStoreException(e);
  423.           }

src/main/java/org/modeshape/jcr/value/binary/CompositeBinaryStore.java:430: error: NULL_DEREFERENCE
  object `namedBinaryStore` last assigned on line 427 could be null and is dereferenced at line 430.
  428.           }
  429.   
  430. >         logger.trace("Selected binary store: " + namedBinaryStore.toString());
  431.   
  432.           return namedBinaryStore;

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:422: error: NULL_DEREFERENCE
  object returned by `LazyCachedNode$1.this$0.properties()` could be null and is dereferenced at line 422.
  420.               @Override
  421.               public Property getProperty( Name name ) {
  422. >                 return properties().get(name);
  423.               }
  424.   

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:427: error: NULL_DEREFERENCE
  object returned by `LazyCachedNode$1.this$0.properties()` could be null and is dereferenced at line 427.
  425.               @Override
  426.               public Iterator<Property> iterator() {
  427. >                 return properties().values().iterator();
  428.               }
  429.           };

src/main/java/org/modeshape/jcr/query/QueryBuilder.java:433: error: NULL_DEREFERENCE
  object `oldName` last assigned on line 429 could be null and is dereferenced by call to `equals(...)` at line 433.
  431.           for (int i = 0; i != columns.size(); ++i) {
  432.               Column old = columns.get(i);
  433. >             if (old.selectorName().equals(oldName)) {
  434.                   columns.set(i, new Column(selector.aliasOrName(), old.getPropertyName(), old.getColumnName()));
  435.               }

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:439: error: NULL_DEREFERENCE
  object returned by `properties()` could be null and is dereferenced at line 439.
  437.               this.propertiesFullyLoaded = true;
  438.           }
  439. >         return properties().values().iterator();
  440.       }
  441.   

src/main/java/org/modeshape/jcr/query/validate/ImmutableSchemata.java:546: error: RESOURCE_LEAK
  resource of type `org.modeshape.jcr.query.BufferManager` acquired to `bufferManager` by call to `BufferManager(...)` at line 448 is not released after line 546.
  544.                       added = true;
  545.                   }
  546. >             } while (added && !definitions.isEmpty());
  547.   
  548.               if (!definitions.isEmpty()) {

src/main/java/org/modeshape/jcr/JcrContentHandler.java:532: error: NULL_DEREFERENCE
  object returned by `node()` could be null and is dereferenced at line 532.
  530.           protected String name() {
  531.               try {
  532. >                 Path path = node().path();
  533.                   return path.isRoot() ? "" : stringFor(path.getLastSegment());
  534.               } catch (Exception e) {

src/main/java/org/modeshape/jcr/JcrContentHandler.java:546: error: NULL_DEREFERENCE
  object returned by `node()` could be null and is dereferenced at line 546.
  544.               }
  545.               try {
  546. >                 return node().getPath();
  547.               } catch (Throwable e) {
  548.                   try {

src/main/java/org/modeshape/jcr/federation/ExternalDocumentStore.java:548: error: NULL_DEREFERENCE
  object returned by `localStore()` could be null and is dereferenced at line 548.
  546.       public EditableDocument edit(String key, boolean createIfMissing, boolean acquireLock) {
  547.           if (isLocalSource(key)) {
  548. >             return localStore().edit(key, createIfMissing, acquireLock);
  549.           }
  550.           return null;

src/main/java/org/modeshape/jcr/value/binary/FileSystemBinaryStore.java:578: error: RESOURCE_LEAK
  resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 578 is not released after line 578.
  576.           try {
  577.               tmpFile = File.createTempFile(TEMP_FILE_PREFIX, TEMP_FILE_SUFFIX + EXTRACTED_TEXT_SUFFIX);
  578. >             IoUtil.write(string, new BufferedOutputStream(new FileOutputStream(tmpFile)));
  579.               saveTempFileToStore(tmpFile, key, tmpFile.length());
  580.           } catch (IOException e) {

src/main/java/org/modeshape/jcr/BackupService.java:588: error: NULL_DEREFERENCE
  object returned by `BackupService$Activity.binaryDirectory.listFiles()` could be null and is dereferenced at line 588.
  586.   
  587.           public void restoreBinaryFiles() {
  588. >             for (File segment1Dir : binaryDirectory.listFiles()) {
  589.                   for (File segment2Dir : segment1Dir.listFiles()) {
  590.                       for (File segment3Dir : segment2Dir.listFiles()) {

src/main/java/org/modeshape/jcr/value/binary/FileSystemBinaryStore.java:627: error: NULL_DEREFERENCE
  object returned by `FileSystemBinaryStore.directory.listFiles()` could be null and is dereferenced at line 627.
  625.           // Iterate over all of the files in the directory structure (excluding trash) and assemble the results ...
  626.           if (isReadableDir(directory)) {
  627. >             for (File first : directory.listFiles()) {
  628.                   if (isReadableDir(first)) {
  629.                       for (File second : first.listFiles()) {

src/main/java/org/modeshape/jcr/cache/RepositoryCache.java:686: error: NULL_DEREFERENCE
  object `systemRoot` last assigned on line 685 could be null and is dereferenced at line 686.
  684.           NodeKey systemRootKey = systemSession.getRootKey();
  685.           CachedNode systemRoot = systemSession.getNode(systemRootKey);
  686. >         ChildReference systemRef = systemRoot.getChildReferences(systemSession).getChild(JcrLexicon.SYSTEM);
  687.           return systemSession.mutable(systemRef.getKey());
  688.       }

src/main/java/org/modeshape/jcr/JcrContentHandler.java:720: error: NULL_DEREFERENCE
  object `parent` last assigned on line 719 could be null and is dereferenced at line 720.
  718.               try {
  719.                   AbstractJcrNode parent = parentHandler.node();
  720. >                 final NodeKey parentKey = parent.key();
  721.                   assert parent != null;
  722.   

src/main/java/org/modeshape/jcr/JcrPropertyDefinition.java:813: error: NULL_DEREFERENCE
  object returned by `value.getBinary()` could be null and is dereferenced at line 813.
  811.               try {
  812.                   JcrValue jcrValue = (JcrValue)value;
  813. >                 long thatSize = value.getBinary().getSize();
  814.                   JcrValue sizeValue = new JcrValue(jcrValue.factories(), PropertyType.LONG, thatSize);
  815.                   return super.matches(sizeValue, session);

src/main/java/org/modeshape/jcr/JcrVersionManager.java:947: error: NULL_DEREFERENCE
  object `prop` last assigned on line 945 could be null and is dereferenced at line 947.
  945.           AbstractJcrProperty prop = targetNode.getProperty(JcrLexicon.PREDECESSORS);
  946.   
  947. >         JcrValue[] values = prop.getValues();
  948.           JcrValue[] newValues = new JcrValue[values.length + 1];
  949.           System.arraycopy(values, 0, newValues, 0, values.length);

src/main/java/org/modeshape/jcr/query/engine/ScanningQueryEngine.java:960: error: NULL_DEREFERENCE
  object `index` last assigned on line 959 could be null and is dereferenced by call to `createNodeSequenceForSource(...)` at line 960.
  958.               if (indexNode.getType() != Type.INDEX) continue;
  959.               IndexPlan index = indexNode.getProperty(Property.INDEX_SPECIFICATION, IndexPlan.class);
  960. >             NodeSequence sequence = createNodeSequenceForSource(originalQuery, context, sourceNode, index, columns, sources);
  961.               if (sequence != null) {
  962.                   // Mark the index as being used ...

src/main/java/org/modeshape/jcr/JcrVersionManager.java:984: error: NULL_DEREFERENCE
  object `prop` last assigned on line 983 could be null and is dereferenced at line 984.
  982.   
  983.           AbstractJcrProperty prop = targetNode.getProperty(JcrLexicon.MERGE_FAILED);
  984. >         Value[] values = prop.getValues();
  985.   
  986.           List<Value> newValues = new ArrayList<Value>();

src/main/java/org/modeshape/jcr/query/plan/PlanUtil.java:1059: error: NULL_DEREFERENCE
  object `projectedColumns` last assigned on line 1053 could be null and is dereferenced at line 1059.
  1057.   
  1058.           for (int i = 0; i != viewColumns.size(); ++i) {
  1059. >             Column projectedColunn = projectedColumns.get(i);
  1060.               String viewColumnName = viewColumns.get(i).getName();
  1061.               mapping.map(viewColumnName, projectedColunn);

src/main/java/org/modeshape/jcr/query/plan/PlanUtil.java:1063: error: NULL_DEREFERENCE
  object `projectedColumns` last assigned on line 1053 could be null and is dereferenced at line 1063.
  1061.               mapping.map(viewColumnName, projectedColunn);
  1062.           }
  1063. >         if (viewColumns.size() < projectedColumns.size()) {
  1064.               // There are some extra projected columns, likely because the view did not know about them ...
  1065.               for (int i = viewColumns.size(); i != projectedColumns.size(); ++i) {

src/main/java/org/modeshape/jcr/query/plan/PlanUtil.java:1091: error: NULL_DEREFERENCE
  object `projectedColumns` last assigned on line 1085 could be null and is dereferenced at line 1091.
  1089.   
  1090.           for (int i = 0; i != viewColumns.size(); ++i) {
  1091. >             Column projectedColunn = projectedColumns.get(i);
  1092.               String viewColumnName = viewColumns.get(i).getName();
  1093.               mapping.map(viewColumnName, projectedColunn);

src/main/java/org/modeshape/jcr/query/plan/PlanUtil.java:1096: error: NULL_DEREFERENCE
  object `projectedColumns` last assigned on line 1085 could be null and is dereferenced at line 1096.
  1094.           }
  1095.   
  1096. >         if (viewColumns.size() < projectedColumns.size()) {
  1097.               // There are some extra projected columns, likely because the view did not know about them ...
  1098.               for (int i = viewColumns.size(); i != projectedColumns.size(); ++i) {

src/main/java/org/modeshape/jcr/RepositoryConfiguration.java:1193: error: NULL_DEREFERENCE
  object `store` last assigned on line 1192 could be null and is dereferenced at line 1193.
  1191.               }
  1192.               if (store == null) store = TransientBinaryStore.get();
  1193. >             store.setMinimumBinarySizeInBytes(getMinimumBinarySizeInBytes());
  1194.               return store;
  1195.           }

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1253: error: NULL_DEREFERENCE
  object returned by `child.getParentKey(session)` could be null and is dereferenced at line 1253.
  1251.           // First, manipulate the child node. But we have to see whether this node is a primary parent or an additional parent ...
  1252.           SessionNode child = session.mutable(childKey);
  1253. >         if (child.getParentKey(session).equals(this.key)) {
  1254.               // The child's parent is this node. If there are additional parents, then we should pick the first additional parent
  1255.               // and use it as the new primary parent ...

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1357: error: NULL_DEREFERENCE
  object `childPrimaryType` last assigned on line 1356 could be null and is dereferenced at line 1357.
  1355.                       // We've not already created a child with this name ...
  1356.                       JcrNodeType childPrimaryType = defn.getDefaultPrimaryType();
  1357. >                     addChildNode(childName, childPrimaryType.getInternalName(), null, false, false);
  1358.                   }
  1359.               }

src/main/java/org/modeshape/jcr/query/plan/PlanUtil.java:1411: error: NULL_DEREFERENCE
  object `projected` last assigned on line 1408 could be null and is dereferenced at line 1411.
  1409.           List<String> projectedTypes = project.getPropertyAsList(Property.PROJECT_COLUMN_TYPES, String.class);
  1410.           Set<String> projectedPropertyNames = new HashSet<String>();
  1411. >         for (Column p : projected) {
  1412.               projectedPropertyNames.add(p.getPropertyName());
  1413.           }

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1441: error: NULL_DEREFERENCE
  object returned by `SessionNode.federatedSegments.get()` could be null and is dereferenced at line 1441.
  1439.               federatedSegments.compareAndSet(null, new FederatedSegmentChanges());
  1440.           }
  1441. >         this.federatedSegments.get().addSegment(externalNodeKey, segmentName);
  1442.       }
  1443.   

src/main/java/org/modeshape/jcr/query/plan/PlanUtil.java:1450: error: NULL_DEREFERENCE
  object `select.parent` last assigned on line 1450 could be null and is dereferenced by call to `extractFromParent()` at line 1450.
  1448.                   if (!existingCriteria.add(constraint)) {
  1449.                       // It was already found, so remove this node ...
  1450. >                     select.extractFromParent();
  1451.                   }
  1452.               }

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1453: error: NULL_DEREFERENCE
  object returned by `SessionNode.federatedSegments.get()` could be null and is dereferenced at line 1453.
  1451.               federatedSegments.compareAndSet(null, new FederatedSegmentChanges());
  1452.           }
  1453. >         this.federatedSegments.get().removeSegment(externalNodeKey);
  1454.       }
  1455.   

src/main/java/org/modeshape/jcr/JcrSession.java:1649: error: NULL_DEREFERENCE
  object returned by `getRepository().getDescriptorValue("option.lifecycle.supported")` could be null and is dereferenced at line 1649.
  1647.           }
  1648.   
  1649. >         boolean retainLifecycleInfo = getRepository().getDescriptorValue(Repository.OPTION_LIFECYCLE_SUPPORTED).getBoolean();
  1650.           boolean retainRetentionInfo = getRepository().getDescriptorValue(Repository.OPTION_RETENTION_SUPPORTED).getBoolean();
  1651.   

src/main/java/org/modeshape/jcr/JcrSession.java:1650: error: NULL_DEREFERENCE
  object returned by `getRepository().getDescriptorValue("option.retention.supported")` could be null and is dereferenced at line 1650.
  1648.   
  1649.           boolean retainLifecycleInfo = getRepository().getDescriptorValue(Repository.OPTION_LIFECYCLE_SUPPORTED).getBoolean();
  1650. >         boolean retainRetentionInfo = getRepository().getDescriptorValue(Repository.OPTION_RETENTION_SUPPORTED).getBoolean();
  1651.   
  1652.           return new JcrContentHandler(this, parent, uuidBehavior, false, retainRetentionInfo, retainLifecycleInfo);

src/main/java/org/modeshape/jcr/query/engine/ScanningQueryEngine.java:1647: error: NULL_DEREFERENCE
  object returned by `ScanningQueryEngine$16.val$fts.getTerm()` could be null and is dereferenced at line 1647.
  1645.                        * (RowExtractors.extractFullText) and in the term where the regex is built
  1646.                        */
  1647. >                     return fts.getTerm().matches(leftHandValue.toString());
  1648.                   }
  1649.               };

src/main/java/org/modeshape/jcr/RepositoryConfiguration.java:1890: error: NULL_DEREFERENCE
  object `defn` last assigned on line 1888 could be null and is dereferenced at line 1890.
  1888.                   IndexDefinition defn = getIndex(indexName);
  1889.                   // Make sure the index has a valid provider ...
  1890. >                 if (defn.getProviderName() == null) {
  1891.                       problems.addError(JcrI18n.indexProviderNameRequired, indexName);
  1892.                   } else if (!hasIndexProvider(defn.getProviderName())) {

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:2842: error: NULL_DEREFERENCE
  object `placeholder` last assigned on line 2840 could be null and is dereferenced at line 2842.
  2840.                       CachedNode placeholder = targetCache.getNode(placeholderKey);
  2841.                       // Get the parent and the child reference ...
  2842. >                     NodeKey parentKey = placeholder.getParentKey(targetCache);
  2843.                       MutableCachedNode parent = targetCache.mutable(parentKey);
  2844.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3294: error: NULL_DEREFERENCE
  object returned by `getProperty(org.modeshape.jcr.JcrLexicon.BASE_VERSION)` could be null and is dereferenced at line 3294.
  3292.               throw new UnsupportedRepositoryOperationException(JcrI18n.requiresVersionable.text());
  3293.           }
  3294. >         NodeKey baseVersionKey = ((NodeKeyReference)getProperty(JcrLexicon.BASE_VERSION).getValue().value()).getNodeKey();
  3295.           try {
  3296.               return (JcrVersionNode)session().node(baseVersionKey, null);

src/main/java/org/modeshape/jcr/query/parse/QueryParsers.java:47: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String QueryParser.getLanguage()` of un-annotated interface `org.modeshape.jcr.query.parse.QueryParser`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  45.           if (parsers != null) {
  46.               for (QueryParser parser : parsers) {
  47. >                 if (parser != null) addLanguage(parser);
  48.               }
  49.           }

src/main/java/org/modeshape/jcr/query/parse/QueryParsers.java:58: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String QueryParser.getLanguage()` of un-annotated interface `org.modeshape.jcr.query.parse.QueryParser`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  56.        */
  57.       public QueryParsers( Iterable<QueryParser> parsers ) {
  58. >         if (parsers != null) addLanguages(parsers);
  59.       }
  60.   

src/main/java/org/modeshape/jcr/cache/document/BucketedChildReferences.java:69: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `List Document.getArray(String)` of un-annotated interface `org.infinispan.schematic.document.Document`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  67.           this.translator = translator;
  68.           
  69. >         List<?> bucketsArray = parent.getArray(DocumentConstants.BUCKETS);
  70.           if (bucketsArray == null) {
  71.               this.bucketIds = Collections.emptySet();

src/main/java/org/modeshape/jcr/cache/document/ReadOnlySessionCache.java:40: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `int Transaction.getStatus()` of un-annotated interface `javax.transaction.Transaction`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  38.                                    WorkspaceCache workspaceCache,
  39.                                    RepositoryEnvironment repositoryEnvironment ) {
  40. >         super(context, workspaceCache, repositoryEnvironment);
  41.       }
  42.   

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:143: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `int Transaction.getStatus()` of un-annotated interface `javax.transaction.Transaction`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  141.                                    WorkspaceCache workspaceCache,
  142.                                    RepositoryEnvironment repositoryEnvironment ) {
  143. >         super(context, workspaceCache, repositoryEnvironment);
  144.           this.changedNodes = new HashMap<NodeKey, SessionNode>();
  145.           this.changedNodesInOrder = new LinkedHashSet<NodeKey>();

src/main/java/org/modeshape/jcr/SystemNamespaceRegistry.java:56: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String NamespaceRegistry$Namespace.getNamespaceUri()` of un-annotated interface `org.modeshape.jcr.value.NamespaceRegistry$Namespace`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  54.           this.cache = new SimpleNamespaceRegistry();
  55.           // Pre-load all of the built-in namespaces ...
  56. >         this.cache.register(new ExecutionContext().getNamespaceRegistry().getNamespaces());
  57.       }
  58.   

src/main/java/org/modeshape/jcr/RepositoryNodeTypeManager.java:112: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Collection Multimap.get(Object)` of un-annotated interface `org.modeshape.common.collection.Multimap`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  110.           PathFactory pathFactory = this.context.getValueFactories().getPathFactory();
  111.           this.nodeTypesPath = pathFactory.createAbsolutePath(JcrLexicon.SYSTEM, JcrLexicon.NODE_TYPES);
  112. >         this.nodeTypesCache = new NodeTypes(this.context);
  113.   
  114.           this.includeColumnsForInheritedProperties = includeColumnsForInheritedProperties;

src/main/java/org/modeshape/jcr/Connectors.java:100: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Iterable Document.fields()` of un-annotated interface `org.infinispan.schematic.document.Document`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  98.           this.repository = repository;
  99.           this.logger = Logger.getLogger(getClass());
  100. >         this.snapshot.set(new Snapshot(components, externalSources, preconfiguredProjections));
  101.       }
  102.   

src/main/java/org/modeshape/jcr/RepositoryIndexManager.java:131: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void Problems.addError(I18n,java.lang.Object[])` of un-annotated interface `org.modeshape.common.collection.Problems`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  129.   
  130.           // Set up the index providers ...
  131. >         this.components = config.getIndexProviders();
  132.           for (Component component : components) {
  133.               try {

src/main/java/org/modeshape/jcr/RepositoryIndexManager.java:135: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `RepositoryIndexManager.<init>(JcrRepository$RunningState,RepositoryConfiguration)` indirectly reads with synchronization from container `byProvider` via call to `get`. Potentially races with unsynchronized write in method `RepositoryIndexManager.registerIndexes(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  133.               try {
  134.                   IndexProvider provider = component.createInstance(ScanningQueryEngine.class.getClassLoader());
  135. >                 register(provider);
  136.               } catch (Throwable t) {
  137.                   if (t.getCause() != null) {

src/main/java/org/modeshape/jcr/RepositoryLockManager.java:82: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `int Document.getInteger(String,int)` of un-annotated interface `org.infinispan.schematic.document.Document`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  80.           this.locksPath = pathFactory.create(pathFactory.createRootPath(), JcrLexicon.SYSTEM, ModeShapeLexicon.LOCKS);
  81.           this.logger = Logger.getLogger(getClass());
  82. >         long lockGCIntervalMillis = gcConfig.getIntervalInMillis();
  83.           assert lockGCIntervalMillis > 0;
  84.           

src/main/java/org/modeshape/jcr/JcrNodeType.java:177: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean Multimap.containsKey(Object)` of un-annotated interface `org.modeshape.common.collection.Multimap`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  175.           this.thisAndAllSupertypesNames = Collections.unmodifiableSet(typeNames);
  176.   
  177. >         this.allDefinitions = new DefinitionCache(this);
  178.           this.key = prototypeKey.withId("/jcr:system/jcr:nodeTypes/" + name.getString());
  179.       }

src/main/java/org/modeshape/jcr/JcrNodeType.java:178: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `JcrNodeType.<init>(NodeKey,ExecutionContext,JcrSession,RepositoryNodeTypeManager,Name,List,Name,Collection,Collection,boolean,boolean,boolean,boolean)` indirectly writes to field `prototypeKey.sourceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  176.   
  177.           this.allDefinitions = new DefinitionCache(this);
  178. >         this.key = prototypeKey.withId("/jcr:system/jcr:nodeTypes/" + name.getString());
  179.       }
  180.   

src/main/java/org/modeshape/jcr/journal/ClusteredJournal.java:66: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `ClusteredJournal.<init>(LocalJournal,ClusteringService)` indirectly writes to field `localJournal.searchTimeDelta` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  64.   
  65.           this.clusteringService = clusteringService;
  66. >         this.localJournal = localJournal.withSearchTimeDelta(clusteringService.getMaxAllowedClockDelayMillis());
  67.       }
  68.   

src/main/java/org/modeshape/jcr/cache/document/BucketId.java:36: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getString()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  34.   
  35.       protected BucketId( Name name, int length ) {
  36. >         this(name.getString(), length);
  37.       }
  38.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3401: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void ItemVisitor.visit(Node)` of un-annotated interface `javax.jcr.ItemVisitor`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  3399.           CheckArg.isNotNull(visitor, "visitor");
  3400.           checkSession();
  3401. >         visitor.visit(this);
  3402.       }
  3403.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void ItemVisitor.visit(Node)` of un-annotated interface `javax.jcr.ItemVisitor`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`.
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:1549: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `SessionNode WritableSessionCache.add(SessionNode)` reads with synchronization from `this.changedNodes`. Potentially races with unsynchronized write in method `WritableSessionCache.clearState()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1547.               lock.lock();
  1548.               NodeKey key = newNode.getKey();
  1549. >             SessionNode node = changedNodes.put(key, newNode);
  1550.               if (node != null) {
  1551.                   if (node != REMOVED) {

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:1558: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `SessionNode WritableSessionCache.add(SessionNode)` reads with synchronization from `this.replacedNodes`. Potentially races with unsynchronized write in method `WritableSessionCache.clearState()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1556.                   // Otherwise, a node with the same key was removed by this session before creating a new
  1557.                   // node with the same ID ...
  1558. >                 if (replacedNodes == null) {
  1559.                       replacedNodes = new HashSet<NodeKey>();
  1560.                   }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:994: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrNode AbstractJcrNode.addAclNode(String,String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  992.           ConstraintViolationException, RepositoryException {
  993.           checkSession();
  994. >         return addNode(relPath, primaryNodeTypeName, null, true);
  995.       }
  996.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1195: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void MutableCachedNode.addInternalProperty(String,Object)` of un-annotated interface `org.modeshape.jcr.cache.MutableCachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1193.               // we're adding a new unordered collection so we need to set some internal (non JCR) information
  1194.               int bucketIdLength = nodeTypes.getBucketIdLengthForUnorderedCollection(childPrimaryNodeTypeName, null);
  1195. >             newChild.addInternalProperty(DocumentConstants.BUCKET_ID_LENGTH, bucketIdLength);
  1196.           }
  1197.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1167: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `AbstractJcrNode AbstractJcrNode.addChildNode(Name,Name,NodeKey,boolean,boolean)` indirectly reads without synchronization from `nodeKey.workspaceKey`. Potentially races with write in method `AbstractJcrNode.addNode(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1165.   
  1166.               // And get or create the JCR node ...
  1167. >             AbstractJcrNode jcrNode = session.node(newChild.getKey(), null, key());
  1168.   
  1169.               // Set the child node definition ...

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1112: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrNode AbstractJcrNode.addChildNode(Name,Name,NodeKey,boolean,boolean)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1110.           }
  1111.   
  1112. >         if (isLockedByAnotherSession()) {
  1113.               throw new LockException(JcrI18n.lockTokenNotHeld.text(location()));
  1114.           }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1109: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrNode AbstractJcrNode.addChildNode(Name,Name,NodeKey,boolean,boolean)` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1107.   
  1108.           if (!aclScope) {
  1109. >             session.checkPermission(this, ModeShapePermissions.ADD_NODE);
  1110.           }
  1111.   

src/main/java/org/modeshape/jcr/query/engine/ScanningQueryEngine.java:3060: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ScanningQueryEngine$ScanQueryContext.addColumnsFor(PlanNode,QueryResults$Columns)` mutates container `this.columnsByPlanNode` via call to `put` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3058.           public void addColumnsFor( PlanNode node,
  3059.                                      Columns columns ) {
  3060. >             columnsByPlanNode.put(node, columns);
  3061.           }
  3062.   

src/main/java/org/modeshape/jcr/JcrObservationManager.java:162: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JcrObservationManager.addEventListener(EventListener,int,String,boolean,java.lang.String[],java.lang.String[],boolean)` indirectly reads without synchronization from `this.session.context`. Potentially races with write in method `JcrObservationManager.setUserData(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  160.                                     boolean noLocal ) throws RepositoryException {
  161.           CheckArg.isNotNull(listener, "listener");
  162. >         checkSession(); // make sure session is still active
  163.   
  164.           // create wrapper and register

src/main/java/org/modeshape/jcr/query/parse/QueryParsers.java:69: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String QueryParser.getLanguage()` of un-annotated interface `org.modeshape.jcr.query.parse.QueryParser`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  67.       public void addLanguage( QueryParser languageParser ) {
  68.           CheckArg.isNotNull(languageParser, "languageParser");
  69. >         this.parsers.put(languageParser.getLanguage().trim().toLowerCase(), languageParser);
  70.       }
  71.   

src/main/java/org/modeshape/jcr/query/parse/QueryParsers.java:96: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String QueryParser.getLanguage()` of un-annotated interface `org.modeshape.jcr.query.parse.QueryParser`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  94.           CheckArg.isNotNull(languages, "languages");
  95.           for (QueryParser language : languages) {
  96. >             addLanguage(language);
  97.           }
  98.       }

src/main/java/org/modeshape/jcr/query/parse/QueryParsers.java:81: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String QueryParser.getLanguage()` of un-annotated interface `org.modeshape.jcr.query.parse.QueryParser`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  79.       public void addLanguages( QueryParser firstLanguage,
  80.                                 QueryParser... additionalLanguages ) {
  81. >         addLanguage(firstLanguage);
  82.           for (QueryParser language : additionalLanguages) {
  83.               addLanguage(language);

src/main/java/org/modeshape/jcr/JcrLockManager.java:102: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReference ChildReferences.getChild(Name)` of un-annotated interface `org.modeshape.jcr.cache.ChildReferences`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  100.           // Change the lock to be held by a session ...
  101.           try {
  102. >             if (!lockManager.setHeldBySession(session, lockToken, true)) {
  103.                   throw new LockException(JcrI18n.lockTokenAlreadyHeld.text(lockToken));
  104.               }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2514: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void MutableCachedNode.addInternalProperty(String,Object)` of un-annotated interface `org.modeshape.jcr.cache.MutableCachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  2512.               // we're making a node an unordered collection, so we need to set some internal data on the document..
  2513.               int bucketIdLength = nodeTypes.getBucketIdLengthForUnorderedCollection(mixinTypeName, null);
  2514. >             mutable.addInternalProperty(DocumentConstants.BUCKET_ID_LENGTH, bucketIdLength);
  2515.           }
  2516.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2518: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.addMixin(String)` indirectly writes to field `defn.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2516.   
  2517.           // And auto-create any properties that are defined by the new primary type ...
  2518. >         autoCreateItemsFor(mixinType);
  2519.   
  2520.           if (mixinType.hasPropertyDefinitions()) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2491: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.addMixin(String)` indirectly writes to field `type.key.sourceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2489.           session.checkPermission(this, ModeShapePermissions.SET_PROPERTY);
  2490.   
  2491. >         if (!canAddMixin(mixinName)) {
  2492.               throw new ConstraintViolationException(JcrI18n.cannotAddMixin.text(mixinName));
  2493.           }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2489: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.addMixin(String)` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2487.           checkForCheckedOut();
  2488.   
  2489. >         session.checkPermission(this, ModeShapePermissions.SET_PROPERTY);
  2490.   
  2491.           if (!canAddMixin(mixinName)) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2486: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.addMixin(String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2484.   
  2485.           checkSession();
  2486. >         checkForLock();
  2487.           checkForCheckedOut();
  2488.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrSystemNode.addMixin(String)` indirectly writes to field `type.key.sourceKey` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:538: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ExecutionContext SessionCache.getContext()` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  536.           if (isNew) {
  537.               // We have the actual properties, so just update the jcr:mixinTypes property ...
  538. >             Property mixinTypes = cache.getContext().getPropertyFactory().create(JcrLexicon.MIXIN_TYPES, new Name[] {mixinName});
  539.               Property existing = changedProperties().putIfAbsent(mixinTypes.getName(), mixinTypes);
  540.               while (existing != null) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:101: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Node AbstractJcrNode.addNode(String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  99.    * The abstract base class for all {@link Node} implementations.
  100.    */
  101. > @ThreadSafe
  102.   abstract class AbstractJcrNode extends AbstractJcrItem implements Node {
  103.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:977: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrNode AbstractJcrNode.addNode(String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  975.           RepositoryException {
  976.           checkSession();
  977. >         return addNode(relPath, null, null, false);
  978.       }
  979.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrNode JcrSystemNode.addNode(String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:101: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Node AbstractJcrNode.addNode(String,String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  99.    * The abstract base class for all {@link Node} implementations.
  100.    */
  101. > @ThreadSafe
  102.   abstract class AbstractJcrNode extends AbstractJcrItem implements Node {
  103.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:986: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrNode AbstractJcrNode.addNode(String,String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  984.           ConstraintViolationException, RepositoryException {
  985.           checkSession();
  986. >         return addNode(relPath, primaryNodeTypeName, null, false);
  987.       }
  988.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrNode JcrSystemNode.addNode(String,String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1054: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrNode AbstractJcrNode.addNode(String,String,NodeKey,boolean)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1052.                                                   ModeShapePermissions.ADD_NODE);
  1053.                       }
  1054. >                     return ((AbstractJcrNode)parent).addChildNode(childName, childPrimaryTypeName, desiredKey, false, aclScope);
  1055.                   } else if (parent instanceof AbstractJcrProperty) {
  1056.                       // Per the TCK, if relPath references a property, then we have to throw a ConstraintViolationException.

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1037: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `int Path$Segment.getIndex()` of un-annotated interface `org.modeshape.jcr.value.Path$Segment`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1035.               throw new RepositoryException(JcrI18n.invalidPathParameter.text(relPath, "relPath"));
  1036.           }
  1037. >         if (path.size() == 0 || path.isIdentifier() || path.getLastSegment().getIndex() > 1 || relPath.endsWith("]")) {
  1038.               throw new RepositoryException(JcrI18n.invalidPathParameter.text(relPath, "relPath"));
  1039.           }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1045: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `AbstractJcrNode AbstractJcrNode.addNode(String,String,NodeKey,boolean)` indirectly reads without synchronization from `nodeKey.workspaceKey`. Potentially races with write in method `AbstractJcrNode.addNode(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1043.               try {
  1044.                   // Find the parent node ...
  1045. >                 AbstractJcrItem parent = session.findItem(this, parentPath);
  1046.                   if (parent instanceof AbstractJcrNode) {
  1047.                       // delegate to the parent node ...

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:989: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  987.                                            boolean add ) {
  988.   
  989. >         boolean isFrozenNode = JcrNtLexicon.FROZEN_NODE.equals(this.getPrimaryType(cache));
  990.   
  991.           while (referenceValuesIterator.hasNext()) {

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1023: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void SessionNode.addOrRemoveReferrers(SessionCache,SessionCache,Property,Iterator,boolean)` indirectly mutates container `changes.addedStrong` via call to `put` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1021.               ReferenceType referenceType = isWeak ? ReferenceType.WEAK : ReferenceType.STRONG;
  1022.               if (add) {
  1023. >                 referredNode.addReferrer(cache, property, key, referenceType);
  1024.               } else {
  1025.                   referredNode.removeReferrer(cache, property, key, referenceType);

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1025: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void SessionNode.addOrRemoveReferrers(SessionCache,SessionCache,Property,Iterator,boolean)` indirectly mutates container `changes.addedStrong` via call to `remove` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1023.                   referredNode.addReferrer(cache, property, key, referenceType);
  1024.               } else {
  1025. >                 referredNode.removeReferrer(cache, property, key, referenceType);
  1026.               }
  1027.   

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:675: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void SessionNode.addReferrer(SessionCache,Property,NodeKey,CachedNode$ReferenceType)` indirectly mutates container `changes.addedWeak` via call to `put` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  673.           switch (type) {
  674.               case WEAK:
  675. >                 changes.addWeakReferrer(property, referrerKey);
  676.                   break;
  677.               case STRONG:

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:678: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void SessionNode.addReferrer(SessionCache,Property,NodeKey,CachedNode$ReferenceType)` indirectly mutates container `changes.addedStrong` via call to `put` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  676.                   break;
  677.               case STRONG:
  678. >                 changes.addStrongReferrer(property, referrerKey);
  679.                   break;
  680.               case BOTH:

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3085: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean NodeTypes$ReusableNodeDefinitionSet.appliesTo(NodeTypes,Name,Set)` of un-annotated interface `org.modeshape.jcr.NodeTypes$ReusableNodeDefinitionSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  3083.   
  3084.           // validate there is an appropriate child node definition
  3085. >         JcrNodeDefinition childDefn = validateChildNodeDefinition(newNodeName, shareableNode.getPrimaryTypeName(), true);
  3086.   
  3087.           // See if this node is checked in. If so, then we can only create children if the child

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3075: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.addSharedNode(AbstractJcrNode,Name)` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3073.           assert session == shareableNode.session;
  3074.   
  3075. >         session.checkPermission(this, ModeShapePermissions.ADD_NODE);
  3076.           if (isLockedByAnotherSession()) {
  3077.               throw new LockException(JcrI18n.lockTokenNotHeld.text(location()));

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3076: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.addSharedNode(AbstractJcrNode,Name)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3074.   
  3075.           session.checkPermission(this, ModeShapePermissions.ADD_NODE);
  3076. >         if (isLockedByAnotherSession()) {
  3077.               throw new LockException(JcrI18n.lockTokenNotHeld.text(location()));
  3078.           }

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:320: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrVersionHistoryNode.addVersionLabel(String,String,boolean)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  318.           try {
  319.               // This throws a PNFE if the named property doesn't already exist
  320. >             versionLabels.getProperty(label);
  321.               if (!moveLabel) throw new LabelExistsVersionException(JcrI18n.versionLabelAlreadyExists.text(label));
  322.   

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:328: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `int Transaction.getStatus()` of un-annotated interface `javax.transaction.Transaction`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  326.   
  327.           // Use a separate system session to set the REFERENCE property on the 'nt:versionLabels' child node ...
  328. >         SessionCache system = session.createSystemCache(false);
  329.           Reference labelReference = session.referenceFactory().create(version.key(), true);
  330.           Property ref = session.propertyFactory().create(nameFrom(label), labelReference);

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:315: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrVersionHistoryNode.addVersionLabel(String,String,boolean)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  313.                                    String label,
  314.                                    boolean moveLabel ) throws VersionException, RepositoryException {
  315. >         AbstractJcrNode versionLabels = versionLabels();
  316.           JcrVersionNode version = getVersion(versionName);
  317.   

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:316: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrVersionHistoryNode.addVersionLabel(String,String,boolean)` indirectly writes to field `parentKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  314.                                    boolean moveLabel ) throws VersionException, RepositoryException {
  315.           AbstractJcrNode versionLabels = versionLabels();
  316. >         JcrVersionNode version = getVersion(versionName);
  317.   
  318.           try {

src/main/java/org/modeshape/jcr/JcrNodeType.java:256: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Collection Multimap.values()` of un-annotated interface `org.modeshape.common.collection.Multimap`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  254.        */
  255.       Collection<JcrNodeDefinition> allChildNodeDefinitions() {
  256. >         return allDefinitions.allChildNodeDefinitions();
  257.       }
  258.   

src/main/java/org/modeshape/jcr/JcrNodeType.java:265: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Collection Multimap.get(Object)` of un-annotated interface `org.modeshape.common.collection.Multimap`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  263.   
  264.       Collection<JcrNodeDefinition> allChildNodeDefinitions( Name childName ) {
  265. >         return allDefinitions.allChildNodeDefinitions(childName);
  266.       }
  267.   

src/main/java/org/modeshape/jcr/JcrNodeType.java:261: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Collection Multimap.get(Object)` of un-annotated interface `org.modeshape.common.collection.Multimap`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  259.       Collection<JcrNodeDefinition> allChildNodeDefinitions( Name childName,
  260.                                                              boolean requireSns ) {
  261. >         return allDefinitions.allChildNodeDefinitions(childName, requireSns);
  262.       }
  263.   

src/main/java/org/modeshape/jcr/JcrNodeType.java:243: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Collection Multimap.get(Object)` of un-annotated interface `org.modeshape.common.collection.Multimap`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  241.   
  242.       Collection<JcrPropertyDefinition> allMultiValuePropertyDefinitions( Name propertyName ) {
  243. >         return allDefinitions.allMultiValuePropertyDefinitions(propertyName);
  244.       }
  245.   

src/main/java/org/modeshape/jcr/JcrNodeType.java:235: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Collection Multimap.values()` of un-annotated interface `org.modeshape.common.collection.Multimap`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  233.        */
  234.       Collection<JcrPropertyDefinition> allPropertyDefinitions() {
  235. >         return allDefinitions.allPropertyDefinitions();
  236.       }
  237.   

src/main/java/org/modeshape/jcr/JcrNodeType.java:247: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Collection Multimap.get(Object)` of un-annotated interface `org.modeshape.common.collection.Multimap`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  245.   
  246.       Collection<JcrPropertyDefinition> allPropertyDefinitions( Name propertyName ) {
  247. >         return allDefinitions.allPropertyDefinitions(propertyName);
  248.       }
  249.   

src/main/java/org/modeshape/jcr/journal/ClusteredJournal.java:142: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `ChangeJournal$Records ClusteredJournal.allRecords(boolean)` indirectly reads without synchronization from `this.localJournal.records`. Potentially races with write in method `ClusteredJournal.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  140.       @Override
  141.       public Records allRecords( boolean descendingOrder ) {
  142. >         return localJournal.allRecords(descendingOrder);
  143.       }
  144.   

src/main/java/org/modeshape/jcr/journal/LocalJournal.java:222: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `ChangeJournal$Records LocalJournal.allRecords(boolean)` reads without synchronization from `this.records`. Potentially races with write in method `LocalJournal.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  220.       @Override
  221.       public Records allRecords( boolean descendingOrder ) {
  222. >         return recordsFrom(records, descendingOrder);
  223.       }
  224.   

src/main/java/org/modeshape/jcr/JcrNodeType.java:239: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Collection Multimap.get(Object)` of un-annotated interface `org.modeshape.common.collection.Multimap`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  237.   
  238.       Collection<JcrPropertyDefinition> allSingleValuePropertyDefinitions( Name propertyName ) {
  239. >         return allDefinitions.allSingleValuePropertyDefinitions(propertyName);
  240.       }
  241.   

src/main/java/org/modeshape/jcr/cache/document/MutableChildReferences.java:183: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getLocalName()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  181.       public void append( NodeKey key,
  182.                           Name name ) {
  183. >         ChildReference reference = new ChildReference(key, name, 1);
  184.           Lock lock = this.lock.writeLock();
  185.           try {

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:152: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WritableSessionCache.assertInSession(SessionNode)` reads without synchronization from `this.changedNodes`. Potentially races with write in method `WritableSessionCache.save()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  150.   
  151.       protected final void assertInSession( SessionNode node ) {
  152. >         assert this.changedNodes.get(node.getKey()) == node : "Node " + node.getKey() + " is not in this session";
  153.       }
  154.       

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1341: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Collection Multimap.get(Object)` of un-annotated interface `org.modeshape.common.collection.Multimap`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1339.           throws ItemExistsException, PathNotFoundException, VersionException, ConstraintViolationException, LockException,
  1340.           RepositoryException {
  1341. >         Collection<JcrNodeDefinition> autoChildDefns = capabilities.getAutoCreatedChildNodeDefinitions(primaryType);
  1342.           if (!autoChildDefns.isEmpty()) {
  1343.               // There is at least one auto-created child under this node ...

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1301: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Collection Multimap.get(Object)` of un-annotated interface `org.modeshape.common.collection.Multimap`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1299.                                                               PropertyFactory propertyFactory,
  1300.                                                               NodeTypes capabilities ) {
  1301. >         Collection<JcrPropertyDefinition> autoPropDefns = capabilities.getAutoCreatedPropertyDefinitions(primaryType);
  1302.           if (autoPropDefns.isEmpty()) {
  1303.               return null;

src/main/java/org/modeshape/jcr/JcrRepositoryManager.java:70: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Problems JcrRepositoryManager.backupRepository(File)` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  68.       @Override
  69.       public Problems backupRepository( File backupDirectory ) throws RepositoryException {
  70. >         return backupRepository(backupDirectory, BackupOptions.DEFAULT);
  71.       }
  72.   

src/main/java/org/modeshape/jcr/JcrRepositoryManager.java:75: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Problems JcrRepositoryManager.backupRepository(File,BackupOptions)` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  73.       @Override
  74.       public Problems backupRepository( File backupDirectory, BackupOptions backupOptions ) throws RepositoryException {
  75. >         session().checkPermission(Path.ROOT_PATH, ModeShapePermissions.BACKUP);
  76.           return repository().runningState().backupService().backupRepository(backupDirectory, backupOptions);
  77.       }

src/main/java/org/modeshape/jcr/cache/document/BucketedChildReferences.java:269: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `BucketedChildReferences$Bucket BucketedChildReferences.bucketFor(Name)` indirectly reads without synchronization from container `this.rangeBucketsById` via call to `get`. Potentially races with write in method `BucketedChildReferences.getChildCount(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  267.       
  268.       protected Bucket bucketFor(Name name) {
  269. >         return loadBucket(new BucketId(name, bucketIdLength));
  270.       }
  271.   

src/main/java/org/modeshape/jcr/JcrNodeType.java:284: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean NodeTypes$ReusableNodeDefinitionSet.appliesTo(NodeTypes,Name,Set)` of un-annotated interface `org.modeshape.jcr.NodeTypes$ReusableNodeDefinitionSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  282.           Name childName = context.getValueFactories().getNameFactory().create(childNodeName);
  283.           boolean skipProtected = true;
  284. >         NodeDefinitionSet childDefns = nodeTypes().findChildNodeDefinitions(this.name, null);
  285.           JcrNodeDefinition childNodeDefinition = childDefns.findBestDefinitionForChild(childName, null, skipProtected,
  286.                                                                                         SiblingCounter.constant(0));

src/main/java/org/modeshape/jcr/JcrNodeType.java:302: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean NodeTypes$ReusableNodeDefinitionSet.appliesTo(NodeTypes,Name,Set)` of un-annotated interface `org.modeshape.jcr.NodeTypes$ReusableNodeDefinitionSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  300.           NodeTypes nodeTypes = nodeTypes();
  301.           boolean skipProtected = true;
  302. >         NodeDefinitionSet childDefns = nodeTypes.findChildNodeDefinitions(this.name, null);
  303.           JcrNodeDefinition childNodeDefinition = childDefns.findBestDefinitionForChild(childName, childPrimaryTypeName,
  304.                                                                                         skipProtected, SiblingCounter.constant(0));

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2779: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean AbstractJcrNode.canAddMixin(String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2777.               for (JcrPropertyDefinition propDefn : mixinType.allPropertyDefinitions()) {
  2778.                   Name propName = propDefn.getInternalName();
  2779. >                 AbstractJcrProperty existingProp = getProperty(propName);
  2780.                   if (existingProp == null) continue;
  2781.                   if (propDefn.isMultiple()) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2746: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean AbstractJcrNode.canAddMixin(String)` indirectly writes to field `type.key.sourceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2744.           JcrNodeTypeManager jcrNodeTypeManager = session().nodeTypeManager();
  2745.           NodeTypes nodeTypes = session().nodeTypes();
  2746. >         JcrNodeType mixinType = jcrNodeTypeManager.getNodeType(mixinName);
  2747.           if (!mixinType.isMixin()) return false;
  2748.           if (isLockedByAnotherSession()) return false;

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2749: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean NodeTypes$ReusableNodeDefinitionSet.appliesTo(NodeTypes,Name,Set)` of un-annotated interface `org.modeshape.jcr.NodeTypes$ReusableNodeDefinitionSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  2747.           if (!mixinType.isMixin()) return false;
  2748.           if (isLockedByAnotherSession()) return false;
  2749. >         if (!isCheckedOut()) return false;
  2750.           if (getDefinition().isProtected()) return false;
  2751.           if (mixinType.isAbstract()) return false;

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2748: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean AbstractJcrNode.canAddMixin(String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2746.           JcrNodeType mixinType = jcrNodeTypeManager.getNodeType(mixinName);
  2747.           if (!mixinType.isMixin()) return false;
  2748. >         if (isLockedByAnotherSession()) return false;
  2749.           if (!isCheckedOut()) return false;
  2750.           if (getDefinition().isProtected()) return false;

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2782: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean AbstractJcrNode.canAddMixin(String)` indirectly writes to field `propDefn.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2780.                   if (existingProp == null) continue;
  2781.                   if (propDefn.isMultiple()) {
  2782. >                     if (!propDefn.canCastToTypeAndSatisfyConstraints(existingProp.getValues(), session())) {
  2783.                           return false;
  2784.                       }

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean JcrSystemNode.canAddMixin(String)` indirectly writes to field `type.key.sourceKey` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3489: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean AbstractJcrNode.canAddNode(String,String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3487.               try {
  3488.                   // Find the parent node ...
  3489. >                 AbstractJcrNode other = session.node(node(), parentPath);
  3490.                   return other.canAddNode(primaryNodeTypeName);
  3491.               } catch (RepositoryException e) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3490: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean AbstractJcrNode.canAddNode(String,String)` indirectly writes to field `type.key.sourceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3488.                   // Find the parent node ...
  3489.                   AbstractJcrNode other = session.node(node(), parentPath);
  3490. >                 return other.canAddNode(primaryNodeTypeName);
  3491.               } catch (RepositoryException e) {
  3492.                   return false;

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3481: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `int Path$Segment.getIndex()` of un-annotated interface `org.modeshape.jcr.value.Path$Segment`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  3479.               return false;
  3480.           }
  3481. >         if (path.getLastSegment().getIndex() > 1 || relPath.endsWith("]")) {
  3482.               return false;
  3483.           }

src/main/java/org/modeshape/jcr/JcrNodeType.java:394: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean JcrNodeType.canCastToTypeAndMatchesConstraints(JcrSession,JcrPropertyDefinition,javax.jcr.Value[])` indirectly writes to field `propertyDefinition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  392.                                                   Value[] values ) {
  393.           for (Value value : values) {
  394. >             if (!canCastToTypeAndMatchesConstraints(session, propertyDefinition, value)) return false;
  395.           }
  396.           return true;

src/main/java/org/modeshape/jcr/JcrNodeType.java:368: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean JcrNodeType.canCastToTypeAndMatchesConstraints(JcrSession,JcrPropertyDefinition,Value)` indirectly writes to field `propertyDefinition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  366.               assert value instanceof JcrValue : "Illegal implementation of Value interface";
  367.               ((JcrValue)value).asType(propertyDefinition.getRequiredType()); // throws ValueFormatException if there's a problem
  368. >             return propertyDefinition.satisfiesConstraints(value, session);
  369.           } catch (javax.jcr.ValueFormatException vfe) {
  370.               // Cast failed

src/main/java/org/modeshape/jcr/JcrNodeType.java:344: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Collection Multimap.get(Object)` of un-annotated interface `org.modeshape.common.collection.Multimap`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  342.           CheckArg.isNotNull(itemName, "itemName");
  343.           Name childName = context.getValueFactories().getNameFactory().create(itemName);
  344. >         return nodeTypes().canRemoveItem(this.name, null, childName, true);
  345.       }
  346.   

src/main/java/org/modeshape/jcr/JcrNodeType.java:328: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Collection Multimap.get(Object)` of un-annotated interface `org.modeshape.common.collection.Multimap`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  326.           CheckArg.isNotNull(itemName, "itemName");
  327.           Name childName = context.getValueFactories().getNameFactory().create(itemName);
  328. >         return nodeTypes().canRemoveAllChildren(this.name, null, childName, true);
  329.       }
  330.   

src/main/java/org/modeshape/jcr/JcrNodeType.java:440: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Collection Multimap.get(Object)` of un-annotated interface `org.modeshape.common.collection.Multimap`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  438.   
  439.           // Reuse the logic in RepositoryNodeTypeManager ...
  440. >         return nodeTypes().canRemoveProperty(this.name, null, name, true);
  441.       }
  442.   

src/main/java/org/modeshape/jcr/JcrNodeType.java:408: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean JcrNodeType.canSetProperty(String,javax.jcr.Value[])` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  406.       public boolean canSetProperty( String propertyName,
  407.                                      Value[] values ) {
  408. >         return canSetProperty(session, propertyName, values);
  409.       }
  410.   

src/main/java/org/modeshape/jcr/JcrNodeType.java:402: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean JcrNodeType.canSetProperty(String,Value)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  400.       public boolean canSetProperty( String propertyName,
  401.                                      Value value ) {
  402. >         return canSetProperty(session, propertyName, value);
  403.       }
  404.   

src/main/java/org/modeshape/jcr/JcrNodeType.java:426: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Collection Multimap.get(Object)` of un-annotated interface `org.modeshape.common.collection.Multimap`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  424.           CheckArg.isNotNull(propertyName, "propertyName");
  425.           if (values == null || values.length == 0) {
  426. >             return canRemoveProperty(propertyName);
  427.           }
  428.   

src/main/java/org/modeshape/jcr/JcrNodeType.java:431: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean JcrNodeType.canSetProperty(JcrSession,String,javax.jcr.Value[])` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  429.           Name name = context.getValueFactories().getNameFactory().create(propertyName);
  430.           // Reuse the logic in RepositoryNodeTypeManager ...
  431. >         return nodeTypes().findPropertyDefinition(session, this.name, null, name, values, true) != null;
  432.       }
  433.   

src/main/java/org/modeshape/jcr/JcrNodeType.java:418: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean JcrNodeType.canSetProperty(JcrSession,String,Value)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  416.   
  417.           // Reuse the logic in RepositoryNodeTypeManager ...
  418. >         return nodeTypes().findPropertyDefinition(session, this.name, null, name, value, false, true) != null;
  419.       }
  420.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2956: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.cancelMerge(Version)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2954.       public void cancelMerge( Version version )
  2955.           throws VersionException, InvalidItemStateException, UnsupportedRepositoryOperationException, RepositoryException {
  2956. >         versionManager().cancelMerge(this, version);
  2957.       }
  2958.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrSystemNode.cancelMerge(Version)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/RepositoryIndexManager.java:727: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `RepositoryIndexManager$IndexChangeInfo RepositoryIndexManager.changeInfoForProvider(AtomicReference,Name)` reads without synchronization from container `byProviderName` via call to `get`. Potentially races with write in method `RepositoryIndexManager.changeInfoForProvider(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  725.               changesByProviderName.set(byProviderName);
  726.           }
  727. >         IndexChangeInfo info = byProviderName.get(providerName);
  728.           if (info == null) {
  729.               info = new IndexChangeInfo();

src/main/java/org/modeshape/jcr/RepositoryIndexManager.java:730: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `RepositoryIndexManager$IndexChangeInfo RepositoryIndexManager.changeInfoForProvider(AtomicReference,Name)` mutates container `byProviderName` via call to `put` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  728.           if (info == null) {
  729.               info = new IndexChangeInfo();
  730. >             byProviderName.put(providerName, info);
  731.           }
  732.           return info;

src/main/java/org/modeshape/jcr/cache/change/RecordingChanges.java:266: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Set RecordingChanges.changedNodes()` reads without synchronization from `this.nodeKeys`. Potentially races with write in method `RecordingChanges.setChangedNodes(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  264.       @Override
  265.       public Set<NodeKey> changedNodes() {
  266. >         return nodeKeys;
  267.       }
  268.   

src/main/java/org/modeshape/jcr/journal/ClusteredJournal.java:159: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Iterator ClusteredJournal.changedNodesSince(long)` indirectly reads without synchronization from `this.localJournal.records`. Potentially races with write in method `ClusteredJournal.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  157.       @Override
  158.       public Iterator<NodeKey> changedNodesSince( long timestamp ) {
  159. >         return localJournal.changedNodesSince(timestamp);
  160.       }
  161.   

src/main/java/org/modeshape/jcr/journal/LocalJournal.java:270: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Iterator LocalJournal.changedNodesSince(long)` reads without synchronization from `this.searchTimeDelta`. Potentially races with write in method `LocalJournal.withSearchTimeDelta(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  268.       public Iterator<NodeKey> changedNodesSince( final long timestamp ) {
  269.           // we use a delta to make sure we get everything and we filter false positives later on
  270. >         long searchBound = TIME_BASED_KEYS.getCounterStartingAt(timestamp - searchTimeDelta);
  271.           Collection<JournalRecord> journalRecords = records.tailMap(searchBound, true).values();
  272.           if (journalRecords.isEmpty()) {

src/main/java/org/modeshape/jcr/journal/LocalJournal.java:271: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Iterator LocalJournal.changedNodesSince(long)` reads without synchronization from `this.records`. Potentially races with write in method `LocalJournal.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  269.           // we use a delta to make sure we get everything and we filter false positives later on
  270.           long searchBound = TIME_BASED_KEYS.getCounterStartingAt(timestamp - searchTimeDelta);
  271. >         Collection<JournalRecord> journalRecords = records.tailMap(searchBound, true).values();
  272.           if (journalRecords.isEmpty()) {
  273.               return Collections.emptyListIterator();

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:657: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean NodeTypes$ReusableNodeDefinitionSet.appliesTo(NodeTypes,Name,Set)` of un-annotated interface `org.modeshape.jcr.NodeTypes$ReusableNodeDefinitionSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  655.        */
  656.       protected final void checkForCheckedOut() throws VersionException, RepositoryException {
  657. >         if (!isCheckedOut()) {
  658.               throw new VersionException(JcrI18n.nodeIsCheckedIn.text(location()));
  659.           }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:636: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Lock.getLockToken()` of un-annotated interface `javax.jcr.lock.Lock`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  634.       protected final void checkForLock() throws LockException, RepositoryException {
  635.           Lock lock = getLockIfExists();
  636. >         if (lock != null && !lock.isLockOwningSession() && lock.getLockToken() == null) {
  637.               throw new LockException(JcrI18n.lockTokenNotHeld.text(location()));
  638.           }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:635: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.checkForLock()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  633.        */
  634.       protected final void checkForLock() throws LockException, RepositoryException {
  635. >         Lock lock = getLockIfExists();
  636.           if (lock != null && !lock.isLockOwningSession() && lock.getLockToken() == null) {
  637.               throw new LockException(JcrI18n.lockTokenNotHeld.text(location()));

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2938: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Version AbstractJcrNode.checkin()` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2936.           throws VersionException, UnsupportedRepositoryOperationException, InvalidItemStateException, LockException,
  2937.           RepositoryException {
  2938. >         return versionManager().checkin(this);
  2939.       }
  2940.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Version JcrSystemNode.checkin()` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2944: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.checkout()` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2942.       public void checkout()
  2943.           throws UnsupportedRepositoryOperationException, LockException, ActivityViolationException, RepositoryException {
  2944. >         versionManager().checkout(this);
  2945.       }
  2946.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrSystemNode.checkout()` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:669: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReferences CachedNode.getChildReferences(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  667.        */
  668.       protected final long childCount() throws RepositoryException {
  669. >         return node().getChildReferences(sessionCache()).size();
  670.       }
  671.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:690: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrNode AbstractJcrNode.childNode(Name,AbstractJcrNode$Type)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  688.               throw new PathNotFoundException(msg);
  689.           }
  690. >         return session().node(ref.getKey(), expectedType, key());
  691.       }
  692.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:685: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReference ChildReferences.getChild(Name)` of un-annotated interface `org.modeshape.jcr.cache.ChildReferences`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  683.                                                  Type expectedType )
  684.           throws PathNotFoundException, ItemNotFoundException, InvalidItemStateException {
  685. >         ChildReference ref = node().getChildReferences(sessionCache()).getChild(name);
  686.           if (ref == null) {
  687.               String msg = JcrI18n.childNotFoundUnderNode.text(readable(name), location(), session.workspaceName());

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:711: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrNode AbstractJcrNode.childNode(Path$Segment,AbstractJcrNode$Type)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  709.               throw new PathNotFoundException(msg);
  710.           }
  711. >         return session().node(ref.getKey(), expectedType, key());
  712.       }
  713.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:706: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReference ChildReferences.getChild(Path$Segment)` of un-annotated interface `org.modeshape.jcr.cache.ChildReferences`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  704.                                                  Type expectedType )
  705.           throws PathNotFoundException, ItemNotFoundException, InvalidItemStateException {
  706. >         ChildReference ref = node().getChildReferences(sessionCache()).getChild(segment);
  707.           if (ref == null) {
  708.               String msg = JcrI18n.childNotFoundUnderNode.text(readable(segment), location(), session.workspaceName());

src/main/java/org/modeshape/jcr/JcrNodeType.java:270: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Collection Multimap.get(Object)` of un-annotated interface `org.modeshape.common.collection.Multimap`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  268.       JcrNodeDefinition childNodeDefinition( NodeDefinitionId nodeDefnId ) {
  269.           List<Name> requiredPrimaryTypeNames = Arrays.asList(nodeDefnId.getRequiredPrimaryTypes());
  270. >         for (JcrNodeDefinition nodeDefn : allChildNodeDefinitions(nodeDefnId.getChildDefinitionName())) {
  271.               if (nodeDefn.requiredPrimaryTypeNameSet().size() == requiredPrimaryTypeNames.size()
  272.                   && nodeDefn.requiredPrimaryTypeNameSet().containsAll(requiredPrimaryTypeNames)) {

src/main/java/org/modeshape/jcr/JcrLockManager.java:67: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void SessionCache.destroy(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  65.       final void cleanLocks() throws RepositoryException {
  66.           // clean the session-scoped locks: unlock all the nodes and remove the lock tokens from the system area
  67. >         Set<String> cleanedTokens = lockManager.cleanLocks(session);
  68.           if (lockTokens.isEmpty()) {
  69.               return;

src/main/java/org/modeshape/jcr/RepositoryLockManager.java:479: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void SessionCache.destroy(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  477.               cleanedTokens = new HashSet<>(locks.size());
  478.               // clear the locks which have been unlocked
  479. >             unlock(session, locks);
  480.               for (ModeShapeLock lock : locks) {
  481.                   locksByNodeKey.remove(lock.getLockedNodeKey());

src/main/java/org/modeshape/jcr/JcrRepository.java:1841: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrRepository$RunningState.cleanUpLocks()` indirectly mutates container `lockedNodes` via call to `add` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1839.                   }
  1840.   
  1841. >                 this.lockManager().cleanupLocks(activeSessionIds);
  1842.                   if (logger.isDebugEnabled()) {
  1843.                       logger.debug("Finishing lock cleanup in the '{0}' repository", repositoryName());

src/main/java/org/modeshape/jcr/RepositoryLockManager.java:200: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void SessionCache.destroy(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  198.                   if (expirationDate.isBefore(now)) {
  199.                       //remove the lock from the system area
  200. >                     systemContent.removeLock(lock);
  201.                       //register the target node which needs cleaning
  202.                       List<NodeKey> lockedNodes = lockedNodesByWorkspaceName.get(lock.getWorkspaceName());

src/main/java/org/modeshape/jcr/RepositoryLockManager.java:207: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void RepositoryLockManager.cleanupLocks(Set)` mutates container `lockedNodes` via call to `add` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  205.                           lockedNodesByWorkspaceName.put(lock.getWorkspaceName(), lockedNodes);
  206.                       }
  207. >                     lockedNodes.add(lockedNodeKey);
  208.                   }
  209.               }

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:573: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void WritableSessionCache.clearState()` writes to field `this.changedNodes` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  571.       protected void clearState() {
  572.           // The changes have been made, so create a new map (we're using the keys from the current map) ...
  573. >         this.changedNodes = new HashMap<NodeKey, SessionNode>();
  574.           this.referrerChangesForRemovedNodes.clear();
  575.           this.changedNodesInOrder.clear();

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:574: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void WritableSessionCache.clearState()` mutates container `this.referrerChangesForRemovedNodes` via call to `clear` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  572.           // The changes have been made, so create a new map (we're using the keys from the current map) ...
  573.           this.changedNodes = new HashMap<NodeKey, SessionNode>();
  574. >         this.referrerChangesForRemovedNodes.clear();
  575.           this.changedNodesInOrder.clear();
  576.           this.binaryReferencesByNodeKey.clear();

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:578: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `int Transaction.getStatus()` of un-annotated interface `javax.transaction.Transaction`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  576.           this.binaryReferencesByNodeKey.clear();
  577.           this.replacedNodes = null;
  578. >         this.checkForTransaction();
  579.       }
  580.   

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:577: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void WritableSessionCache.clearState()` writes to field `this.replacedNodes` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  575.           this.changedNodesInOrder.clear();
  576.           this.binaryReferencesByNodeKey.clear();
  577. >         this.replacedNodes = null;
  578.           this.checkForTransaction();
  579.       }

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:586: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WritableSessionCache.clearState(Iterable)` reads without synchronization from `this.replacedNodes`. Potentially races with write in method `WritableSessionCache.save()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  584.               this.changedNodes.remove(savedNode);
  585.               this.changedNodesInOrder.remove(savedNode);
  586. >             if (this.replacedNodes != null) {
  587.                   this.replacedNodes.remove(savedNode);
  588.               }

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:584: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WritableSessionCache.clearState(Iterable)` reads without synchronization from `this.changedNodes`. Potentially races with write in method `WritableSessionCache.save()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  582.           // The changes have been made, so remove the changes from this session's map ...
  583.           for (NodeKey savedNode : savedNodesInOrder) {
  584. >             this.changedNodes.remove(savedNode);
  585.               this.changedNodesInOrder.remove(savedNode);
  586.               if (this.replacedNodes != null) {

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:592: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `int Transaction.getStatus()` of un-annotated interface `javax.transaction.Transaction`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  590.               this.binaryReferencesByNodeKey.remove(savedNode);
  591.           }
  592. >         this.checkForTransaction();
  593.       }
  594.   

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:589: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void WritableSessionCache.clearState(Iterable)` mutates container `this.referrerChangesForRemovedNodes` via call to `remove` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  587.                   this.replacedNodes.remove(savedNode);
  588.               }
  589. >             this.referrerChangesForRemovedNodes.remove(savedNode);
  590.               this.binaryReferencesByNodeKey.remove(savedNode);
  591.           }

src/main/java/org/modeshape/jcr/JcrWorkspace.java:292: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.clone(String,String,String,boolean)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  290.           throws NoSuchWorkspaceException, ConstraintViolationException, VersionException, AccessDeniedException,
  291.           PathNotFoundException, ItemExistsException, LockException, RepositoryException {
  292. >         internalClone(srcWorkspace, srcAbsPath, destAbsPath, removeExisting, false);
  293.       }
  294.   

src/main/java/org/modeshape/jcr/value/binary/SharedLockingInputStream.java:117: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void SharedLockingInputStream.close()` writes to field `this.processLock` outside of synchronization.
 Reporting because this access may occur on a background thread.
  115.                                   processLock.unlock();
  116.                               } finally {
  117. >                                 processLock = null;
  118.                               }
  119.                           }

src/main/java/org/modeshape/jcr/value/binary/SharedLockingInputStream.java:108: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void SharedLockingInputStream.close()` reads without synchronization from `this.fileLock`. Potentially races with write in method `SharedLockingInputStream.close()`.
 Reporting because this access may occur on a background thread.
  106.               } finally {
  107.                   stream = null;
  108. >                 if (fileLock != null) {
  109.                       try {
  110.                           fileLock.unlock();

src/main/java/org/modeshape/jcr/value/binary/SharedLockingInputStream.java:113: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void SharedLockingInputStream.close()` reads without synchronization from `this.processLock`. Potentially races with write in method `SharedLockingInputStream.close()`.
 Reporting because this access may occur on a background thread.
  111.                       } finally {
  112.                           fileLock = null;
  113. >                         if (processLock != null) {
  114.                               try {
  115.                                   processLock.unlock();

src/main/java/org/modeshape/jcr/value/binary/SharedLockingInputStream.java:112: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void SharedLockingInputStream.close()` writes to field `this.fileLock` outside of synchronization.
 Reporting because this access may occur on a background thread.
  110.                           fileLock.unlock();
  111.                       } finally {
  112. >                         fileLock = null;
  113.                           if (processLock != null) {
  114.                               try {

src/main/java/org/modeshape/jcr/value/binary/SharedLockingInputStream.java:102: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void SharedLockingInputStream.close()` reads without synchronization from `this.stream`. Potentially races with write in method `SharedLockingInputStream.close()`.
 Reporting because this access may occur on a background thread.
  100.       @Override
  101.       public void close() throws IOException {
  102. >         if (this.stream != null) {
  103.               try {
  104.                   // this will release the lock automatically ...

src/main/java/org/modeshape/jcr/value/binary/SharedLockingInputStream.java:107: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void SharedLockingInputStream.close()` writes to field `this.stream` outside of synchronization.
 Reporting because this access may occur on a background thread.
  105.                   stream.close();
  106.               } finally {
  107. >                 stream = null;
  108.                   if (fileLock != null) {
  109.                       try {

src/main/java/org/modeshape/jcr/clustering/ClusteringService.java:245: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String ClusteringService.clusterName()` reads without synchronization from `this.channel`. Potentially races with write in method `ClusteringService.restart()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  243.        */
  244.       public String clusterName() {
  245. >         return channel.getClusterName();
  246.       }
  247.   

src/main/java/org/modeshape/jcr/query/engine/ScanningQueryEngine.java:3070: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `QueryResults$Columns ScanningQueryEngine$ScanQueryContext.columnsFor(PlanNode)` reads without synchronization from container `this.columnsByPlanNode` via call to `get`. Potentially races with write in method `ScanningQueryEngine$ScanQueryContext.addColumnsFor(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3068.            */
  3069.           public Columns columnsFor( PlanNode node ) {
  3070. >             return columnsByPlanNode.get(node);
  3071.           }
  3072.   

src/main/java/org/modeshape/jcr/JcrNodeType.java:695: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String NodeType.getName()` of un-annotated interface `javax.jcr.nodetype.NodeType`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  693.            * TCK canRemoveMixin test cases assume that this will generate a conflict.
  694.            */
  695. >         if (primaryNodeType.getName().equals(getName())) {
  696.               // This node type has already been applied to the node
  697.               return true;

src/main/java/org/modeshape/jcr/bus/ClusteredChangeBus.java:37: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String ChangeSet.getProcessKey()` of un-annotated interface `org.modeshape.jcr.cache.change.ChangeSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  35.    * @author Horia Chiorean
  36.    */
  37. > @ThreadSafe
  38.   public final class ClusteredChangeBus extends MessageConsumer<ChangeSet> implements ChangeBus {
  39.   

src/main/java/org/modeshape/jcr/journal/ClusteredJournal.java:41: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ClusteredJournal.consume(Serializable)` indirectly reads without synchronization from `this.localJournal.journalId`. Potentially races with write in method `ClusteredJournal.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  39.    * @author Horia Chiorean (hchiorea@redhat.com)
  40.    */
  41. > @ThreadSafe
  42.   public class ClusteredJournal extends MessageConsumer<ClusteredJournal.DeltaMessage> implements ChangeJournal {
  43.   

src/main/java/org/modeshape/jcr/bus/ClusteredChangeBus.java:72: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String ChangeSet.getProcessKey()` of un-annotated interface `org.modeshape.jcr.cache.change.ChangeSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  70.           if (hasObservers()) {
  71.               delegate.notify(changes);
  72. >             logReceivedOperation(changes);
  73.           }
  74.       }

src/main/java/org/modeshape/jcr/journal/ClusteredJournal.java:183: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ClusteredJournal.consume(ClusteredJournal$DeltaMessage)` indirectly reads without synchronization from `this.localJournal.journalId`. Potentially races with write in method `ClusteredJournal.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  181.           }
  182.           if (message.isResponse()) {
  183. >             processDeltaResponse(message);
  184.           } else {
  185.               processDeltaRequest(message);

src/main/java/org/modeshape/jcr/journal/ClusteredJournal.java:185: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ClusteredJournal.consume(ClusteredJournal$DeltaMessage)` indirectly reads without synchronization from `this.localJournal.records`. Potentially races with write in method `ClusteredJournal.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  183.               processDeltaResponse(message);
  184.           } else {
  185. >             processDeltaRequest(message);
  186.           }
  187.       }

src/main/java/org/modeshape/jcr/cache/ChildReferences.java:475: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `int ChildReferences$SingleNameContext.consume(Name,NodeKey)` writes to field `this.index` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  473.           public int consume( Name name,
  474.                               NodeKey key ) {
  475. >             return ++index;
  476.           }
  477.   

src/main/java/org/modeshape/jcr/cache/ChildReferences.java:527: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `int ChildReferences$Context.consume(Name,NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.ChildReferences$Context`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  525.           public int consume( Name name,
  526.                               NodeKey key ) {
  527. >             return this.delegate.consume(name, key);
  528.           }
  529.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3547: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Set SessionCache.getChangedNodeKeys()` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  3545.       protected boolean containsChangesWithExternalDependencies( AtomicReference<Set<NodeKey>> affectedNodeKeys )
  3546.           throws RepositoryException {
  3547. >         Set<NodeKey> allChanges = sessionCache().getChangedNodeKeys();
  3548.           Set<NodeKey> changesAtOrBelowThis = sessionCache().getChangedNodeKeysAtOrBelow(this.node());
  3549.           removeReferrerChanges(allChanges, changesAtOrBelowThis);

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3549: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean AbstractJcrNode.containsChangesWithExternalDependencies(AtomicReference)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3547.           Set<NodeKey> allChanges = sessionCache().getChangedNodeKeys();
  3548.           Set<NodeKey> changesAtOrBelowThis = sessionCache().getChangedNodeKeysAtOrBelow(this.node());
  3549. >         removeReferrerChanges(allChanges, changesAtOrBelowThis);
  3550.           if (affectedNodeKeys != null) affectedNodeKeys.set(changesAtOrBelowThis);
  3551.   

src/main/java/org/modeshape/jcr/JcrWorkspace.java:121: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.copy(String,String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  119.           session.checkLive();
  120.   
  121. >         this.copy(this.workspaceName, srcAbsPath, destAbsPath);
  122.       }
  123.   

src/main/java/org/modeshape/jcr/JcrWorkspace.java:211: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void MutableCachedNode.addInternalProperty(String,Object)` of un-annotated interface `org.modeshape.jcr.cache.MutableCachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  209.               * Use the JCR add child here to perform the parent validations
  210.               */
  211. >             AbstractJcrNode copy = newNodeName == null ? parentNode : parentNode.addChildNode(newNodeName,
  212.                                                                                                 sourceNode.getPrimaryTypeName(),
  213.                                                                                                 null, false, false);

src/main/java/org/modeshape/jcr/JcrWorkspace.java:171: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JcrWorkspace.copy(String,String,String)` indirectly reads without synchronization from `nodeKey.workspaceKey`. Potentially races with write in method `JcrWorkspace.deleteWorkspace(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  169.   
  170.               if (destPath.isIdentifier()) {
  171. >                 AbstractJcrNode existingDestNode = copySession.node(destPath);
  172.                   if (!existingDestNode.isRoot()) {
  173.                       parentNode = existingDestNode.getParent();

src/main/java/org/modeshape/jcr/JcrWorkspace.java:229: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.copy(String,String,String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  227.   
  228.                       // For the nodes which were versionable, set the mappings for the original version
  229. >                     copySession.setOriginalVersionKey(dstNodeKey, srcNode.getBaseVersion().key());
  230.                   }
  231.                   

src/main/java/org/modeshape/jcr/JcrWorkspace.java:133: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.copy(String,String,String)` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  131.           CheckArg.isNotEmpty(destAbsPath, "destAbsPath");
  132.   
  133. >         validateCrossWorkspaceAction(srcWorkspace);
  134.   
  135.           // Create the paths ...

src/main/java/org/modeshape/jcr/JcrWorkspace.java:201: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.copy(String,String,String)` indirectly writes to field `parentKey.sourceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  199.                * Perform validations if external nodes are present.
  200.                */
  201. >             validateCopyForExternalNode(sourceNode, parentNode);
  202.   
  203.               NodeTypes nodeTypes = repository().nodeTypeManager().getNodeTypes();

src/main/java/org/modeshape/jcr/JcrWorkspace.java:193: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.copy(String,String,String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  191.               AbstractJcrNode sourceNode = sourceSession.node(srcPath);
  192.               JcrLockManager lockManager = session.lockManager();
  193. >             javax.jcr.lock.Lock lock = lockManager.getLockIfExists(sourceNode);
  194.               if (lock != null && !lock.isLockOwningSession()) {
  195.                   throw new LockException(srcAbsPath);

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3048: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  3046.   
  3047.           NodeKey nodeKey = new NodeKey(key.getSourceKey(), workspaceKey, key.getIdentifier());
  3048. >         return session.getPathForCorrespondingNode(workspaceName, nodeKey, relativePath);
  3049.       }
  3050.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3045: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Path AbstractJcrNode.correspondingNodePath(String)` indirectly writes to field `key.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3043.           // if the we're looking for a system node, we need to use the system ws name, which is repository-wide
  3044.           String systemWsKey = session.getRepository().systemWorkspaceKey();
  3045. >         String workspaceKey = systemWsKey.equals(key.getWorkspaceKey()) ? systemWsKey : NodeKey.keyForWorkspaceName(workspaceName);
  3046.   
  3047.           NodeKey nodeKey = new NodeKey(key.getSourceKey(), workspaceKey, key.getIdentifier());

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3047: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Path AbstractJcrNode.correspondingNodePath(String)` indirectly writes to field `key.identifier` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3045.           String workspaceKey = systemWsKey.equals(key.getWorkspaceKey()) ? systemWsKey : NodeKey.keyForWorkspaceName(workspaceName);
  3046.   
  3047. >         NodeKey nodeKey = new NodeKey(key.getSourceKey(), workspaceKey, key.getIdentifier());
  3048.           return session.getPathForCorrespondingNode(workspaceName, nodeKey, relativePath);
  3049.       }

src/main/java/org/modeshape/jcr/value/basic/AbstractValueFactory.java:144: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `java.lang.Object[] AbstractValueFactory.create(boolean[])` writes to field `result.[_]` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  142.           T[] result = createEmptyArray(length);
  143.           for (int i = 0; i != length; ++i) {
  144. >             result[i] = create(values[i]);
  145.           }
  146.           return result;

src/main/java/org/modeshape/jcr/value/basic/NameValueFactory.java:46: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  44.    * The standard {@link ValueFactory} for {@link PropertyType#NAME} values.
  45.    */
  46. > @Immutable
  47.   public class NameValueFactory extends AbstractValueFactory<Name> implements NameFactory {
  48.   

src/main/java/org/modeshape/jcr/value/basic/NameValueFactory.java:314: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  312.       public Name create( byte[] value ) {
  313.           // First attempt to create a string from the value, then a long from the string ...
  314. >         return create(getStringValueFactory().create(value));
  315.       }
  316.   

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:50: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getLocalName()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  48.    * The standard {@link ValueFactory} for {@link PropertyType#NAME} values.
  49.    */
  50. > @Immutable
  51.   public class PathValueFactory extends AbstractValueFactory<Path> implements PathFactory {
  52.   

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:671: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getLocalName()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  669.       public Path create( byte[] value ) {
  670.           // First attempt to create a string from the value, then a long from the string ...
  671. >         return create(getStringValueFactory().create(value));
  672.       }
  673.   

src/main/java/org/modeshape/jcr/value/basic/AbstractValueFactory.java:155: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `java.lang.Object[] AbstractValueFactory.create(byte[][])` writes to field `result.[_]` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  153.           T[] result = createEmptyArray(length);
  154.           for (int i = 0; i != length; ++i) {
  155. >             result[i] = create(values[i]);
  156.           }
  157.           return result;

src/main/java/org/modeshape/jcr/value/basic/AbstractValueFactory.java:199: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `java.lang.Object[] AbstractValueFactory.create(double[])` writes to field `result.[_]` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  197.           T[] result = createEmptyArray(length);
  198.           for (int i = 0; i != length; ++i) {
  199. >             result[i] = create(values[i]);
  200.           }
  201.           return result;

src/main/java/org/modeshape/jcr/value/basic/AbstractValueFactory.java:210: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `java.lang.Object[] AbstractValueFactory.create(float[])` writes to field `result.[_]` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  208.           T[] result = createEmptyArray(length);
  209.           for (int i = 0; i != length; ++i) {
  210. >             result[i] = create(values[i]);
  211.           }
  212.           return result;

src/main/java/org/modeshape/jcr/value/basic/AbstractValueFactory.java:221: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `java.lang.Object[] AbstractValueFactory.create(int[])` writes to field `result.[_]` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  219.           T[] result = createEmptyArray(length);
  220.           for (int i = 0; i != length; ++i) {
  221. >             result[i] = create(values[i]);
  222.           }
  223.           return result;

src/main/java/org/modeshape/jcr/value/basic/AbstractValueFactory.java:254: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `java.lang.Object[] AbstractValueFactory.create(java.lang.Object[])` writes to field `result.[_]` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  252.           T[] result = createEmptyArray(length);
  253.           for (int i = 0; i != length; ++i) {
  254. >             result[i] = create(values[i]);
  255.           }
  256.           return result;

src/main/java/org/modeshape/jcr/value/basic/AbstractValueFactory.java:299: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `java.lang.Object[] AbstractValueFactory.create(java.lang.String[])` writes to field `result.[_]` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  297.           T[] result = createEmptyArray(length);
  298.           for (int i = 0; i != length; ++i) {
  299. >             result[i] = create(values[i]);
  300.           }
  301.           return result;

src/main/java/org/modeshape/jcr/value/basic/AbstractValueFactory.java:288: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `java.lang.Object[] AbstractValueFactory.create(java.lang.String[],TextDecoder)` writes to field `result.[_]` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  286.           T[] result = createEmptyArray(length);
  287.           for (int i = 0; i != length; ++i) {
  288. >             result[i] = create(values[i], decoder);
  289.           }
  290.           return result;

src/main/java/org/modeshape/jcr/value/basic/AbstractValueFactory.java:133: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `java.lang.Object[] AbstractValueFactory.create(java.math.BigDecimal[])` writes to field `result.[_]` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  131.           T[] result = createEmptyArray(length);
  132.           for (int i = 0; i != length; ++i) {
  133. >             result[i] = create(values[i]);
  134.           }
  135.           return result;

src/main/java/org/modeshape/jcr/value/basic/AbstractValueFactory.java:310: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `java.lang.Object[] AbstractValueFactory.create(java.net.URI[])` writes to field `result.[_]` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  308.           T[] result = createEmptyArray(length);
  309.           for (int i = 0; i != length; ++i) {
  310. >             result[i] = create(values[i]);
  311.           }
  312.           return result;

src/main/java/org/modeshape/jcr/value/basic/AbstractValueFactory.java:166: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `java.lang.Object[] AbstractValueFactory.create(java.util.Calendar[])` writes to field `result.[_]` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  164.           T[] result = createEmptyArray(length);
  165.           for (int i = 0; i != length; ++i) {
  166. >             result[i] = create(values[i]);
  167.           }
  168.           return result;

src/main/java/org/modeshape/jcr/value/basic/AbstractValueFactory.java:177: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `java.lang.Object[] AbstractValueFactory.create(java.util.Date[])` writes to field `result.[_]` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  175.           T[] result = createEmptyArray(length);
  176.           for (int i = 0; i != length; ++i) {
  177. >             result[i] = create(values[i]);
  178.           }
  179.           return result;

src/main/java/org/modeshape/jcr/value/basic/AbstractValueFactory.java:321: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `java.lang.Object[] AbstractValueFactory.create(java.util.UUID[])` writes to field `result.[_]` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  319.           T[] result = createEmptyArray(length);
  320.           for (int i = 0; i != length; ++i) {
  321. >             result[i] = create(values[i]);
  322.           }
  323.           return result;

src/main/java/org/modeshape/jcr/value/basic/AbstractValueFactory.java:232: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `java.lang.Object[] AbstractValueFactory.create(long[])` writes to field `result.[_]` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  230.           T[] result = createEmptyArray(length);
  231.           for (int i = 0; i != length; ++i) {
  232. >             result[i] = create(values[i]);
  233.           }
  234.           return result;

src/main/java/org/modeshape/jcr/value/basic/AbstractValueFactory.java:188: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `java.lang.Object[] AbstractValueFactory.create(org.modeshape.jcr.api.value.DateTime[])` writes to field `result.[_]` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  186.           T[] result = createEmptyArray(length);
  187.           for (int i = 0; i != length; ++i) {
  188. >             result[i] = create(values[i]);
  189.           }
  190.           return result;

src/main/java/org/modeshape/jcr/value/basic/AbstractValueFactory.java:332: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `java.lang.Object[] AbstractValueFactory.create(org.modeshape.jcr.cache.NodeKey[])` writes to field `result.[_]` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  330.           T[] result = createEmptyArray(length);
  331.           for (int i = 0; i != length; ++i) {
  332. >             result[i] = create(values[i]);
  333.           }
  334.           return result;

src/main/java/org/modeshape/jcr/value/basic/AbstractValueFactory.java:343: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `java.lang.Object[] AbstractValueFactory.create(org.modeshape.jcr.value.BinaryValue[])` writes to field `result.[_]` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  341.           T[] result = createEmptyArray(length);
  342.           for (int i = 0; i != length; ++i) {
  343. >             result[i] = create(values[i]);
  344.           }
  345.           return result;

src/main/java/org/modeshape/jcr/value/basic/AbstractValueFactory.java:243: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `java.lang.Object[] AbstractValueFactory.create(org.modeshape.jcr.value.Name[])` writes to field `result.[_]` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  241.           T[] result = createEmptyArray(length);
  242.           for (int i = 0; i != length; ++i) {
  243. >             result[i] = create(values[i]);
  244.           }
  245.           return result;

src/main/java/org/modeshape/jcr/value/basic/AbstractValueFactory.java:265: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `java.lang.Object[] AbstractValueFactory.create(org.modeshape.jcr.value.Path[])` writes to field `result.[_]` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  263.           T[] result = createEmptyArray(length);
  264.           for (int i = 0; i != length; ++i) {
  265. >             result[i] = create(values[i]);
  266.           }
  267.           return result;

src/main/java/org/modeshape/jcr/value/basic/AbstractValueFactory.java:276: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `java.lang.Object[] AbstractValueFactory.create(org.modeshape.jcr.value.Reference[])` writes to field `result.[_]` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  274.           T[] result = createEmptyArray(length);
  275.           for (int i = 0; i != length; ++i) {
  276. >             result[i] = create(values[i]);
  277.           }
  278.           return result;

src/main/java/org/modeshape/jcr/value/basic/NameValueFactory.java:46: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  44.    * The standard {@link ValueFactory} for {@link PropertyType#NAME} values.
  45.    */
  46. > @Immutable
  47.   public class NameValueFactory extends AbstractValueFactory<Name> implements NameFactory {
  48.   

src/main/java/org/modeshape/jcr/value/basic/NameValueFactory.java:326: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  324.       public Name create( InputStream stream ) throws IoException {
  325.           // First attempt to create a string from the value, then a double from the string ...
  326. >         return create(getStringValueFactory().create(stream));
  327.       }
  328.   

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:50: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getLocalName()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  48.    * The standard {@link ValueFactory} for {@link PropertyType#NAME} values.
  49.    */
  50. > @Immutable
  51.   public class PathValueFactory extends AbstractValueFactory<Path> implements PathFactory {
  52.   

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:683: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getLocalName()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  681.       public Path create( InputStream stream ) throws IoException {
  682.           // First attempt to create a string from the value, then a double from the string ...
  683. >         return create(getStringValueFactory().create(stream));
  684.       }
  685.   

src/main/java/org/modeshape/jcr/value/basic/AbstractValueFactory.java:117: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `InputStream Binary.getStream()` of un-annotated interface `javax.jcr.Binary`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  115.               javax.jcr.Binary jcrBinary = (javax.jcr.Binary)value;
  116.               try {
  117. >                 return create(jcrBinary.getStream());
  118.               } catch (RepositoryException e) {
  119.                   throw new RuntimeException(e);

src/main/java/org/modeshape/jcr/value/basic/NameValueFactory.java:46: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  44.    * The standard {@link ValueFactory} for {@link PropertyType#NAME} values.
  45.    */
  46. > @Immutable
  47.   public class NameValueFactory extends AbstractValueFactory<Name> implements NameFactory {
  48.   

src/main/java/org/modeshape/jcr/value/basic/NameValueFactory.java:85: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  83.       @Override
  84.       public Name create( String value ) {
  85. >         return create(value, getDecoder());
  86.       }
  87.   

src/main/java/org/modeshape/jcr/value/basic/NodeIdentifierReferenceFactory.java:34: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Object NodeIdentifierReferenceFactory.create(String)` indirectly writes to field `this.rootKey.sourceKey` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  32.    * @see JcrSession
  33.    */
  34. > public class NodeIdentifierReferenceFactory extends ReferenceValueFactory {
  35.   
  36.       private final NodeKey rootKey;

src/main/java/org/modeshape/jcr/value/basic/NodeIdentifierReferenceFactory.java:67: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Reference NodeIdentifierReferenceFactory.create(String)` indirectly writes to field `this.rootKey.sourceKey` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  65.       public Reference create( String value ) {
  66.           if (value == null) return null;
  67. >         NodeKey key = JcrSession.createNodeKeyFromIdentifier(value, rootKey);
  68.           boolean isForeign = !(key.getSourceKey().equals(rootKey.getSourceKey()) && key.getWorkspaceKey()
  69.                                                                                         .equals(rootKey.getWorkspaceKey()));

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:50: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getLocalName()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  48.    * The standard {@link ValueFactory} for {@link PropertyType#NAME} values.
  49.    */
  50. > @Immutable
  51.   public class PathValueFactory extends AbstractValueFactory<Path> implements PathFactory {
  52.   

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:106: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getLocalName()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  104.       @Override
  105.       public Path create( String value ) {
  106. >         return create(value, getDecoder());
  107.       }
  108.   

src/main/java/org/modeshape/jcr/value/basic/NameValueFactory.java:168: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  166.       public Name create( String namespaceUri,
  167.                           String localName ) {
  168. >         return create(namespaceUri, localName, getDecoder());
  169.       }
  170.   

src/main/java/org/modeshape/jcr/value/basic/NameValueFactory.java:177: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  175.           CheckArg.isNotEmpty(localName, "localName");
  176.           if (decoder == null) decoder = getDecoder();
  177. >         namespaceUri = namespaceUri != null ? decoder.decode(namespaceUri.trim()) : null;
  178.           localName = decoder.decode(localName.trim());
  179.           return new BasicName(namespaceUri, localName);

src/main/java/org/modeshape/jcr/value/basic/BooleanValueFactory.java:72: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  70.                              TextDecoder decoder ) {
  71.           // this probably doesn't really need to call the decoder, but by doing so then we don't care at all what the decoder does
  72. >         return create(getDecoder(decoder).decode(value));
  73.       }
  74.   

src/main/java/org/modeshape/jcr/value/basic/BooleanValueFactory.java:42: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  40.    * The standard {@link ValueFactory} for {@link PropertyType#BOOLEAN} values.
  41.    */
  42. > @Immutable
  43.   public class BooleanValueFactory extends AbstractValueFactory<Boolean> {
  44.   

src/main/java/org/modeshape/jcr/value/basic/DecimalValueFactory.java:42: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  40.    * The standard {@link ValueFactory} for {@link PropertyType#DECIMAL} values.
  41.    */
  42. > @Immutable
  43.   public class DecimalValueFactory extends AbstractValueFactory<BigDecimal> {
  44.   

src/main/java/org/modeshape/jcr/value/basic/DecimalValueFactory.java:79: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  77.                                 TextDecoder decoder ) {
  78.           // this probably doesn't really need to call the decoder, but by doing so then we don't care at all what the decoder does
  79. >         return create(getDecoder(decoder).decode(value.trim()));
  80.       }
  81.   

src/main/java/org/modeshape/jcr/value/basic/DoubleValueFactory.java:79: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  77.                             TextDecoder decoder ) {
  78.           // this probably doesn't really need to call the decoder, but by doing so then we don't care at all what the decoder does
  79. >         return create(getDecoder(decoder).decode(value));
  80.       }
  81.   

src/main/java/org/modeshape/jcr/value/basic/DoubleValueFactory.java:42: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  40.    * The standard {@link ValueFactory} for {@link PropertyType#DOUBLE} values.
  41.    */
  42. > @Immutable
  43.   public class DoubleValueFactory extends AbstractValueFactory<Double> {
  44.   

src/main/java/org/modeshape/jcr/value/basic/JodaDateTimeValueFactory.java:44: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  42.    * The standard {@link ValueFactory} for {@link PropertyType#DATE} values.
  43.    */
  44. > @Immutable
  45.   public class JodaDateTimeValueFactory extends AbstractValueFactory<DateTime> implements DateTimeFactory {
  46.   

src/main/java/org/modeshape/jcr/value/basic/JodaDateTimeValueFactory.java:88: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  86.                               TextDecoder decoder ) {
  87.           // this probably doesn't really need to call the decoder, but by doing so then we don't care at all what the decoder does
  88. >         return create(getDecoder(decoder).decode(value));
  89.       }
  90.   

src/main/java/org/modeshape/jcr/value/basic/LongValueFactory.java:79: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  77.                           TextDecoder decoder ) {
  78.           // this probably doesn't really need to call the decoder, but by doing so then we don't care at all what the decoder does
  79. >         return create(getDecoder(decoder).decode(value));
  80.       }
  81.   

src/main/java/org/modeshape/jcr/value/basic/LongValueFactory.java:42: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  40.    * The standard {@link ValueFactory} for {@link PropertyType#LONG} values.
  41.    */
  42. > @Immutable
  43.   public class LongValueFactory extends AbstractValueFactory<Long> {
  44.   

src/main/java/org/modeshape/jcr/value/basic/NameValueFactory.java:46: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  44.    * The standard {@link ValueFactory} for {@link PropertyType#NAME} values.
  45.    */
  46. > @Immutable
  47.   public class NameValueFactory extends AbstractValueFactory<Name> implements NameFactory {
  48.   

src/main/java/org/modeshape/jcr/value/basic/NameValueFactory.java:121: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  119.                       }
  120.                       String namespaceUri = this.namespaceRegistryHolder.getNamespaceRegistry().getNamespaceForPrefix("");
  121. >                     String localName = decoder.decode(value.substring(2));
  122.                       return new BasicName(namespaceUri, localName);
  123.                   }

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:50: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getLocalName()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  48.    * The standard {@link ValueFactory} for {@link PropertyType#NAME} values.
  49.    */
  50. > @Immutable
  51.   public class PathValueFactory extends AbstractValueFactory<Path> implements PathFactory {
  52.   

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:168: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getLocalName()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  166.               }
  167.               // Create the name and add a segment with it ...
  168. >             segments.add(createSegment(segment, decoder));
  169.           }
  170.   

src/main/java/org/modeshape/jcr/value/basic/ReferenceValueFactory.java:43: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  41.    * The standard {@link ValueFactory} for {@link PropertyType#REFERENCE} values.
  42.    */
  43. > @Immutable
  44.   public class ReferenceValueFactory extends AbstractValueFactory<Reference> implements ReferenceFactory {
  45.   

src/main/java/org/modeshape/jcr/value/basic/ReferenceValueFactory.java:106: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  104.                                TextDecoder decoder ) {
  105.           // this probably doesn't really need to call the decoder, but by doing so then we don't care at all what the decoder does
  106. >         return create(getDecoder(decoder).decode(value));
  107.       }
  108.   

src/main/java/org/modeshape/jcr/value/basic/StringValueFactory.java:53: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  51.    * The standard {@link ValueFactory} for {@link PropertyType#STRING} values.
  52.    */
  53. > @Immutable
  54.   public final class StringValueFactory extends AbstractValueFactory<String> implements StringFactory {
  55.   

src/main/java/org/modeshape/jcr/value/basic/StringValueFactory.java:111: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  109.           if (value == null) return value;
  110.           if (decoder == null) decoder = getDecoder();
  111. >         return decoder.decode(value);
  112.       }
  113.   

src/main/java/org/modeshape/jcr/value/basic/UriValueFactory.java:47: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  45.    * The standard {@link ValueFactory} for {@link PropertyType#URI} values.
  46.    */
  47. > @Immutable
  48.   public class UriValueFactory extends AbstractValueFactory<URI> implements UriFactory {
  49.   

src/main/java/org/modeshape/jcr/value/basic/UriValueFactory.java:98: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  96.                          TextDecoder decoder ) {
  97.           // this probably doesn't really need to call the decoder, but by doing so then we don't care at all what the decoder does
  98. >         return create(getDecoder(decoder).decode(value));
  99.       }
  100.   

src/main/java/org/modeshape/jcr/value/binary/BinaryStoreValueFactory.java:49: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  47.    * concrete implementations.
  48.    */
  49. > @Immutable
  50.   public class BinaryStoreValueFactory extends AbstractValueFactory<BinaryValue> implements BinaryFactory {
  51.   

src/main/java/org/modeshape/jcr/value/binary/BinaryStoreValueFactory.java:117: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  115.                                  TextDecoder decoder ) {
  116.           if (value == null) return null;
  117. >         return create(getDecoder(decoder).decode(value));
  118.       }
  119.   

src/main/java/org/modeshape/jcr/value/basic/NameValueFactory.java:46: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  44.    * The standard {@link ValueFactory} for {@link PropertyType#NAME} values.
  45.    */
  46. > @Immutable
  47.   public class NameValueFactory extends AbstractValueFactory<Name> implements NameFactory {
  48.   

src/main/java/org/modeshape/jcr/value/basic/NameValueFactory.java:290: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  288.           }
  289.           if (asciiString.indexOf('/') == -1) {
  290. >             return create(asciiString);
  291.           }
  292.           throw new ValueFormatException(value, getPropertyType(), GraphI18n.errorConvertingType.text(URI.class.getSimpleName(),

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:50: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getLocalName()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  48.    * The standard {@link ValueFactory} for {@link PropertyType#NAME} values.
  49.    */
  50. > @Immutable
  51.   public class PathValueFactory extends AbstractValueFactory<Path> implements PathFactory {
  52.   

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:646: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getLocalName()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  644.           }
  645.           if (asciiString.indexOf('/') == -1) {
  646. >             return create(asciiString);
  647.           }
  648.           throw new ValueFormatException(value, getPropertyType(), GraphI18n.errorConvertingType.text(URI.class.getSimpleName(),

src/main/java/org/modeshape/jcr/value/basic/DecimalValueFactory.java:42: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `long DateTime.getMilliseconds()` of un-annotated interface `org.modeshape.jcr.api.value.DateTime`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  40.    * The standard {@link ValueFactory} for {@link PropertyType#DECIMAL} values.
  41.    */
  42. > @Immutable
  43.   public class DecimalValueFactory extends AbstractValueFactory<BigDecimal> {
  44.   

src/main/java/org/modeshape/jcr/value/basic/DecimalValueFactory.java:130: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `long DateTime.getMilliseconds()` of un-annotated interface `org.modeshape.jcr.api.value.DateTime`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  128.       public BigDecimal create( DateTime value ) throws ValueFormatException {
  129.           if (value == null) return null;
  130. >         return create(value.getMilliseconds());
  131.       }
  132.   

src/main/java/org/modeshape/jcr/value/basic/DoubleValueFactory.java:137: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `long DateTime.getMilliseconds()` of un-annotated interface `org.modeshape.jcr.api.value.DateTime`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  135.       public Double create( DateTime value ) throws ValueFormatException {
  136.           if (value == null) return null;
  137. >         return create(value.getMilliseconds());
  138.       }
  139.   

src/main/java/org/modeshape/jcr/value/basic/DoubleValueFactory.java:42: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `long DateTime.getMilliseconds()` of un-annotated interface `org.modeshape.jcr.api.value.DateTime`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  40.    * The standard {@link ValueFactory} for {@link PropertyType#DOUBLE} values.
  41.    */
  42. > @Immutable
  43.   public class DoubleValueFactory extends AbstractValueFactory<Double> {
  44.   

src/main/java/org/modeshape/jcr/value/basic/LongValueFactory.java:130: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `long DateTime.getMilliseconds()` of un-annotated interface `org.modeshape.jcr.api.value.DateTime`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  128.       public Long create( DateTime value ) throws ValueFormatException {
  129.           if (value == null) return null;
  130. >         return value.getMilliseconds();
  131.       }
  132.   

src/main/java/org/modeshape/jcr/value/basic/LongValueFactory.java:42: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `long DateTime.getMilliseconds()` of un-annotated interface `org.modeshape.jcr.api.value.DateTime`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  40.    * The standard {@link ValueFactory} for {@link PropertyType#LONG} values.
  41.    */
  42. > @Immutable
  43.   public class LongValueFactory extends AbstractValueFactory<Long> {
  44.   

src/main/java/org/modeshape/jcr/value/basic/StringValueFactory.java:53: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String DateTime.getString()` of un-annotated interface `org.modeshape.jcr.api.value.DateTime`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  51.    * The standard {@link ValueFactory} for {@link PropertyType#STRING} values.
  52.    */
  53. > @Immutable
  54.   public final class StringValueFactory extends AbstractValueFactory<String> implements StringFactory {
  55.   

src/main/java/org/modeshape/jcr/value/basic/StringValueFactory.java:160: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String DateTime.getString()` of un-annotated interface `org.modeshape.jcr.api.value.DateTime`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  158.       public String create( DateTime value ) throws ValueFormatException {
  159.           if (value == null) return null;
  160. >         return value.getString(); // ISO representation
  161.       }
  162.   

src/main/java/org/modeshape/jcr/value/basic/JodaDateTimeValueFactory.java:263: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `long DateTime.getMilliseconds()` of un-annotated interface `org.modeshape.jcr.api.value.DateTime`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  261.           assert original != null;
  262.           if (offsetInMillis == 0l) return original;
  263. >         long newMillis = original.getMilliseconds() + offsetInMillis;
  264.           return new JodaDateTime(newMillis, original.getTimeZoneId());
  265.       }

src/main/java/org/modeshape/jcr/value/basic/NameValueFactory.java:46: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  44.    * The standard {@link ValueFactory} for {@link PropertyType#NAME} values.
  45.    */
  46. > @Immutable
  47.   public class NameValueFactory extends AbstractValueFactory<Name> implements NameFactory {
  48.   

src/main/java/org/modeshape/jcr/value/basic/NameValueFactory.java:320: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String TextDecoder.decode(String)` of un-annotated interface `org.modeshape.common.text.TextDecoder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  318.       public Name create( BinaryValue value ) throws ValueFormatException, IoException {
  319.           // First create a string and then create the boolean from the string value ...
  320. >         return create(getStringValueFactory().create(value));
  321.       }
  322.   

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:50: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getLocalName()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  48.    * The standard {@link ValueFactory} for {@link PropertyType#NAME} values.
  49.    */
  50. > @Immutable
  51.   public class PathValueFactory extends AbstractValueFactory<Path> implements PathFactory {
  52.   

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:677: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getLocalName()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  675.       public Path create( BinaryValue value ) throws ValueFormatException, IoException {
  676.           // First create a string and then create the boolean from the string value ...
  677. >         return create(getStringValueFactory().create(value));
  678.       }
  679.   

src/main/java/org/modeshape/jcr/value/basic/StringValueFactory.java:53: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void BinaryValue.dispose()` of un-annotated interface `org.modeshape.jcr.value.BinaryValue`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  51.    * The standard {@link ValueFactory} for {@link PropertyType#STRING} values.
  52.    */
  53. > @Immutable
  54.   public final class StringValueFactory extends AbstractValueFactory<String> implements StringFactory {
  55.   

src/main/java/org/modeshape/jcr/value/basic/StringValueFactory.java:270: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void BinaryValue.dispose()` of un-annotated interface `org.modeshape.jcr.value.BinaryValue`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  268.               throw new IoException(e);
  269.           } finally {
  270. >             value.dispose();
  271.           }
  272.       }

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:50: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `int Path.size()` of un-annotated interface `org.modeshape.jcr.value.Path`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  48.    * The standard {@link ValueFactory} for {@link PropertyType#NAME} values.
  49.    */
  50. > @Immutable
  51.   public class PathValueFactory extends AbstractValueFactory<Path> implements PathFactory {
  52.   

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:290: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `int Path.size()` of un-annotated interface `org.modeshape.jcr.value.Path`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  288.           if (value == null) return null;
  289.           try {
  290. >             return new ChildPath(RootPath.INSTANCE, new BasicPathSegment(value));
  291.           } catch (IllegalArgumentException e) {
  292.               throw new ValueFormatException(value, getPropertyType(),

src/main/java/org/modeshape/jcr/value/basic/StringValueFactory.java:53: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `NamespaceRegistry NamespaceRegistry$Holder.getNamespaceRegistry()` of un-annotated interface `org.modeshape.jcr.value.NamespaceRegistry$Holder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  51.    * The standard {@link ValueFactory} for {@link PropertyType#STRING} values.
  52.    */
  53. > @Immutable
  54.   public final class StringValueFactory extends AbstractValueFactory<String> implements StringFactory {
  55.   

src/main/java/org/modeshape/jcr/value/basic/StringValueFactory.java:167: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `NamespaceRegistry NamespaceRegistry$Holder.getNamespaceRegistry()` of un-annotated interface `org.modeshape.jcr.value.NamespaceRegistry$Holder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  165.           if (value == null) return null;
  166.           if (namespaceRegistryHolder != null) {
  167. >             return value.getString(namespaceRegistryHolder.getNamespaceRegistry(), getEncoder());
  168.           }
  169.           return value.getString(getEncoder());

src/main/java/org/modeshape/jcr/value/basic/UriValueFactory.java:47: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `NamespaceRegistry NamespaceRegistry$Holder.getNamespaceRegistry()` of un-annotated interface `org.modeshape.jcr.value.NamespaceRegistry$Holder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  45.    * The standard {@link ValueFactory} for {@link PropertyType#URI} values.
  46.    */
  47. > @Immutable
  48.   public class UriValueFactory extends AbstractValueFactory<URI> implements UriFactory {
  49.   

src/main/java/org/modeshape/jcr/value/basic/UriValueFactory.java:172: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `NamespaceRegistry NamespaceRegistry$Holder.getNamespaceRegistry()` of un-annotated interface `org.modeshape.jcr.value.NamespaceRegistry$Holder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  170.       public URI create( Name value ) {
  171.           if (value == null) return null;
  172. >         return create("./" + value.getString(namespaceRegistryHolder.getNamespaceRegistry()));
  173.       }
  174.   

src/main/java/org/modeshape/jcr/value/basic/NameValueFactory.java:46: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Path$Segment Path.getLastSegment()` of un-annotated interface `org.modeshape.jcr.value.Path`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  44.    * The standard {@link ValueFactory} for {@link PropertyType#NAME} values.
  45.    */
  46. > @Immutable
  47.   public class NameValueFactory extends AbstractValueFactory<Name> implements NameFactory {
  48.   

src/main/java/org/modeshape/jcr/value/basic/NameValueFactory.java:255: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Path$Segment Path.getLastSegment()` of un-annotated interface `org.modeshape.jcr.value.Path`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  253.           if (!value.isAbsolute() && value.size() == 1) {
  254.               // A relative name of length 1 is converted to a name
  255. >             Path.Segment segment = value.getLastSegment();
  256.               // Can only convert if the path has no SNS index ...
  257.               if (!segment.hasIndex()) return segment.getName();

src/main/java/org/modeshape/jcr/value/basic/StringValueFactory.java:53: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Path$Segment Path.getLastSegment()` of un-annotated interface `org.modeshape.jcr.value.Path`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  51.    * The standard {@link ValueFactory} for {@link PropertyType#STRING} values.
  52.    */
  53. > @Immutable
  54.   public final class StringValueFactory extends AbstractValueFactory<String> implements StringFactory {
  55.   

src/main/java/org/modeshape/jcr/value/basic/StringValueFactory.java:177: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Path$Segment Path.getLastSegment()` of un-annotated interface `org.modeshape.jcr.value.Path`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  175.           if (value.isIdentifier()) {
  176.               // Get the identifier segment ...
  177. >             Segment segment = value.getLastSegment();
  178.               assert segment.isIdentifier();
  179.               try {

src/main/java/org/modeshape/jcr/value/basic/UriValueFactory.java:47: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `NamespaceRegistry NamespaceRegistry$Holder.getNamespaceRegistry()` of un-annotated interface `org.modeshape.jcr.value.NamespaceRegistry$Holder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  45.    * The standard {@link ValueFactory} for {@link PropertyType#URI} values.
  46.    */
  47. > @Immutable
  48.   public class UriValueFactory extends AbstractValueFactory<URI> implements UriFactory {
  49.   

src/main/java/org/modeshape/jcr/value/basic/UriValueFactory.java:179: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `NamespaceRegistry NamespaceRegistry$Holder.getNamespaceRegistry()` of un-annotated interface `org.modeshape.jcr.value.NamespaceRegistry$Holder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  177.           if (value == null) return null;
  178.           if (value.isAbsolute()) {
  179. >             return create("/" + value.getString(namespaceRegistryHolder.getNamespaceRegistry()));
  180.           }
  181.           return create("./" + value.getString(namespaceRegistryHolder.getNamespaceRegistry()));

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:462: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `List Path.getSegmentsList()` of un-annotated interface `org.modeshape.jcr.value.Path`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  460.   
  461.           List<Segment> segments = new ArrayList<Segment>(parentPath.size() + 1);
  462. >         segments.addAll(parentPath.getSegmentsList());
  463.           for (Name segmentName : segmentNames) {
  464.               if (segmentName == null) {

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:491: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `List Path.getSegmentsList()` of un-annotated interface `org.modeshape.jcr.value.Path`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  489.   
  490.           List<Segment> segmentsList = new ArrayList<Segment>(parentPath.size() + 1);
  491. >         segmentsList.addAll(parentPath.getSegmentsList());
  492.           for (Segment segment : segments) {
  493.               if (segment == null) {

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:517: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `List Path.getSegmentsList()` of un-annotated interface `org.modeshape.jcr.value.Path`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  515.   
  516.           List<Segment> segmentsList = new LinkedList<Segment>();
  517. >         segmentsList.addAll(parentPath.getSegmentsList());
  518.           for (Segment segment : segments) {
  519.               if (segment == null) {

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:553: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getLocalName()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  551.           if (singleChild) {
  552.               try {
  553. >                 Path.Segment childSegment = createSegment(subpath);
  554.                   if (childSegment.isIdentifier()) {
  555.                       throw new InvalidPathException(GraphI18n.unableToCreatePathUsingIdentifierPathAndAnotherPath.text(parentPath,

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:449: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getLocalName()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  447.                           String segmentName,
  448.                           int index ) {
  449. >         return create(parentPath, getNameValueFactory().create(segmentName), index);
  450.       }
  451.   

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:442: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getLocalName()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  440.           CheckArg.isNotNull(parentPath, "parent path");
  441.           CheckArg.isNotNull(segmentName, "segment name");
  442. >         return new ChildPath(parentPath, new BasicPathSegment(segmentName, index));
  443.       }
  444.   

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:424: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `List Path.getSegmentsList()` of un-annotated interface `org.modeshape.jcr.value.Path`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  422.               if (childPath.isAbsolute() == parentPath.isAbsolute()) return childPath;
  423.               // They aren't the same absoluteness, so create a new one ...
  424. >             return new BasicPath(childPath.getSegmentsList(), parentPath.isAbsolute());
  425.           }
  426.           List<Segment> segments = new ArrayList<Segment>(parentPath.size() + childPath.size());

src/main/java/org/modeshape/jcr/value/basic/NameValueFactory.java:46: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Name Path$Segment.getName()` of un-annotated interface `org.modeshape.jcr.value.Path$Segment`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  44.    * The standard {@link ValueFactory} for {@link PropertyType#NAME} values.
  45.    */
  46. > @Immutable
  47.   public class NameValueFactory extends AbstractValueFactory<Name> implements NameFactory {
  48.   

src/main/java/org/modeshape/jcr/value/basic/NameValueFactory.java:268: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Name Path$Segment.getName()` of un-annotated interface `org.modeshape.jcr.value.Path$Segment`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  266.           if (segment == null) return null;
  267.           // Can only convert if the path has no SNS index ...
  268. >         if (!segment.hasIndex()) return segment.getName();
  269.           throw new ValueFormatException(segment, getPropertyType(),
  270.                                          GraphI18n.errorConvertingType.text(Path.Segment.class.getSimpleName(),

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:50: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean Path$Segment.isParentReference()` of un-annotated interface `org.modeshape.jcr.value.Path$Segment`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  48.    * The standard {@link ValueFactory} for {@link PropertyType#NAME} values.
  49.    */
  50. > @Immutable
  51.   public class PathValueFactory extends AbstractValueFactory<Path> implements PathFactory {
  52.   

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:306: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean Path$Segment.isParentReference()` of un-annotated interface `org.modeshape.jcr.value.Path$Segment`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  304.       @Override
  305.       public Path create( Path.Segment value ) {
  306. >         return createAbsolutePath(value);
  307.       }
  308.   

src/main/java/org/modeshape/jcr/value/basic/StringValueFactory.java:53: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getLocalName()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  51.    * The standard {@link ValueFactory} for {@link PropertyType#STRING} values.
  52.    */
  53. > @Immutable
  54.   public final class StringValueFactory extends AbstractValueFactory<String> implements StringFactory {
  55.   

src/main/java/org/modeshape/jcr/value/basic/StringValueFactory.java:202: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getLocalName()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  200.               try {
  201.                   // The local part of the segment's name should be the identifier, though it may not be a UUID ...
  202. >                 return value.getName().getLocalName();
  203.               } catch (IllegalArgumentException err) {
  204.                   throw new ValueFormatException(value, PropertyType.STRING,

src/main/java/org/modeshape/jcr/value/basic/UriValueFactory.java:47: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `NamespaceRegistry NamespaceRegistry$Holder.getNamespaceRegistry()` of un-annotated interface `org.modeshape.jcr.value.NamespaceRegistry$Holder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  45.    * The standard {@link ValueFactory} for {@link PropertyType#URI} values.
  46.    */
  47. > @Immutable
  48.   public class UriValueFactory extends AbstractValueFactory<URI> implements UriFactory {
  49.   

src/main/java/org/modeshape/jcr/value/basic/UriValueFactory.java:187: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `NamespaceRegistry NamespaceRegistry$Holder.getNamespaceRegistry()` of un-annotated interface `org.modeshape.jcr.value.NamespaceRegistry$Holder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  185.       public URI create( Path.Segment value ) {
  186.           if (value == null) return null;
  187. >         return create("./" + value.getString(namespaceRegistryHolder.getNamespaceRegistry()));
  188.       }
  189.   

src/main/java/org/modeshape/jcr/value/basic/StringValueFactory.java:53: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Reference.getString(TextEncoder)` of un-annotated interface `org.modeshape.jcr.value.Reference`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  51.    * The standard {@link ValueFactory} for {@link PropertyType#STRING} values.
  52.    */
  53. > @Immutable
  54.   public final class StringValueFactory extends AbstractValueFactory<String> implements StringFactory {
  55.   

src/main/java/org/modeshape/jcr/value/basic/StringValueFactory.java:219: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Reference.getString(TextEncoder)` of un-annotated interface `org.modeshape.jcr.value.Reference`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  217.       public String create( Reference value ) {
  218.           if (value == null) return null;
  219. >         return value.getString(getEncoder());
  220.       }
  221.   

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:323: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean Path$Segment.isParentReference()` of un-annotated interface `org.modeshape.jcr.value.Path$Segment`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  321.               return new ChildPath(RootPath.INSTANCE, segments.get(0));
  322.           }
  323. >         return new BasicPath(segments, true);
  324.       }
  325.   

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:340: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean Path$Segment.isParentReference()` of un-annotated interface `org.modeshape.jcr.value.Path$Segment`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  338.               return new ChildPath(RootPath.INSTANCE, segmentsList.get(0));
  339.           }
  340. >         return new BasicPath(segmentsList, true);
  341.       }
  342.   

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:357: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean Path$Segment.isParentReference()` of un-annotated interface `org.modeshape.jcr.value.Path$Segment`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  355.               return new ChildPath(RootPath.INSTANCE, segmentsList.get(0));
  356.           }
  357. >         return new BasicPath(segmentsList, true);
  358.       }
  359.   

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1209: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getLocalName()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1207.   
  1208.           // And finally append the new node as a child of this node ...
  1209. >         appended(true).append(key, name);
  1210.   
  1211.           return child;

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1201: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `MutableCachedNode SessionNode.createChild(SessionCache,NodeKey,Name,Iterable)` indirectly mutates container `changes.addedStrong` via call to `put` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1199.           if (properties != null) {
  1200.               for (Property property : properties) {
  1201. >                 if (property != null) child.setProperty(cache, property);
  1202.               }
  1203.           }

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1188: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `MutableCachedNode SessionNode.createChild(SessionCache,NodeKey,Name,Iterable)` indirectly reads without synchronization from container `session.changedNodes` via call to `get`. Potentially races with write in method `SessionNode.createChild(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1186.                                             Iterable<Property> properties ) {
  1187.           WritableSessionCache session = writableSession(cache);
  1188. >         session.assertInSession(this);
  1189.   
  1190.           if (key == null) key = getKey().withRandomId();

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1165: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `MutableCachedNode SessionNode.createChild(SessionCache,NodeKey,Name,Property,org.modeshape.jcr.value.Property[])` indirectly mutates container `changes.addedStrong` via call to `put` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1163.           // Add the properties ...
  1164.           if (firstProperty != null) {
  1165. >             child.setProperty(cache, firstProperty);
  1166.           }
  1167.           if (additionalProperties != null) {

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1177: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getLocalName()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1175.   
  1176.           // And finally append the new node as a child of this node ...
  1177. >         appended(true).append(key, name);
  1178.   
  1179.           return child;

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1153: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `MutableCachedNode SessionNode.createChild(SessionCache,NodeKey,Name,Property,org.modeshape.jcr.value.Property[])` indirectly reads without synchronization from container `session.changedNodes` via call to `get`. Potentially races with write in method `SessionNode.setPermissions(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1151.                                             Property... additionalProperties ) {
  1152.           WritableSessionCache session = writableSession(cache);
  1153. >         session.assertInSession(this);
  1154.   
  1155.           if (key == null) key = getKey().withRandomId();

src/main/java/org/modeshape/jcr/RepositoryIndexManager.java:429: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getString()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  427.       @Override
  428.       public IndexDefinitionTemplate createIndexDefinitionTemplate() {
  429. >         return new RepositoryIndexDefinitionTemplate();
  430.       }
  431.   

src/main/java/org/modeshape/jcr/cache/document/SessionChildReferences.java:215: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Iterator ChildReferences.iterator(ChildReferences$Context)` of un-annotated interface `org.modeshape.jcr.cache.ChildReferences`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  213.   
  214.       protected Iterator<ChildReference> createIterator( final Context context ) {
  215. >         Iterator<ChildReference> firstIter = persisted.iterator(context);
  216.           final MutableChildReferences appended = this.appended;
  217.           Iterable<ChildReference> second = new Iterable<ChildReference>() {

src/main/java/org/modeshape/jcr/cache/document/SessionChildReferences.java:197: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Iterator ChildReferences.iterator(Name,ChildReferences$Context)` of un-annotated interface `org.modeshape.jcr.cache.ChildReferences`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  195.       protected Iterator<ChildReference> createIterator( final Name name,
  196.                                                          final Context context ) {
  197. >         Iterator<ChildReference> firstIter = persisted.iterator(name, context);
  198.           final MutableChildReferences appended = this.appended;
  199.           Iterable<ChildReference> second = new Iterable<ChildReference>() {

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:375: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean Path$Segment.isParentReference()` of un-annotated interface `org.modeshape.jcr.value.Path$Segment`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  373.               segments.add(new BasicPathSegment(segmentName));
  374.           }
  375. >         return new BasicPath(segments, false);
  376.       }
  377.   

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:387: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean Path$Segment.isIdentifier()` of un-annotated interface `org.modeshape.jcr.value.Path$Segment`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  385.               }
  386.               assert segment != null;
  387. >             if (segment.isIdentifier()) {
  388.                   throw new InvalidPathException(
  389.                                                  GraphI18n.unableToCreateRelativePathWithIdentifierSegment.text(segments.toString()));

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:404: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean Path$Segment.isIdentifier()` of un-annotated interface `org.modeshape.jcr.value.Path$Segment`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  402.               }
  403.               assert segment != null;
  404. >             if (segment.isIdentifier()) {
  405.                   throw new InvalidPathException(
  406.                                                  GraphI18n.unableToCreateRelativePathWithIdentifierSegment.text(segments.toString()));

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:588: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getLocalName()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  586.       @Override
  587.       public Segment createSegment( String segmentName ) {
  588. >         return createSegment(segmentName, getDecoder());
  589.       }
  590.   

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:626: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getLocalName()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  624.           if (Path.SELF.equals(segmentName)) return Path.SELF_SEGMENT;
  625.           if (Path.PARENT.equals(segmentName)) return Path.PARENT_SEGMENT;
  626. >         return new BasicPathSegment(getNameValueFactory().create(segmentName), index);
  627.       }
  628.   

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:613: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getLocalName()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  611.           try {
  612.               return new BasicPathSegment(getNameValueFactory().create(segmentName.substring(0, startBracketNdx), decoder),
  613. >                                         Integer.parseInt(ndx));
  614.           } catch (NumberFormatException err) {
  615.               throw new ValueFormatException(segmentName, getPropertyType(), GraphI18n.invalidIndexInSegmentName.text(ndx,

src/main/java/org/modeshape/jcr/value/basic/PathValueFactory.java:583: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getLocalName()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  581.           if (Path.SELF_NAME.equals(segmentName)) return Path.SELF_SEGMENT;
  582.           if (Path.PARENT_NAME.equals(segmentName)) return Path.PARENT_SEGMENT;
  583. >         return new BasicPathSegment(segmentName, index);
  584.       }
  585.   

src/main/java/org/modeshape/jcr/JcrWorkspace.java:784: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.createWorkspace(String)` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  782.           session.checkLive();
  783.           try {
  784. >             session.checkWorkspacePermission(name, ModeShapePermissions.CREATE_WORKSPACE);
  785.               JcrRepository repository = session.repository();
  786.               if (repository.hasWorkspace(name)) {

src/main/java/org/modeshape/jcr/JcrWorkspace.java:794: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void Problems.addWarning(I18n,java.lang.Object[])` of un-annotated interface `org.modeshape.common.collection.Problems`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  792.   
  793.               // import any initial content
  794. >             repository.runningState().initialContentImporter().importInitialContent(name);
  795.           } catch (UnsupportedOperationException e) {
  796.               throw new UnsupportedRepositoryOperationException(e.getMessage());

src/main/java/org/modeshape/jcr/JcrWorkspace.java:810: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.createWorkspace(String,String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  808.           JcrSession srcWorkspaceSession = session.spawnSession(srcWorkspace, true);
  809.   
  810. >         deepClone(srcWorkspaceSession, srcWorkspaceSession.getRootNode().key(), newWorkspaceSession,
  811.                     newWorkspaceSession.getRootNode().key());
  812.       }

src/main/java/org/modeshape/jcr/JcrWorkspace.java:805: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void Problems.addWarning(I18n,java.lang.Object[])` of un-annotated interface `org.modeshape.common.collection.Problems`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  803.           throws AccessDeniedException, UnsupportedRepositoryOperationException, NoSuchWorkspaceException, RepositoryException {
  804.           validateCrossWorkspaceAction(srcWorkspace);
  805. >         createWorkspace(name);
  806.   
  807.           JcrSession newWorkspaceSession = session.spawnSession(name, false);

src/main/java/org/modeshape/jcr/JcrWorkspace.java:804: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.createWorkspace(String,String)` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  802.                                    String srcWorkspace )
  803.           throws AccessDeniedException, UnsupportedRepositoryOperationException, NoSuchWorkspaceException, RepositoryException {
  804. >         validateCrossWorkspaceAction(srcWorkspace);
  805.           createWorkspace(name);
  806.   

src/main/java/org/modeshape/jcr/value/binary/DatabaseBinaryStore.java:155: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Database DatabaseBinaryStore.database()` reads without synchronization from `this.database`. Potentially races with write in method `DatabaseBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  153.   
  154.       protected Database database() {
  155. >         if (this.database == null) {
  156.               Connection connection = newConnection();
  157.               try {

src/main/java/org/modeshape/jcr/value/binary/DatabaseBinaryStore.java:156: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Database DatabaseBinaryStore.database()` indirectly reads without synchronization from `this.dataSource`. Potentially races with write in method `DatabaseBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  154.       protected Database database() {
  155.           if (this.database == null) {
  156. >             Connection connection = newConnection();
  157.               try {
  158.                   this.database = new Database(connection);

src/main/java/org/modeshape/jcr/value/binary/DatabaseBinaryStore.java:158: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Database DatabaseBinaryStore.database()` writes to field `this.database` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  156.               Connection connection = newConnection();
  157.               try {
  158. >                 this.database = new Database(connection);
  159.               } catch (Throwable t) {
  160.                   throw new RuntimeException(t);

src/main/java/org/modeshape/jcr/JcrWorkspace.java:841: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.deepClone(JcrSession,NodeKey,JcrSession,NodeKey)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  839.               if (srcNode.isNodeType(JcrMixLexicon.VERSIONABLE)) {
  840.                   // Preserve the base version of the versionable nodes (this will in turn preserve the version history)
  841. >                 cloneSession.setDesiredBaseVersionKey(sourceKey, srcNode.getBaseVersion().key());
  842.               }
  843.           }

src/main/java/org/modeshape/jcr/JcrWorkspace.java:824: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.deepClone(JcrSession,NodeKey,JcrSession,NodeKey)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  822.   
  823.           SessionCache cloneCache = cloneSession.cache();
  824. >         MutableCachedNode mutableCloneNode = cloneSession.node(cloneNodeKey, null).mutable();
  825.   
  826.           /**

src/main/java/org/modeshape/jcr/JcrWorkspace.java:844: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void Transactions$Transaction.commit()` of un-annotated interface `org.modeshape.jcr.txn.Transactions$Transaction`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  842.               }
  843.           }
  844. >         cloneSession.save();
  845.       }
  846.   

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1416: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Path CachedNode.getPath(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1414.           final WritableSessionCache writableSessionCache = writableSession(cache);
  1415.           writableSessionCache.assertInSession(this);
  1416. >         DeepClone cloner = new DeepClone(this, writableSessionCache, sourceNode, sourceCache, systemWorkspaceKey, connectors);
  1417.           cloner.execute();
  1418.       }

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1417: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void SessionNode.deepClone(SessionCache,CachedNode,SessionCache,String,Connectors)` indirectly reads with synchronization from container `changes.addedStrong` via call to `get`. Potentially races with unsynchronized write in method `SessionNode.setProperties(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1415.           writableSessionCache.assertInSession(this);
  1416.           DeepClone cloner = new DeepClone(this, writableSessionCache, sourceNode, sourceCache, systemWorkspaceKey, connectors);
  1417. >         cloner.execute();
  1418.       }
  1419.   

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1403: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Path CachedNode.getPath(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1401.           final WritableSessionCache writableSessionCache = writableSession(cache);
  1402.           writableSessionCache.assertInSession(this);
  1403. >         DeepCopy copier = new DeepCopy(this, writableSessionCache, sourceNode, sourceCache, systemWorkspaceKey, connectors);
  1404.           copier.execute();
  1405.           return copier.getSourceToTargetKeys();

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1404: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Map SessionNode.deepCopy(SessionCache,CachedNode,SessionCache,String,Connectors)` indirectly reads with synchronization from container `changes.addedStrong` via call to `get`. Potentially races with unsynchronized write in method `SessionNode.setProperties(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1402.           writableSessionCache.assertInSession(this);
  1403.           DeepCopy copier = new DeepCopy(this, writableSessionCache, sourceNode, sourceCache, systemWorkspaceKey, connectors);
  1404. >         copier.execute();
  1405.           return copier.getSourceToTargetKeys();
  1406.       }

src/main/java/org/modeshape/jcr/LocalEnvironment.java:371: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Configuration EmbeddedCacheManager.defineConfiguration(String,Configuration)` of un-annotated interface `org.infinispan.manager.EmbeddedCacheManager`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.Environment` is annotated `@ThreadSafe`.
  369.               if (container == null) container = newContainer;
  370.           }
  371. >         return ((EmbeddedCacheManager)container).defineConfiguration(cacheName, configuration);
  372.       }
  373.   

src/main/java/org/modeshape/jcr/LocalEnvironment.java:343: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Configuration EmbeddedCacheManager.defineConfiguration(String,Configuration)` of un-annotated interface `org.infinispan.manager.EmbeddedCacheManager`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.Environment` is annotated `@ThreadSafe`.
  341.           CheckArg.isNotNull(cacheName, "cacheName");
  342.           CheckArg.isNotNull(configuration, "configuration");
  343. >         return defineCache(null, cacheName, configuration);
  344.       }
  345.   

src/main/java/org/modeshape/jcr/JcrWorkspace.java:851: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.deleteWorkspace(String)` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  849.           throws AccessDeniedException, UnsupportedRepositoryOperationException, NoSuchWorkspaceException, RepositoryException {
  850.           session.checkLive();
  851. >         session.checkWorkspacePermission(name, ModeShapePermissions.DELETE_WORKSPACE);
  852.           // start an internal remove session which needs to act as a unit for the entire operation
  853.           JcrSession removeSession = session.spawnSession(name, false);

src/main/java/org/modeshape/jcr/JcrWorkspace.java:867: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.deleteWorkspace(String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  865.                       continue;
  866.                   }
  867. >                 child.remove();
  868.               }
  869.   

src/main/java/org/modeshape/jcr/JcrWorkspace.java:872: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void Transactions$Transaction.commit()` of un-annotated interface `org.modeshape.jcr.txn.Transactions$Transaction`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  870.               // then remove the workspace itself and unlink the system content. This method will create & save the session cache
  871.               // therefore, we don't need to call removeSession.save() from here.
  872. >             if (!repositoryCache.destroyWorkspace(name, (WritableSessionCache)removeSession.cache())) {
  873.                   throw new NoSuchWorkspaceException(JcrI18n.workspaceNotFound.text(name, getName()));
  874.               }

src/main/java/org/modeshape/jcr/ModeShapeEngine.java:478: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void Problems.addError(I18n,java.lang.Object[])` of un-annotated interface `org.modeshape.common.collection.Problems`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  476.   
  477.           final String repoName = repositoryKey != null ? repositoryKey : repositoryConfiguration.getName();
  478. >         Problems problems = repositoryConfiguration.validate();
  479.           if (problems.hasErrors()) {
  480.               throw new ConfigurationException(problems, JcrI18n.repositoryConfigurationIsNotValid.text(repoName,

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:1575: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WritableSessionCache.destroy(NodeKey)` indirectly reads with synchronization from `this.changedNodes`. Potentially races with unsynchronized write in method `WritableSessionCache.clearState()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1573.           assert key != null;
  1574.           final WorkspaceCache workspace = workspaceCache();
  1575. >         CachedNode topNode = getNode(key);
  1576.           if (topNode == null) {
  1577.               throw new NodeNotFoundException(key);

src/main/java/org/modeshape/jcr/mimetype/ContentDetector.java:74: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String ContentDetector.detect(InputStream,Metadata)` reads without synchronization from `this.detector`. Potentially races with write in method `ContentDetector.initDetector(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  72.               if (inputStream != null) {
  73.                   try (TikaInputStream tikaInputStream = TikaInputStream.get(inputStream)) {
  74. >                     detectedMimeType = detector.detect(tikaInputStream, metadata);
  75.                   } 
  76.               } else {

src/main/java/org/modeshape/jcr/mimetype/NameOnlyDetector.java:64: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String NameOnlyDetector.detect(InputStream,Metadata)` reads without synchronization from `this.detector`. Potentially races with write in method `NameOnlyDetector.initDetector(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  62.           try {
  63.               // we never care about the stream here
  64. >             MediaType detectedMimeType = detector.detect(null, metadata);
  65.               if (logger.isTraceEnabled()) {
  66.                   logger.trace("MIME type for '" + metadata.get(Metadata.RESOURCE_NAME_KEY) + "' ==> " + detectedMimeType);

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:230: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WritableSessionCache.doClear()` reads with synchronization from `this.changedNodes`. Potentially races with unsynchronized write in method `WritableSessionCache.clearState()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  228.               lock.lock();
  229.               referrerChangesForRemovedNodes.clear();
  230. >             changedNodes.clear();
  231.               changedNodesInOrder.clear();
  232.               referrerChangesForRemovedNodes.clear();

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:241: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Path CachedNode.getPath(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  239.       @Override
  240.       protected void doClear( CachedNode node ) {
  241. >         final Path nodePath = node.getPath(this);
  242.           Lock lock = this.lock.writeLock();
  243.           try {

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:246: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WritableSessionCache.doClear(CachedNode)` indirectly reads with synchronization from `this.changedNodes`. Potentially races with unsynchronized write in method `WritableSessionCache.clearState()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  244.               lock.lock();
  245.               // we must first remove the children and only then the parents, otherwise child paths won't be found
  246. >             List<SessionNode> nodesToRemoveInOrder = getChangedNodesAtOrBelowChildrenFirst(nodePath);
  247.               for (SessionNode nodeToRemove : nodesToRemoveInOrder) {
  248.                   NodeKey key = nodeToRemove.getKey();

src/main/java/org/modeshape/jcr/JcrNode.java:111: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void SessionCache.destroy(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  109.               // There are no shares, so destroy the node and the shared set ...
  110.               parent.removeChild(cache, key);
  111. >             cache.destroy(key);
  112.               shareableNodeCache.destroyed(key);
  113.               return;

src/main/java/org/modeshape/jcr/JcrNode.java:119: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrNode.doRemove()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  117.           // NOT destroy the node, and adjust the SharedSet ...
  118.           parent.removeChild(cache, key);
  119. >         shareableNodeCache.removed(this);
  120.       }
  121.   }

src/main/java/org/modeshape/jcr/LocalEnvironment.java:128: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void CacheContainer.stop()` of un-annotated interface `org.infinispan.manager.CacheContainer`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.Environment` is annotated `@ThreadSafe`.
  126.       protected void doShutdown() {
  127.           for (CacheContainer container : containers.values()) {
  128. >             shutdown(container);
  129.           }
  130.           containers.clear();

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2950: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.doneMerge(Version)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2948.       public void doneMerge( Version version )
  2949.           throws VersionException, InvalidItemStateException, UnsupportedRepositoryOperationException, RepositoryException {
  2950. >         versionManager().doneMerge(this, version);
  2951.       }
  2952.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrSystemNode.doneMerge(Version)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/JcrNodeType.java:606: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String NodeType.getName()` of un-annotated interface `javax.jcr.nodetype.NodeType`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  604.           if (obj instanceof NodeType) {
  605.               NodeType that = (NodeType)obj;
  606. >             return this.getName().equals(that.getName());
  607.           }
  608.           return false;

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:539: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `NodeKey CachedNode.getKey()` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  537.           if (obj instanceof CachedNode) {
  538.               CachedNode that = (CachedNode)obj;
  539. >             return this.getKey().equals(that.getKey());
  540.           }
  541.           return false;

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1618: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `NodeKey CachedNode.getKey()` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1616.           if (obj instanceof CachedNode) {
  1617.               CachedNode that = (CachedNode)obj;
  1618. >             return this.getKey().equals(that.getKey());
  1619.           }
  1620.           return false;

src/main/java/org/modeshape/jcr/query/parse/QueryParsers.java:196: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String QueryParser.getLanguage()` of un-annotated interface `org.modeshape.jcr.query.parse.QueryParser`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  194.           if (obj instanceof QueryParsers) {
  195.               QueryParsers that = (QueryParsers)obj;
  196. >             return this.getLanguages().equals(that.getLanguages());
  197.           }
  198.           return false;

src/main/java/org/modeshape/jcr/JcrWorkspace.java:959: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `ModeShapeFederationManager JcrWorkspace.federationManager()` reads without synchronization from `this.federationManager`. Potentially races with write in method `JcrWorkspace.getFederationManager()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  957.   
  958.       final ModeShapeFederationManager federationManager() {
  959. >         if (federationManager == null) {
  960.               try {
  961.                   lock.lock();

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:501: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Collection Multimap.get(Object)` of un-annotated interface `org.modeshape.common.collection.Multimap`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  499.                                                               NodeTypes nodeTypes ) {
  500.           JcrPropertyDefinition definition = null;
  501. >         int propertyType = PropertyTypeUtil.jcrPropertyTypeFor(property);
  502.   
  503.           // If single-valued ...

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:509: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `JcrPropertyDefinition AbstractJcrNode.findBestPropertyDefinition(Name,Collection,Property,boolean,boolean,boolean,NodeTypes)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  507.               Object value = property.getFirstValue();
  508.               Value jcrValue = new JcrValue(factories, propertyType, value);
  509. >             definition = nodeTypes.findPropertyDefinition(session, primaryTypeNameOfParent, mixinTypeNamesOfParent,
  510.                                                             property.getName(), jcrValue, true, skipProtected);
  511.           } else {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:518: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `JcrPropertyDefinition AbstractJcrNode.findBestPropertyDefinition(Name,Collection,Property,boolean,boolean,boolean,NodeTypes)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  516.                   jcrValues[index++] = new JcrValue(factories, propertyType, value);
  517.               }
  518. >             definition = nodeTypes.findPropertyDefinition(session, primaryTypeNameOfParent, mixinTypeNamesOfParent,
  519.                                                             property.getName(), jcrValues, skipProtected);
  520.           }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2058: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Collection AbstractJcrNode.findJcrProperties(Iterator)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2056.                   Property property = propertyIterator.next();
  2057.                   Name propertyName = property.getName();
  2058. >                 AbstractJcrProperty jcrProp = getProperty(propertyName);
  2059.                   if (jcrProp != null) result.add(jcrProp);
  2060.               }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2057: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Name Property.getName()` of un-annotated interface `org.modeshape.jcr.value.Property`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  2055.               while (propertyIterator.hasNext()) {
  2056.                   Property property = propertyIterator.next();
  2057. >                 Name propertyName = property.getName();
  2058.                   AbstractJcrProperty jcrProp = getProperty(propertyName);
  2059.                   if (jcrProp != null) result.add(jcrProp);

src/main/java/org/modeshape/jcr/RepositoryLockManager.java:539: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Object Property.getFirstValue()` of un-annotated interface `org.modeshape.jcr.value.Property`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  537.       protected final boolean firstBoolean( Property property ) {
  538.           if (property == null) return false;
  539. >         return repository.context().getValueFactories().getBooleanFactory().create(property.getFirstValue());
  540.       }
  541.   

src/main/java/org/modeshape/jcr/RepositoryLockManager.java:544: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Object Property.getFirstValue()` of un-annotated interface `org.modeshape.jcr.value.Property`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  542.       protected final DateTime firstDate( Property property ) {
  543.           if (property == null) return null;
  544. >         return repository.context().getValueFactories().getDateFactory().create(property.getFirstValue());
  545.       }
  546.   

src/main/java/org/modeshape/jcr/RepositoryLockManager.java:534: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Object Property.getFirstValue()` of un-annotated interface `org.modeshape.jcr.value.Property`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  532.       protected final String firstString( Property property ) {
  533.           if (property == null) return null;
  534. >         return repository.context().getValueFactories().getStringFactory().create(property.getFirstValue());
  535.       }
  536.   

src/main/java/org/modeshape/jcr/cache/change/RecordingChanges.java:309: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void RecordingChanges.freeze(String,Map,DateTime)` writes to field `this.timestamp` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  307.               this.userData = Collections.unmodifiableMap(userData);
  308.           }
  309. >         this.timestamp = timestamp;
  310.       }
  311.   

src/main/java/org/modeshape/jcr/cache/change/RecordingChanges.java:307: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void RecordingChanges.freeze(String,Map,DateTime)` writes to field `this.userData` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  305.           this.userId = userId;
  306.           if (userData != null) {
  307. >             this.userData = Collections.unmodifiableMap(userData);
  308.           }
  309.           this.timestamp = timestamp;

src/main/java/org/modeshape/jcr/cache/change/RecordingChanges.java:305: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void RecordingChanges.freeze(String,Map,DateTime)` writes to field `this.userId` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  303.                           Map<String, String> userData,
  304.                           DateTime timestamp ) {
  305. >         this.userId = userId;
  306.           if (userData != null) {
  307.               this.userData = Collections.unmodifiableMap(userData);

src/main/java/org/modeshape/jcr/RepositoryLockManager.java:278: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `NodeKey RepositoryLockManager.generateLockKey(NodeKey,NodeKey)` indirectly writes to field `prototype.sourceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  276.       protected final NodeKey generateLockKey( NodeKey prototype,
  277.                                                NodeKey lockedNodeKey ) {
  278. >         return prototype.withId("mode:lock-" + lockedNodeKey.toString());
  279.       }
  280.   

src/main/java/org/modeshape/jcr/JcrWorkspace.java:770: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `java.lang.String[] JcrWorkspace.getAccessibleWorkspaceNames()` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  768.           for (Iterator<String> iter = names.iterator(); iter.hasNext();) {
  769.               try {
  770. >                 session.checkWorkspacePermission(iter.next(), ModeShapePermissions.READ);
  771.               } catch (AccessDeniedException ace) {
  772.                   iter.remove();

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:620: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Iterator Property.iterator()` of un-annotated interface `org.modeshape.jcr.value.Property`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  618.           final NameFactory nameFactory = session(cache).nameFactory();
  619.           Set<Name> names = new HashSet<Name>();
  620. >         for (Object value : prop) {
  621.               Name name = nameFactory.create(value);
  622.               names.add(name);

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:139: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Object Document.get(String)` of un-annotated interface `org.infinispan.schematic.document.Document`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  137.           if (additionalParents == null) {
  138.               WorkspaceCache wsCache = workspaceCache(cache);
  139. >             Set<NodeKey> additionalParents = wsCache.translator().getAdditionalParentKeys(document(wsCache));
  140.               this.additionalParents = additionalParents.isEmpty() ? additionalParents : Collections.unmodifiableSet(additionalParents);
  141.           }

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:348: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  346.           // Get the additional parents on the persisted node ...
  347.           AbstractSessionCache session = session(cache);
  348. >         CachedNode raw = nodeInWorkspace(session);
  349.           Set<NodeKey> persisted = raw != null ? raw.getAdditionalParentKeys(cache) : null;
  350.   

src/main/java/org/modeshape/jcr/value/binary/CassandraBinaryStore.java:241: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Iterable CassandraBinaryStore.getAllBinaryKeys()` reads without synchronization from `this.session`. Potentially races with write in method `CassandraBinaryStore.start()`.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  239.       public Iterable<BinaryKey> getAllBinaryKeys() throws BinaryStoreException {
  240.           try {
  241. >             ResultSet rs = session.execute("SELECT cid from modeshape.binary WHERE usage=1;");
  242.               Iterator<Row> it = rs.iterator();
  243.               HashSet<BinaryKey> keys = new HashSet<BinaryKey>();

src/main/java/org/modeshape/jcr/value/binary/DatabaseBinaryStore.java:313: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Iterable DatabaseBinaryStore.getAllBinaryKeys()` indirectly reads without synchronization from `this.dataSource`. Potentially races with write in method `DatabaseBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  311.       @Override
  312.       public Iterable<BinaryKey> getAllBinaryKeys() throws BinaryStoreException {
  313. >         return dbCall(new DBCallable<Iterable<BinaryKey>>() {
  314.               @Override
  315.               public Iterable<BinaryKey> execute( Connection connection ) throws Exception {

src/main/java/org/modeshape/jcr/value/binary/MongodbBinaryStore.java:312: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Iterable MongodbBinaryStore.getAllBinaryKeys()` indirectly reads without synchronization from `this.db`. Potentially races with write in method `MongodbBinaryStore.start()`.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  310.       public Iterable<BinaryKey> getAllBinaryKeys() {
  311.           ArrayList<BinaryKey> list = new ArrayList<BinaryKey>();
  312. >         Set<String> keys = getStoredKeys(true);
  313.           for (String s : keys) {
  314.               list.add(new BinaryKey(s));

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:582: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `AdvancedCache Cache.getAdvancedCache()` of un-annotated interface `org.infinispan.Cache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  580.               }
  581.   
  582. >             PersistenceManager persistenceManager = metadataCache.getAdvancedCache().getComponentRegistry()
  583.                                                                    .getComponent(PersistenceManager.class);
  584.               if (persistenceManager != null) {

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:574: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Iterable InfinispanBinaryStore.getAllBinaryKeys()` reads without synchronization from `this.metadataCache`. Potentially races with write in method `InfinispanBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  572.   
  573.           try {
  574. >             for (String key : metadataCache.keySet()) {
  575.                   if (!isMetadataKey(key)) { continue; }
  576.                   Metadata metadata = metadataCache.get(key);

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:356: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReferences CachedNode.getChildReferences(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  354.       @Override
  355.       public NodeIterator getAllFrozenNodes() throws RepositoryException {
  356. >         return new FrozenNodeIterator(getAllVersions());
  357.       }
  358.   

src/main/java/org/modeshape/jcr/cache/document/SessionChildReferences.java:228: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Iterator ChildReferences.getAllKeys()` of un-annotated interface `org.modeshape.jcr.cache.ChildReferences`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  226.       @Override
  227.       public Iterator<NodeKey> getAllKeys() {
  228. >         Iterator<NodeKey> firstIter = persisted.getAllKeys();
  229.           final MutableChildReferences appended = this.appended;
  230.           Iterable<NodeKey> second = new Iterable<NodeKey>() {

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:361: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `NodeIterator JcrVersionHistoryNode.getAllLinearFrozenNodes()` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  359.       @Override
  360.       public NodeIterator getAllLinearFrozenNodes() throws RepositoryException {
  361. >         return new FrozenNodeIterator(getAllLinearVersions());
  362.       }
  363.   

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:372: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `VersionIterator JcrVersionHistoryNode.getAllLinearVersions()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  370.   
  371.           LinkedList<JcrVersionNode> versions = new LinkedList<JcrVersionNode>();
  372. >         JcrVersionNode baseVersion = existingNode.getBaseVersion();
  373.           while (baseVersion != null) {
  374.               versions.addFirst(baseVersion);

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:366: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `VersionIterator JcrVersionHistoryNode.getAllLinearVersions()` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  364.       @Override
  365.       public VersionIterator getAllLinearVersions() throws RepositoryException {
  366. >         AbstractJcrNode existingNode = session().getNonSystemNodeByIdentifier(getVersionableIdentifier());
  367.           if (existingNode == null) return getAllVersions();
  368.   

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:367: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReferences CachedNode.getChildReferences(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  365.       public VersionIterator getAllLinearVersions() throws RepositoryException {
  366.           AbstractJcrNode existingNode = session().getNonSystemNodeByIdentifier(getVersionableIdentifier());
  367. >         if (existingNode == null) return getAllVersions();
  368.   
  369.           assert existingNode.isNodeType(JcrMixLexicon.VERSIONABLE);

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:82: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReferences CachedNode.getChildReferences(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  80.       @Override
  81.       public VersionIterator getAllVersions() throws RepositoryException {
  82. >         return new JcrVersionIterator(getNodesInternal());
  83.       }
  84.   

src/main/java/org/modeshape/jcr/AbstractJcrItem.java:107: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `int Path.size()` of un-annotated interface `org.modeshape.jcr.value.Path`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  105.            * Next statement converts depth parameter from a relative depth to an absolute depth.
  106.            */
  107. >         depth = getDepth() - depth;
  108.   
  109.           if (depth < 0) {

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `int Path.size()` of un-annotated interface `org.modeshape.jcr.value.Path`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`.
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:101: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Version AbstractJcrNode.getBaseVersion()` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  99.    * The abstract base class for all {@link Node} implementations.
  100.    */
  101. > @ThreadSafe
  102.   abstract class AbstractJcrNode extends AbstractJcrItem implements Node {
  103.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3296: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `JcrVersionNode AbstractJcrNode.getBaseVersion()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3294.           NodeKey baseVersionKey = ((NodeKeyReference)getProperty(JcrLexicon.BASE_VERSION).getValue().value()).getNodeKey();
  3295.           try {
  3296. >             return (JcrVersionNode)session().node(baseVersionKey, null);
  3297.           } catch (NodeNotFoundInParentException | ItemNotFoundException e) {
  3298.               // this should only happen if multiple threads are performing non-atomic checkin/checkout flows on the same node

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3291: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `CachedNode SessionCache.getNode(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  3289.       public JcrVersionNode getBaseVersion() throws UnsupportedRepositoryOperationException, RepositoryException {
  3290.           checkSession();
  3291. >         if (!hasProperty(JcrLexicon.BASE_VERSION)) {
  3292.               throw new UnsupportedRepositoryOperationException(JcrI18n.requiresVersionable.text());
  3293.           }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3294: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `JcrVersionNode AbstractJcrNode.getBaseVersion()` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3292.               throw new UnsupportedRepositoryOperationException(JcrI18n.requiresVersionable.text());
  3293.           }
  3294. >         NodeKey baseVersionKey = ((NodeKeyReference)getProperty(JcrLexicon.BASE_VERSION).getValue().value()).getNodeKey();
  3295.           try {
  3296.               return (JcrVersionNode)session().node(baseVersionKey, null);

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `JcrVersionNode JcrSystemNode.getBaseVersion()` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:203: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `List InfinispanBinaryStore.getCaches()` reads without synchronization from `this.blobCache`. Potentially races with write in method `InfinispanBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  201.                   caches.add(metadataCache);
  202.               }
  203. >             if (blobCache != null) {
  204.                   caches.add(blobCache);
  205.               }

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:200: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `List InfinispanBinaryStore.getCaches()` reads without synchronization from `this.metadataCache`. Potentially races with write in method `InfinispanBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  198.           List<Cache<?, ?>> caches = new ArrayList<Cache<?, ?>>(2);
  199.           if (!dedicatedCacheContainer) {
  200. >             if (metadataCache != null) {
  201.                   caches.add(metadataCache);
  202.               }

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:299: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Set WritableSessionCache.getChangedNodeKeys()` reads with synchronization from `this.changedNodes`. Potentially races with unsynchronized write in method `WritableSessionCache.clearState()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  297.           try {
  298.               readLock.lock();
  299. >             return new HashSet<NodeKey>(changedNodes.keySet());
  300.           } finally {
  301.               readLock.unlock();

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:308: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Path CachedNode.getPath(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  306.       public Set<NodeKey> getChangedNodeKeysAtOrBelow( CachedNode srcNode ) {
  307.           CheckArg.isNotNull(srcNode, "srcNode");
  308. >         final Path sourcePath = srcNode.getPath(this);
  309.           WorkspaceCache workspaceCache = workspaceCache();
  310.   

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:335: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Set WritableSessionCache.getChangedNodeKeysAtOrBelow(CachedNode)` reads with synchronization from `this.changedNodes`. Potentially races with unsynchronized write in method `WritableSessionCache.clearState()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  333.           try {
  334.               readLock.lock();
  335. >             for (Map.Entry<NodeKey, SessionNode> entry : changedNodes.entrySet()) {
  336.                   SessionNode changedNodeThisSession = entry.getValue();
  337.                   NodeKey changedNodeKey = entry.getKey();

src/main/java/org/modeshape/jcr/clustering/ClusteringService.java:338: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `JChannel ClusteringService.getChannel()` reads without synchronization from `this.channel`. Potentially races with write in method `ClusteringService.restart()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  336.   
  337.       protected JChannel getChannel() {
  338. >         return channel;
  339.       }
  340.   

src/main/java/org/modeshape/jcr/cache/document/BucketedChildReferences.java:130: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `ChildReference BucketedChildReferences.getChild(NodeKey)` indirectly reads without synchronization from container `this.rangeBucketsById` via call to `get`. Potentially races with write in method `BucketedChildReferences.getChildCount(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  128.       @Override
  129.       public ChildReference getChild( NodeKey key ) {
  130. >         return getChild(key, NoContext.INSTANCE);
  131.       }
  132.   

src/main/java/org/modeshape/jcr/cache/document/BucketedChildReferences.java:138: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `ChildReference BucketedChildReferences.getChild(NodeKey,ChildReferences$Context)` indirectly reads without synchronization from container `this.rangeBucketsById` via call to `get`. Potentially races with write in method `BucketedChildReferences.getChildCount(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  136.           ChildReference ref = null;
  137.           for (BucketId bucketId : bucketIds) {
  138. >             Bucket bucket = loadBucket(bucketId);
  139.               ref = bucket != null ? bucket.childReferenceFor(key) : null;
  140.               if (ref != null) {

src/main/java/org/modeshape/jcr/cache/document/BucketedChildReferences.java:145: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReferences$Changes ChildReferences$Context.changes()` of un-annotated interface `org.modeshape.jcr.cache.ChildReferences$Context`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  143.           }
  144.           
  145. >         Changes changes = context != null ? context.changes() : null;
  146.           if (ref == null) {
  147.               // we don't have the node key locally, but we still need to check the changes

src/main/java/org/modeshape/jcr/cache/document/SessionChildReferences.java:148: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReference ChildReferences.getChild(NodeKey,ChildReferences$Context)` of un-annotated interface `org.modeshape.jcr.cache.ChildReferences`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  146.           // Note that we don't know the name of the child yet, so we'll have to come back
  147.           // to the persisted node after we know the name ...
  148. >         ChildReference ref = persisted.getChild(key, context);
  149.           if (ref == null) {
  150.               if (appended != null) {

src/main/java/org/modeshape/jcr/cache/document/BucketedChildReferences.java:99: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReferences$Changes ChildReferences$Context.changes()` of un-annotated interface `org.modeshape.jcr.cache.ChildReferences$Context`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  97.           }
  98.           Bucket bucket = bucketFor(name);
  99. >         if (context == null || context.changes() == null) {
  100.               // there are no additional changes
  101.               return bucket != null ? bucket.childReferenceFor(name) : null;

src/main/java/org/modeshape/jcr/cache/document/BucketedChildReferences.java:98: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `ChildReference BucketedChildReferences.getChild(Name,int,ChildReferences$Context)` indirectly reads without synchronization from container `this.rangeBucketsById` via call to `get`. Potentially races with write in method `BucketedChildReferences.getChildCount(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  96.               return null;
  97.           }
  98. >         Bucket bucket = bucketFor(name);
  99.           if (context == null || context.changes() == null) {
  100.               // there are no additional changes

src/main/java/org/modeshape/jcr/cache/document/SessionChildReferences.java:105: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReference ChildReferences.getChild(Name,int,ChildReferences$Context)` of un-annotated interface `org.modeshape.jcr.cache.ChildReferences`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  103.           if (changedChildren != null && !changedChildren.isEmpty()) context = new WithChanges(context, changedChildren);
  104.           // First look in the delegate references ...
  105. >         ChildReference ref = persisted.getChild(name, snsIndex, context);
  106.           if (ref == null) {
  107.               if (appended != null) {

src/main/java/org/modeshape/jcr/cache/document/BucketedChildReferences.java:88: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int BucketedChildReferences.getChildCount(Name)` indirectly reads without synchronization from container `this.rangeBucketsById` via call to `get`. Potentially races with write in method `BucketedChildReferences.getChildCount(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  86.       @Override
  87.       public int getChildCount( Name name ) {
  88. >         Bucket bucket = bucketFor(name);
  89.           return bucket != null ? bucket.childCount(name) : 0;
  90.       }

src/main/java/org/modeshape/jcr/cache/document/SessionChildReferences.java:70: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Iterator ChildReferences.iterator(Name)` of un-annotated interface `org.modeshape.jcr.cache.ChildReferences`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  68.           int appendedThenReorderedChildren = 0;
  69.   
  70. >         for (Iterator<ChildReference> childReferenceIterator = persisted.iterator(name); childReferenceIterator.hasNext(); ) {
  71.               ChildReference persistedChild = childReferenceIterator.next();
  72.               ++persistedChildrenCount;

src/main/java/org/modeshape/jcr/JcrNodeType.java:45: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Collection Multimap.values()` of un-annotated interface `org.modeshape.common.collection.Multimap`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  43.    * ModeShape implementation of JCR {@link NodeType}s.
  44.    */
  45. > @ThreadSafe
  46.   class JcrNodeType implements NodeType, Namespaced {
  47.   

src/main/java/org/modeshape/jcr/JcrNodeType.java:452: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Collection Multimap.values()` of un-annotated interface `org.modeshape.common.collection.Multimap`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  450.       public JcrNodeDefinition[] getChildNodeDefinitions() {
  451.           // Always have to make a copy to prevent changes ...
  452. >         Collection<JcrNodeDefinition> definitions = this.allDefinitions.allChildNodeDefinitions();
  453.           return definitions.toArray(new JcrNodeDefinition[definitions.size()]);
  454.       }

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:460: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `ChildReferences LazyCachedNode.getChildReferences(NodeCache)` indirectly mutates container `keysWithName` via call to `add` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  458.               // This is idempotent, so it's okay if another thread sneaks in here and recalculates the object before we do ...
  459.               WorkspaceCache wsCache = workspaceCache(cache);
  460. >             childReferences = wsCache.translator().getChildReferences(wsCache, document(wsCache));
  461.           }
  462.           return childReferences;

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:459: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `NodeCache NodeCache.unwrap()` of un-annotated interface `org.modeshape.jcr.cache.NodeCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  457.           if (childReferences == null) {
  458.               // This is idempotent, so it's okay if another thread sneaks in here and recalculates the object before we do ...
  459. >             WorkspaceCache wsCache = workspaceCache(cache);
  460.               childReferences = wsCache.translator().getChildReferences(wsCache, document(wsCache));
  461.           }

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1120: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1118.       @Override
  1119.       public ChildReferences getChildReferences( NodeCache cache ) {
  1120. >         boolean allowsSNS = allowsSNS(cache);
  1121.           if (isNew) {
  1122.               // Then this node was created in this session. Note that it is possible that there still may be a persisted node,

src/main/java/org/modeshape/jcr/value/binary/MongodbBinaryStore.java:185: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int MongodbBinaryStore.getChunkSize()` reads without synchronization from `this.chunkSize`. Potentially races with write in method `MongodbBinaryStore.setChunkSize(...)`.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  183.        */
  184.       public int getChunkSize() {
  185. >         return chunkSize;
  186.       }
  187.   

src/main/java/org/modeshape/jcr/Connectors.java:767: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Connector Connectors$Snapshot.getConnectorWithSourceKey(String)` reads without synchronization from container `this.sourceKeyToConnectorMap` via call to `get`. Potentially races with write in method `Connectors$Snapshot.shutdownConnectors()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  765.            */
  766.           public Connector getConnectorWithSourceKey( String sourceKey ) {
  767. >             return sourceKeyToConnectorMap.get(sourceKey);
  768.           }
  769.   

src/main/java/org/modeshape/jcr/Connectors.java:787: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Collection Connectors$Snapshot.getConnectors()` reads without synchronization from container `this.sourceKeyToConnectorMap` via call to `values`. Potentially races with write in method `Connectors$Snapshot.shutdownConnectors()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  785.            */
  786.           public Collection<Connector> getConnectors() {
  787. >             return Collections.unmodifiableCollection(sourceKeyToConnectorMap.values());
  788.           }
  789.   

src/main/java/org/modeshape/jcr/JcrVersionNode.java:33: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `VersionHistory JcrVersionNode.getContainingHistory()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  31.    * Convenience wrapper around a version {@link JcrNode node}.
  32.    */
  33. > class JcrVersionNode extends JcrSystemNode implements Version {
  34.   
  35.       private static final Version[] EMPTY_VERSION_ARRAY = new Version[0];

src/main/java/org/modeshape/jcr/JcrVersionNode.java:54: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `JcrVersionHistoryNode JcrVersionNode.getContainingHistory()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  52.       @Override
  53.       public JcrVersionHistoryNode getContainingHistory() throws RepositoryException {
  54. >         return getParent();
  55.       }
  56.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3025: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `String AbstractJcrNode.getCorrespondingNodePath(String)` indirectly writes to field `key.identifier` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3023.           checkSession();
  3024.           NamespaceRegistry namespaces = this.context().getNamespaceRegistry();
  3025. >         return correspondingNodePath(workspaceName).getString(namespaces);
  3026.       }
  3027.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `String JcrSystemNode.getCorrespondingNodePath(String)` indirectly writes to field `key.identifier` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/JcrVersionNode.java:59: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Calendar JcrVersionNode.getCreated()` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  57.       @Override
  58.       public Calendar getCreated() throws RepositoryException {
  59. >         return getProperty(JcrLexicon.CREATED).getDate();
  60.       }
  61.   

src/main/java/org/modeshape/jcr/JcrNodeType.java:493: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getString(NamespaceRegistry)` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  491.       @Override
  492.       public NodeTypeIterator getDeclaredSubtypes() {
  493. >         return new JcrNodeTypeIterator(nodeTypes().declaredSubtypesFor(this));
  494.       }
  495.   

src/main/java/org/modeshape/jcr/JcrNodeType.java:479: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getString(NamespaceRegistry)` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  477.   
  478.           for (JcrNodeType declaredSupertype : declaredSupertypes) {
  479. >             supertypeNames.add(declaredSupertype.getName());
  480.           }
  481.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2835: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean NodeTypes$ReusableNodeDefinitionSet.appliesTo(NodeTypes,Name,Set)` of un-annotated interface `org.modeshape.jcr.NodeTypes$ReusableNodeDefinitionSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  2833.       public NodeDefinition getDefinition() throws RepositoryException {
  2834.           checkSession();
  2835. >         return nodeDefinition();
  2836.       }
  2837.   

src/main/java/org/modeshape/jcr/JcrRootNode.java:27: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String JcrItemDefinition.getName()` of un-annotated interface `org.modeshape.jcr.JcrItemDefinition`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.AbstractJcrNode` is annotated `@ThreadSafe`.
  25.    * The {@link Node} implementation for the root node.
  26.    */
  27. > final class JcrRootNode extends AbstractJcrNode {
  28.   
  29.       private final String NAME_STR = "";

src/main/java/org/modeshape/jcr/JcrRootNode.java:50: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String JcrItemDefinition.getName()` of un-annotated interface `org.modeshape.jcr.JcrItemDefinition`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.AbstractJcrNode` is annotated `@ThreadSafe`.
  48.       @Override
  49.       public JcrNodeDefinition getDefinition() throws RepositoryException {
  50. >         return session.workspace().nodeTypeManager().getRootNodeDefinition();
  51.       }
  52.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean NodeTypes$ReusableNodeDefinitionSet.appliesTo(NodeTypes,Name,Set)` of un-annotated interface `org.modeshape.jcr.NodeTypes$ReusableNodeDefinitionSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`.
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrItem.java:123: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `int Path.size()` of un-annotated interface `org.modeshape.jcr.value.Path`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  121.       public int getDepth() throws RepositoryException {
  122.           checkSession();
  123. >         return path().size();
  124.       }
  125.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `int Path.size()` of un-annotated interface `org.modeshape.jcr.value.Path`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`.
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:338: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  336.           }
  337.           // make sure that this isn't a node which has been removed in the meantime
  338. >         if (wsCache.getNode(key) == null) {
  339.               throw new NodeNotFoundException(key);
  340.           }

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:332: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `int LazyCachedNode.getDepth(NodeCache)` indirectly writes to field `this.key.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  330.       public int getDepth( NodeCache cache ) throws NodeNotFoundException {
  331.           WorkspaceCache wsCache = workspaceCache(cache);
  332. >         CachedNode parent = parent(wsCache);
  333.           if (parent != null) {
  334.               // This is not the root, so get our parent's depth and add 1 ...

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:443: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  441.       public int getDepth( NodeCache cache ) throws NodeNotFoundException {
  442.           AbstractSessionCache session = session(cache);
  443. >         CachedNode parent = parent(session);
  444.           if (parent != null) {
  445.               // This is not the root, so get our parent's depth and add 1 ...

src/main/java/org/modeshape/jcr/JcrRepository.java:565: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String JcrRepository.getDescriptor(String)` indirectly reads without synchronization from container `this.descriptors` via call to `get`. Potentially races with write in method `JcrRepository.apply(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  563.       public String getDescriptor( String key ) {
  564.           if (key == null) return null;
  565. >         if (!isSingleValueDescriptor(key)) return null;
  566.   
  567.           JcrValue value = (JcrValue)descriptors.get(key);

src/main/java/org/modeshape/jcr/JcrRepository.java:611: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `java.lang.String[] JcrRepository.getDescriptorKeys()` reads without synchronization from container `this.descriptors` via call to `size`. Potentially races with write in method `JcrRepository.apply(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  609.       @Override
  610.       public String[] getDescriptorKeys() {
  611. >         return descriptors.keySet().toArray(new String[descriptors.size()]);
  612.       }
  613.   

src/main/java/org/modeshape/jcr/JcrRepository.java:145: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Value JcrRepository.getDescriptorValue(String)` indirectly reads without synchronization from container `this.descriptors` via call to `get`. Potentially races with write in method `JcrRepository.apply(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  143.    *
  144.    */
  145. > public class JcrRepository implements org.modeshape.jcr.api.Repository {
  146.   
  147.       /**

src/main/java/org/modeshape/jcr/JcrRepository.java:578: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `JcrValue JcrRepository.getDescriptorValue(String)` indirectly reads without synchronization from container `this.descriptors` via call to `get`. Potentially races with write in method `JcrRepository.apply(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  576.       public JcrValue getDescriptorValue( String key ) {
  577.           if (key == null) return null;
  578. >         if (!isSingleValueDescriptor(key)) return null;
  579.           return (JcrValue)descriptors.get(key);
  580.       }

src/main/java/org/modeshape/jcr/JcrRepository.java:145: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `javax.jcr.Value[] JcrRepository.getDescriptorValues(String)` indirectly reads without synchronization from container `this.descriptors` via call to `get`. Potentially races with write in method `JcrRepository.apply(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  143.    *
  144.    */
  145. > public class JcrRepository implements org.modeshape.jcr.api.Repository {
  146.   
  147.       /**

src/main/java/org/modeshape/jcr/JcrRepository.java:584: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `org.modeshape.jcr.JcrValue[] JcrRepository.getDescriptorValues(String)` reads without synchronization from container `this.descriptors` via call to `get`. Potentially races with write in method `JcrRepository.apply(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  582.       @Override
  583.       public JcrValue[] getDescriptorValues( String key ) {
  584. >         Object value = descriptors.get(key);
  585.           if (value instanceof JcrValue[]) {
  586.               // Make a defensive copy of the array; the elements are immutable ...

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1380: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1378.       public String getEtag( SessionCache cache ) {
  1379.           StringBuilder sb = new StringBuilder();
  1380. >         Iterator<Property> iter = getProperties(cache);
  1381.           while (iter.hasNext()) {
  1382.               Property prop = iter.next();

src/main/java/org/modeshape/jcr/JcrObservationManager.java:227: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String ChangeJournal.journalId()` of un-annotated interface `org.modeshape.jcr.journal.ChangeJournal`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  225.       @Override
  226.       public EventJournal getEventJournal() {
  227. >         return session.repository().journalId() != null ? new JcrEventJournal() : null;
  228.       }
  229.   

src/main/java/org/modeshape/jcr/JcrObservationManager.java:246: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String ChangeJournal.journalId()` of un-annotated interface `org.modeshape.jcr.journal.ChangeJournal`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  244.                                            String[] uuid,
  245.                                            String[] nodeTypeName ) {
  246. >         return session.repository().journalId() != null ? new JcrEventJournal(absPath, eventTypes, isDeep, nodeTypeName, uuid) : null;
  247.       }
  248.   

src/main/java/org/modeshape/jcr/value/binary/CassandraBinaryStore.java:108: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String CassandraBinaryStore.getExtractedText(BinaryValue)` indirectly reads without synchronization from `this.session`. Potentially races with write in method `CassandraBinaryStore.start()`.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  106.       public String getExtractedText( BinaryValue source ) throws BinaryStoreException {
  107.           try {
  108. >             checkContentExists(source);
  109.               ResultSet rs = session.execute("SELECT ext_text FROM modeshape.binary WHERE cid = '" + source.getKey() + "';");
  110.               Row row = rs.one();

src/main/java/org/modeshape/jcr/value/binary/DatabaseBinaryStore.java:286: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String DatabaseBinaryStore.getExtractedText(BinaryValue)` indirectly reads without synchronization from `this.dataSource`. Potentially races with write in method `DatabaseBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  284.       @Override
  285.       public String getExtractedText( final BinaryValue source ) throws BinaryStoreException {
  286. >         return dbCall(new DBCallable<String>() {
  287.               @SuppressWarnings( "synthetic-access" )
  288.               @Override

src/main/java/org/modeshape/jcr/value/binary/FileSystemBinaryStore.java:539: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `BinaryKey BinaryValue.getKey()` of un-annotated interface `org.modeshape.jcr.value.BinaryValue`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  537.       @Override
  538.       public String getExtractedText( BinaryValue source ) throws BinaryStoreException {
  539. >         if (!binaryValueExists(source)) {
  540.               throw new BinaryStoreException(JcrI18n.unableToFindBinaryValue.text(source.getKey(), directory));
  541.           }

src/main/java/org/modeshape/jcr/value/binary/MongodbBinaryStore.java:302: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String MongodbBinaryStore.getExtractedText(BinaryValue)` reads without synchronization from `this.db`. Potentially races with write in method `MongodbBinaryStore.start()`.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  300.       @Override
  301.       public String getExtractedText( BinaryValue source ) throws BinaryStoreException {
  302. >         if (!db.collectionExists(source.getKey().toString())) {
  303.               throw new BinaryStoreException(JcrI18n.unableToFindBinaryValue.text(source.getKey(), db.getName()));
  304.           }

src/main/java/org/modeshape/jcr/value/binary/MongodbBinaryStore.java:306: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Object DBObject.get(String)` of un-annotated interface `com.mongodb.DBObject`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`.
  304.           }
  305.           DBCollection content = db.getCollection(source.getKey().toString());
  306. >         return (String)getAttribute(content, FIELD_EXTRACTED_TEXT);
  307.       }
  308.   

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:522: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String InfinispanBinaryStore.getExtractedText(BinaryValue)` reads without synchronization from `this.metadataCache`. Potentially races with write in method `InfinispanBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  520.           final BinaryKey key = binary.getKey();
  521.           final String metadataKeyStr = metadataKeyFrom(key);
  522. >         Metadata metadata = metadataCache.get(metadataKeyStr);
  523.           if (metadata == null) {
  524.               String msg = JcrI18n.unableToFindBinaryValueInCache.text(key, metadataCache.getName());

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:532: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String InfinispanBinaryStore.getExtractedText(BinaryValue)` reads without synchronization from `this.blobCache`. Potentially races with write in method `InfinispanBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  530.           try {
  531.               final String textKey = textKeyFrom(key);
  532. >             return IoUtil.read(new ChunkInputStream(blobCache, textKey, metadata.getChunkSize(), metadata.getLength()), "UTF-8");
  533.           } catch (IOException ex) {
  534.               logger.debug(ex, "Error during read of extracted text for {0}", key);

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:520: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `BinaryKey BinaryValue.getKey()` of un-annotated interface `org.modeshape.jcr.value.BinaryValue`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  518.       @Override
  519.       public String getExtractedText( BinaryValue binary ) throws BinaryStoreException {
  520. >         final BinaryKey key = binary.getKey();
  521.           final String metadataKeyStr = metadataKeyFrom(key);
  522.           Metadata metadata = metadataCache.get(metadataKeyStr);

src/main/java/org/modeshape/jcr/JcrWorkspace.java:955: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `FederationManager JcrWorkspace.getFederationManager()` indirectly reads without synchronization from `this.federationManager`. Potentially races with write in method `JcrWorkspace.getFederationManager()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  953.       public FederationManager getFederationManager() throws RepositoryException {
  954.           session.checkLive();
  955. >         return federationManager();
  956.       }
  957.   

src/main/java/org/modeshape/jcr/JcrVersionNode.java:33: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Node JcrVersionNode.getFrozenNode()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  31.    * Convenience wrapper around a version {@link JcrNode node}.
  32.    */
  33. > class JcrVersionNode extends JcrSystemNode implements Version {
  34.   
  35.       private static final Version[] EMPTY_VERSION_ARRAY = new Version[0];

src/main/java/org/modeshape/jcr/JcrVersionNode.java:72: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrNode JcrVersionNode.getFrozenNode()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  70.       @Override
  71.       public AbstractJcrNode getFrozenNode() throws RepositoryException {
  72. >         return childNode(JcrLexicon.FROZEN_NODE, Type.SYSTEM);
  73.       }
  74.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:275: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `NodeKey SessionCache.getRootKey()` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  273.       @Override
  274.       public final String getIdentifier() {
  275. >         return session().nodeIdentifier(key());
  276.       }
  277.   

src/main/java/org/modeshape/jcr/JcrWorkspace.java:713: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean NodeTypes$ReusableNodeDefinitionSet.appliesTo(NodeTypes,Name,Set)` of un-annotated interface `org.modeshape.jcr.NodeTypes$ReusableNodeDefinitionSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  711.           // Find the parent path ...
  712.           AbstractJcrNode parent = session.getNode(parentAbsPath);
  713. >         if (!parent.isCheckedOut()) {
  714.               throw new VersionException(JcrI18n.nodeIsCheckedIn.text(parent.getPath()));
  715.           }

src/main/java/org/modeshape/jcr/JcrWorkspace.java:712: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `ContentHandler JcrWorkspace.getImportContentHandler(String,int)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  710.   
  711.           // Find the parent path ...
  712. >         AbstractJcrNode parent = session.getNode(parentAbsPath);
  713.           if (!parent.isCheckedOut()) {
  714.               throw new VersionException(JcrI18n.nodeIsCheckedIn.text(parent.getPath()));

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2142: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `int Path$Segment.getIndex()` of un-annotated interface `org.modeshape.jcr.value.Path$Segment`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  2140.       @Override
  2141.       public int getIndex() throws RepositoryException {
  2142. >         return node().getSegment(sessionCache()).getIndex();
  2143.       }
  2144.   

src/main/java/org/modeshape/jcr/JcrNode.java:56: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `int Path$Segment.getIndex()` of un-annotated interface `org.modeshape.jcr.value.Path$Segment`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  54.       @Override
  55.       public int getIndex() throws RepositoryException {
  56. >         return segment().getIndex();
  57.       }
  58.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `int Path$Segment.getIndex()` of un-annotated interface `org.modeshape.jcr.value.Path$Segment`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`.
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/spi/index/provider/IndexProvider.java:511: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Index IndexProvider.getIndex(String,String)` reads without synchronization from container `this.providedIndexesByWorkspaceNameByIndexName` via call to `get`. Potentially races with write in method `IndexProvider.notify(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  509.           logger().trace("Looking for index '{0}' in '{1}' provider for query in workspace '{2}'", indexName, getName(),
  510.                          workspaceName);
  511. >         Map<String, AtomicIndex> byWorkspaceNames = providedIndexesByWorkspaceNameByIndexName.get(indexName);
  512.           return byWorkspaceNames == null ? null : byWorkspaceNames.get(workspaceName);
  513.       }

src/main/java/org/modeshape/jcr/RepositoryIndexManager.java:392: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void IndexProvider$ManagedIndexOperation.apply(String,ManagedIndex,IndexDefinition)` of un-annotated interface `org.modeshape.jcr.spi.index.provider.IndexProvider$ManagedIndexOperation`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  390.               return result;
  391.           }
  392. >         provider.onEachIndexInWorkspace(workspaceName, new IndexProvider.ManagedIndexOperation() {
  393.               @Override
  394.               public void apply( String workspaceName, ManagedIndex index, IndexDefinition defn ) {

src/main/java/org/modeshape/jcr/RepositoryIndexManager.java:356: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `IndexManager$IndexStatus ManagedIndex.getStatus()` of un-annotated interface `org.modeshape.jcr.spi.index.provider.ManagedIndex`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  354.           }
  355.           ManagedIndex managedIndex = provider.getManagedIndex(indexName, workspaceName);
  356. >         return managedIndex != null ? managedIndex.getStatus() : IndexStatus.NON_EXISTENT;
  357.       }
  358.   

src/main/java/org/modeshape/jcr/RepositoryIndexManager.java:295: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean IndexWriter.canBeSkipped()` of un-annotated interface `org.modeshape.jcr.spi.index.IndexWriter`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  293.               }
  294.           }
  295. >         return CompositeIndexWriter.create(reindexProviders);
  296.       }
  297.   

src/main/java/org/modeshape/jcr/spi/index/provider/IndexProvider.java:553: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Iterable IndexProvider.getIndexes(String)` reads without synchronization from container `this.providedIndexesByIndexNameByWorkspaceName` via call to `get`. Potentially races with write in method `IndexProvider.notify(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  551.        */
  552.       protected final Iterable<ManagedIndex> getIndexes( String workspaceName ) {
  553. >         final Map<String, AtomicIndex> byIndexName = providedIndexesByIndexNameByWorkspaceName.get(workspaceName);
  554.           if (byIndexName == null) return Collections.emptySet();
  555.           return DelegateIterable.around(byIndexName.values(), new Function<AtomicIndex, ManagedIndex>() {

src/main/java/org/modeshape/jcr/RepositoryIndexManager.java:370: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void IndexProvider$ManagedIndexOperation.apply(String,ManagedIndex,IndexDefinition)` of un-annotated interface `org.modeshape.jcr.spi.index.provider.IndexProvider$ManagedIndexOperation`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  368.               return result;
  369.           }
  370. >         provider.onEachIndexInWorkspace(workspaceName, new IndexProvider.ManagedIndexOperation() {
  371.               @Override
  372.               public void apply( String workspaceName, ManagedIndex index, IndexDefinition defn ) {

src/main/java/org/modeshape/jcr/value/binary/CassandraBinaryStore.java:171: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `InputStream CassandraBinaryStore.getInputStream(BinaryKey)` reads without synchronization from `this.session`. Potentially races with write in method `CassandraBinaryStore.start()`.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  169.       public InputStream getInputStream( BinaryKey key ) throws BinaryStoreException {
  170.           try {
  171. >             ResultSet rs = session.execute("SELECT payload FROM modeshape.binary WHERE cid='" + key.toString() + "'");
  172.               Row row = rs.one();
  173.               if (row == null) {

src/main/java/org/modeshape/jcr/value/binary/DatabaseBinaryStore.java:209: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `InputStream DatabaseBinaryStore.getInputStream(BinaryKey)` indirectly reads without synchronization from `this.dataSource`. Potentially races with write in method `DatabaseBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  207.       @Override
  208.       public InputStream getInputStream( BinaryKey key ) throws BinaryStoreException {
  209. >         Connection connection = newConnection();
  210.           try {
  211.               InputStream inputStream = database.readContent(key, connection);

src/main/java/org/modeshape/jcr/value/binary/DatabaseBinaryStore.java:211: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `InputStream DatabaseBinaryStore.getInputStream(BinaryKey)` reads without synchronization from `this.database`. Potentially races with write in method `DatabaseBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  209.           Connection connection = newConnection();
  210.           try {
  211. >             InputStream inputStream = database.readContent(key, connection);
  212.               if (inputStream == null) {
  213.                   throw new BinaryStoreException(JcrI18n.unableToFindBinaryValue.text(key, database.getTableName()));

src/main/java/org/modeshape/jcr/value/binary/MongodbBinaryStore.java:230: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `InputStream MongodbBinaryStore.getInputStream(BinaryKey)` reads without synchronization from `this.db`. Potentially races with write in method `MongodbBinaryStore.start()`.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  228.       @Override
  229.       public InputStream getInputStream( BinaryKey key ) throws BinaryStoreException {
  230. >         if (!db.collectionExists(key.toString())) {
  231.               throw new BinaryStoreException(JcrI18n.unableToFindBinaryValue.text(key, db.getName()));
  232.           }

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:283: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `InputStream InfinispanBinaryStore.getInputStream(BinaryKey)` reads without synchronization from `this.metadataCache`. Potentially races with write in method `InfinispanBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  281.       @Override
  282.       public InputStream getInputStream( BinaryKey binaryKey ) throws BinaryStoreException {
  283. >         Metadata metadata = metadataCache.get(metadataKeyFrom(binaryKey));
  284.           if (metadata == null) {
  285.               throw new BinaryStoreException(JcrI18n.unableToFindBinaryValue.text(binaryKey,

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:291: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `InputStream InfinispanBinaryStore.getInputStream(BinaryKey)` reads without synchronization from `this.blobCache`. Potentially races with write in method `InfinispanBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  289.               return new ByteArrayInputStream(new byte[0]);
  290.           }
  291. >         return new ChunkInputStream(blobCache, dataKeyFrom(binaryKey), metadata.getChunkSize(), metadata.getLength());
  292.       }
  293.   

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:286: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Cache.getName()` of un-annotated interface `org.infinispan.Cache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  284.           if (metadata == null) {
  285.               throw new BinaryStoreException(JcrI18n.unableToFindBinaryValue.text(binaryKey,
  286. >                                                                                 "Infinispan cache " + metadataCache.getName()));
  287.           }
  288.           if (metadata.getLength() == 0) {

src/main/java/org/modeshape/jcr/query/parse/QueryParsers.java:142: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String QueryParser.getLanguage()` of un-annotated interface `org.modeshape.jcr.query.parse.QueryParser`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  140.           Set<String> result = new HashSet<String>();
  141.           for (QueryParser parser : parsers.values()) {
  142. >             result.add(parser.getLanguage());
  143.           }
  144.           return Collections.unmodifiableSet(result);

src/main/java/org/modeshape/jcr/JcrVersionNode.java:33: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Version JcrVersionNode.getLinearPredecessor()` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  31.    * Convenience wrapper around a version {@link JcrNode node}.
  32.    */
  33. > class JcrVersionNode extends JcrSystemNode implements Version {
  34.   
  35.       private static final Version[] EMPTY_VERSION_ARRAY = new Version[0];

src/main/java/org/modeshape/jcr/JcrVersionNode.java:156: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `JcrVersionNode JcrVersionNode.getLinearPredecessor()` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  154.       @Override
  155.       public JcrVersionNode getLinearPredecessor() throws RepositoryException {
  156. >         return getFirstNodeForProperty(JcrLexicon.PREDECESSORS);
  157.       }
  158.   

src/main/java/org/modeshape/jcr/JcrVersionNode.java:33: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Version JcrVersionNode.getLinearSuccessor()` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  31.    * Convenience wrapper around a version {@link JcrNode node}.
  32.    */
  33. > class JcrVersionNode extends JcrSystemNode implements Version {
  34.   
  35.       private static final Version[] EMPTY_VERSION_ARRAY = new Version[0];

src/main/java/org/modeshape/jcr/JcrVersionNode.java:161: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `JcrVersionNode JcrVersionNode.getLinearSuccessor()` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  159.       @Override
  160.       public JcrVersionNode getLinearSuccessor() throws RepositoryException {
  161. >         return getFirstNodeForProperty(JcrLexicon.SUCCESSORS);
  162.       }
  163.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:295: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getLocalName()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  293.       @Override
  294.       public String getLocalName() throws RepositoryException {
  295. >         return name().getLocalName();
  296.       }
  297.   

src/main/java/org/modeshape/jcr/JcrNodeType.java:584: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getLocalName()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  582.       @Override
  583.       public String getLocalName() {
  584. >         return name.getLocalName();
  585.       }
  586.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getLocalName()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`.
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3317: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Lock AbstractJcrNode.getLock()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3315.           throws UnsupportedRepositoryOperationException, LockException, AccessDeniedException, RepositoryException {
  3316.           // Session's liveness will be checked in 'lockManager()' ...
  3317. >         return session.lockManager().getLock(this);
  3318.       }
  3319.   

src/main/java/org/modeshape/jcr/JcrLockManager.java:165: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Lock JcrLockManager.getLock(String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  163.       @Override
  164.       public Lock getLock( String absPath ) throws PathNotFoundException, LockException, AccessDeniedException, RepositoryException {
  165. >         ModeShapeLock lock = getLowestLockAlongPath(session.node(session.absolutePathFor(absPath)));
  166.           if (lock != null) return lock.lockFor(session);
  167.           throw new LockException(JcrI18n.notLocked.text(absPath));

src/main/java/org/modeshape/jcr/JcrLockManager.java:171: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  169.   
  170.       public Lock getLock( AbstractJcrNode node ) throws LockException, AccessDeniedException, RepositoryException {
  171. >         ModeShapeLock lock = getLowestLockAlongPath(node);
  172.           if (lock != null) return lock.lockFor(session);
  173.           throw new LockException(JcrI18n.notLocked.text(node.getPath()));

src/main/java/org/modeshape/jcr/JcrLockManager.java:172: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Lock JcrLockManager.getLock(AbstractJcrNode)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  170.       public Lock getLock( AbstractJcrNode node ) throws LockException, AccessDeniedException, RepositoryException {
  171.           ModeShapeLock lock = getLowestLockAlongPath(node);
  172. >         if (lock != null) return lock.lockFor(session);
  173.           throw new LockException(JcrI18n.notLocked.text(node.getPath()));
  174.       }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3322: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Lock AbstractJcrNode.getLockIfExists()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3320.       protected final Lock getLockIfExists()
  3321.           throws UnsupportedRepositoryOperationException, AccessDeniedException, RepositoryException {
  3322. >         return session.lockManager().getLockIfExists(this);
  3323.       }
  3324.   

src/main/java/org/modeshape/jcr/JcrLockManager.java:177: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  175.   
  176.       public Lock getLockIfExists( AbstractJcrNode node ) throws AccessDeniedException, RepositoryException {
  177. >         ModeShapeLock lock = getLowestLockAlongPath(node);
  178.           return lock == null ? null : lock.lockFor(session);
  179.       }

src/main/java/org/modeshape/jcr/JcrLockManager.java:178: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Lock JcrLockManager.getLockIfExists(AbstractJcrNode)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  176.       public Lock getLockIfExists( AbstractJcrNode node ) throws AccessDeniedException, RepositoryException {
  177.           ModeShapeLock lock = getLowestLockAlongPath(node);
  178. >         return lock == null ? null : lock.lockFor(session);
  179.       }
  180.   

src/main/java/org/modeshape/jcr/JcrWorkspace.java:72: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `LockManager JcrWorkspace.getLockManager()` indirectly reads without synchronization from `this.lockManager`. Potentially races with write in method `JcrWorkspace.lockManager()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  70.    * instantiates the various components when needed.
  71.    */
  72. > @ThreadSafe
  73.   class JcrWorkspace implements org.modeshape.jcr.api.Workspace {
  74.   

src/main/java/org/modeshape/jcr/JcrWorkspace.java:570: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `JcrLockManager JcrWorkspace.getLockManager()` indirectly reads without synchronization from `this.lockManager`. Potentially races with write in method `JcrWorkspace.lockManager()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  568.       public JcrLockManager getLockManager() throws UnsupportedRepositoryOperationException, RepositoryException {
  569.           session.checkLive();
  570. >         return lockManager();
  571.       }
  572.   

src/main/java/org/modeshape/jcr/JcrLockManager.java:205: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  203.                   if (sessionCache == cache) {
  204.                       cache = sessionCache.getWorkspace();
  205. >                     cachedNode = cache.getNode(key);
  206.                   }
  207.                   if (cachedNode == null) break;

src/main/java/org/modeshape/jcr/spi/index/provider/IndexProvider.java:526: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `ManagedIndex IndexProvider.getManagedIndex(String,String)` reads without synchronization from container `this.providedIndexesByWorkspaceNameByIndexName` via call to `get`. Potentially races with write in method `IndexProvider.notify(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  524.           logger().trace("Looking for managed index '{0}' in '{1}' provider in workspace '{2}'", indexName, getName(),
  525.                          workspaceName);
  526. >         Map<String, AtomicIndex> byWorkspaceNames = providedIndexesByWorkspaceNameByIndexName.get(indexName);
  527.           if (byWorkspaceNames == null) {
  528.               return null;

src/main/java/org/modeshape/jcr/value/binary/AbstractBinaryStore.java:166: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String MimeTypeDetector.mimeTypeOf(String,Binary)` of un-annotated interface `org.modeshape.jcr.mimetype.MimeTypeDetector`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  164.           }
  165.           
  166. >         String detectedMimeType = detector().mimeTypeOf(name, binary);
  167.           if (binary instanceof InMemoryBinaryValue) {
  168.               return detectedMimeType;

src/main/java/org/modeshape/jcr/value/binary/CompositeBinaryStore.java:354: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `BinaryKey BinaryValue.getKey()` of un-annotated interface `org.modeshape.jcr.value.BinaryValue`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.BinaryStore` is annotated `@ThreadSafe`.
  352.   
  353.               try {
  354. >                 if (bs.hasBinary(binary.getKey())) {
  355.                       return bs.getMimeType(binary, name);
  356.                   }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2298: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `javax.jcr.nodetype.NodeType[] AbstractJcrNode.getMixinNodeTypes()` indirectly writes to field `nodeType.key.sourceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2296.           List<NodeType> mixinNodeTypes = new LinkedList<NodeType>();
  2297.           for (Name mixinTypeName : node().getMixinTypes(sessionCache())) {
  2298. >             NodeType nodeType = nodeTypeManager.getNodeType(mixinTypeName);
  2299.               if (nodeType != null) mixinNodeTypes.add(nodeType);
  2300.           }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2297: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Set CachedNode.getMixinTypes(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  2295.           JcrNodeTypeManager nodeTypeManager = session().nodeTypeManager();
  2296.           List<NodeType> mixinNodeTypes = new LinkedList<NodeType>();
  2297. >         for (Name mixinTypeName : node().getMixinTypes(sessionCache())) {
  2298.               NodeType nodeType = nodeTypeManager.getNodeType(mixinTypeName);
  2299.               if (nodeType != null) mixinNodeTypes.add(nodeType);

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `javax.jcr.nodetype.NodeType[] JcrSystemNode.getMixinNodeTypes()` indirectly writes to field `nodeType.key.sourceKey` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2312: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Set CachedNode.getMixinTypes(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  2310.        */
  2311.       Set<Name> getMixinTypeNames() throws ItemNotFoundException, InvalidItemStateException {
  2312. >         return node().getMixinTypes(sessionCache());
  2313.       }
  2314.   

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:360: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Object Property.getFirstValue()` of un-annotated interface `org.modeshape.jcr.value.Property`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  358.           final NameFactory nameFactory = workspaceCache(cache).nameFactory();
  359.           if (prop.size() == 1) {
  360. >             Name name = nameFactory.create(prop.getFirstValue());
  361.               return Collections.singleton(name);
  362.           }

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:355: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Set LazyCachedNode.getMixinTypes(NodeCache)` indirectly mutates container `props` via call to `put` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  353.       @Override
  354.       public Set<Name> getMixinTypes( NodeCache cache ) {
  355. >         Property prop = getProperty(JcrLexicon.MIXIN_TYPES, cache);
  356.           if (prop == null || prop.size() == 0) return Collections.emptySet();
  357.   

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:508: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  506.       public Set<Name> getMixinTypes( NodeCache cache ) {
  507.           AbstractSessionCache session = session(cache);
  508. >         Property prop = getProperty(JcrLexicon.MIXIN_TYPES, session);
  509.           MixinChanges changes = mixinChanges(false);
  510.           if (prop == null || prop.size() == 0) {

src/main/java/org/modeshape/jcr/JcrNode.java:61: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Name Path$Segment.getName()` of un-annotated interface `org.modeshape.jcr.value.Path$Segment`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  59.       @Override
  60.       public String getName() throws RepositoryException {
  61. >         return segment().getName().getString(namespaces());
  62.       }
  63.   

src/main/java/org/modeshape/jcr/JcrNodeType.java:499: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getString(NamespaceRegistry)` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  497.       public String getName() {
  498.           // Translate the name to the correct prefix. Need to check the session to support url-remapping.
  499. >         return name.getString(context.getNamespaceRegistry());
  500.       }
  501.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Name Path$Segment.getName()` of un-annotated interface `org.modeshape.jcr.value.Path$Segment`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`.
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:274: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Name LazyCachedNode.getName(NodeCache)` indirectly writes to field `this.key.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  272.       @Override
  273.       public Name getName( NodeCache cache ) {
  274. >         return parentReferenceToSelf(workspaceCache(cache)).getName();
  275.       }
  276.   

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:408: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  406.       @Override
  407.       public Name getName( NodeCache cache ) {
  408. >         return getSegment(cache).getName();
  409.       }
  410.   

src/main/java/org/modeshape/jcr/JcrWorkspace.java:602: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `NamespaceRegistry JcrWorkspace.getNamespaceRegistry()` reads without synchronization from `this.workspaceRegistry`. Potentially races with write in method `JcrWorkspace.getNamespaceRegistry()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  600.       public javax.jcr.NamespaceRegistry getNamespaceRegistry() throws RepositoryException {
  601.           session.checkLive();
  602. >         if (workspaceRegistry == null) {
  603.               try {
  604.                   lock.lock();

src/main/java/org/modeshape/jcr/value/basic/NameValueFactory.java:331: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `NamespaceRegistry NamespaceRegistry$Holder.getNamespaceRegistry()` of un-annotated interface `org.modeshape.jcr.value.NamespaceRegistry$Holder`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactory` is annotated `@ThreadSafe`.
  329.       @Override
  330.       public NamespaceRegistry getNamespaceRegistry() {
  331. >         return namespaceRegistryHolder.getNamespaceRegistry();
  332.       }
  333.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:300: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Name CachedNode.getName(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  298.       @Override
  299.       public String getNamespaceURI() throws RepositoryException {
  300. >         return name().getNamespaceUri();
  301.       }
  302.   

src/main/java/org/modeshape/jcr/JcrNodeType.java:589: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getNamespaceUri()` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  587.       @Override
  588.       public String getNamespaceURI() {
  589. >         return name.getNamespaceUri();
  590.       }
  591.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Name CachedNode.getName(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`.
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:101: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Node AbstractJcrNode.getNode(String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  99.    * The abstract base class for all {@link Node} implementations.
  100.    */
  101. > @ThreadSafe
  102.   abstract class AbstractJcrNode extends AbstractJcrItem implements Node {
  103.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:807: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReference ChildReferences.getChild(Path$Segment)` of un-annotated interface `org.modeshape.jcr.cache.ChildReferences`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  805.   
  806.           // It's just a name, so look for a child ...
  807. >         ChildReference ref = node().getChildReferences(sessionCache()).getChild(segment);
  808.           if (ref == null) {
  809.               String msg = JcrI18n.childNotFoundUnderNode.text(readable(segment), location(), session.workspaceName());

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:770: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrNode AbstractJcrNode.getNode(String)` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  768.   
  769.           if (relativePath.equals("..")) {
  770. >             session().checkPermission(this.getParent(), ModeShapePermissions.READ);
  771.               return this.getParent();
  772.           }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:796: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrNode AbstractJcrNode.getNode(String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  794.               // We know it's a resolved relative path with more than one segment ...
  795.               if (path.size() > 1) {
  796. >                 AbstractJcrNode node = session().node(node(), path);
  797.                   session().checkPermission(node, ModeShapePermissions.READ);
  798.                   return node;

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrNode JcrSystemNode.getNode(String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:182: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  180.               return null;
  181.           }
  182. >         return sessionNode != null ? sessionNode : super.getNode(key);
  183.       }
  184.   

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:174: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `CachedNode WritableSessionCache.getNode(NodeKey)` reads with synchronization from `this.changedNodes`. Potentially races with unsynchronized write in method `WritableSessionCache.clearState()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  172.           try {
  173.               lock.lock();
  174. >             sessionNode = changedNodes.get(key);
  175.           } finally {
  176.               lock.unlock();

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:830: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrNode AbstractJcrNode.getNode(Name)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  828.               throw new PathNotFoundException(msg);
  829.           }
  830. >         return session().node(ref.getKey(), null, key());
  831.       }
  832.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:825: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReference ChildReferences.getChild(Name)` of un-annotated interface `org.modeshape.jcr.cache.ChildReferences`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  823.       AbstractJcrNode getNode( Name childName ) throws PathNotFoundException, RepositoryException {
  824.           // It's just a name, so look for a child ...
  825. >         ChildReference ref = node().getChildReferences(sessionCache()).getChild(childName);
  826.           if (ref == null) {
  827.               String msg = JcrI18n.childNotFoundUnderNode.text(readable(childName), location(), session.workspaceName());

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:836: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrNode AbstractJcrNode.getNodeIfExists(Name)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  834.           // It's just a name, so look for a child ...
  835.           ChildReference ref = node().getChildReferences(sessionCache()).getChild(childName);
  836. >         return ref != null ? session().node(ref.getKey(), null, key()) : null;
  837.       }
  838.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:835: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReference ChildReferences.getChild(Name)` of un-annotated interface `org.modeshape.jcr.cache.ChildReferences`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  833.       AbstractJcrNode getNodeIfExists( Name childName ) throws RepositoryException {
  834.           // It's just a name, so look for a child ...
  835. >         ChildReference ref = node().getChildReferences(sessionCache()).getChild(childName);
  836.           return ref != null ? session().node(ref.getKey(), null, key()) : null;
  837.       }

src/main/java/org/modeshape/jcr/JcrWorkspace.java:72: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `NodeTypeManager JcrWorkspace.getNodeTypeManager()` indirectly reads without synchronization from `this.nodeTypeManager`. Potentially races with write in method `JcrWorkspace.getNodeTypeManager()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  70.    * instantiates the various components when needed.
  71.    */
  72. > @ThreadSafe
  73.   class JcrWorkspace implements org.modeshape.jcr.api.Workspace {
  74.   

src/main/java/org/modeshape/jcr/JcrWorkspace.java:624: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `JcrNodeTypeManager JcrWorkspace.getNodeTypeManager()` indirectly reads without synchronization from `this.nodeTypeManager`. Potentially races with write in method `JcrWorkspace.getNodeTypeManager()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  622.       public JcrNodeTypeManager getNodeTypeManager() throws RepositoryException {
  623.           session.checkLive();
  624. >         return nodeTypeManager();
  625.       }
  626.   

src/main/java/org/modeshape/jcr/JcrWorkspace.java:72: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `NodeTypeManager JcrWorkspace.getNodeTypeManager()` indirectly reads without synchronization from `this.nodeTypeManager`. Potentially races with write in method `JcrWorkspace.getNodeTypeManager()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  70.    * instantiates the various components when needed.
  71.    */
  72. > @ThreadSafe
  73.   class JcrWorkspace implements org.modeshape.jcr.api.Workspace {
  74.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:842: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReferences CachedNode.getChildReferences(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  840.       public NodeIterator getNodes() throws RepositoryException {
  841.           checkSession();
  842. >         ChildReferences childReferences = node().getChildReferences(sessionCache());
  843.           if (childReferences.isEmpty()) return JcrEmptyNodeIterator.INSTANCE;
  844.           // if we don't require permission checking, we should use the child references directly since it may have precomputed the size

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReferences CachedNode.getChildReferences(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`.
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:883: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReferences CachedNode.getChildReferences(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  881.               // This is a literal, so just look up by name ...
  882.               Name literal = nameFrom((String)patterns.get(0));
  883. >             iter = node().getChildReferences(sessionCache()).iterator(literal);
  884.           } else {
  885.               NamespaceRegistry registry = session.namespaces();

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReferences CachedNode.getChildReferences(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`.
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:861: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReferences CachedNode.getChildReferences(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  859.           checkSession();
  860.           if (namePattern.length() == 0) return JcrEmptyNodeIterator.INSTANCE;
  861. >         if ("*".equals(namePattern)) return getNodes();
  862.           return getNodes(patternStringToGlobArray(namePattern));
  863.       }

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReferences CachedNode.getChildReferences(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`.
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:851: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReferences CachedNode.getChildReferences(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  849.   
  850.       protected NodeIterator getNodesInternal() throws RepositoryException {
  851. >         ChildReferences childReferences = node().getChildReferences(sessionCache());
  852.           if (childReferences.isEmpty()) return JcrEmptyNodeIterator.INSTANCE;
  853.           return new JcrChildNodeIterator(new ChildNodeResolver(session, key(), false), childReferences);

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:900: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReferences CachedNode.getChildReferences(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  898.               // This is a literal, so just look up by name ...
  899.               Name literal = nameFrom((String)patterns.get(0));
  900. >             iter = node().getChildReferences(sessionCache()).iterator(literal);
  901.           } else {
  902.               NamespaceRegistry registry = session.namespaces();

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:869: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReferences CachedNode.getChildReferences(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  867.           checkSession();
  868.           if (namePattern.length() == 0) return JcrEmptyNodeIterator.INSTANCE;
  869. >         if ("*".equals(namePattern)) return getNodesInternal();
  870.           return getNodesInternal(patternStringToGlobArray(namePattern));
  871.       }

src/main/java/org/modeshape/jcr/JcrWorkspace.java:644: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `ObservationManager JcrWorkspace.getObservationManager()` indirectly reads without synchronization from `this.observationManager`. Potentially races with write in method `JcrWorkspace.getObservationManager()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  642.       public ObservationManager getObservationManager() throws UnsupportedRepositoryOperationException, RepositoryException {
  643.           session.checkLive();
  644. >         return observationManager();
  645.       }
  646.   

src/main/java/org/modeshape/jcr/JcrNode.java:36: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Node JcrNode.getParent()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  34.    * @see JcrRootNode
  35.    */
  36. > @ThreadSafe
  37.   class JcrNode extends AbstractJcrNode {
  38.   

src/main/java/org/modeshape/jcr/JcrNode.java:67: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `CachedNode SessionCache.getNode(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  65.       public AbstractJcrNode getParent() throws ItemNotFoundException, RepositoryException {
  66.           checkSession();
  67. >         NodeKey parentKey = node().getParentKey(sessionCache());
  68.           return session().node(parentKey, null);
  69.       }

src/main/java/org/modeshape/jcr/JcrNode.java:68: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrNode JcrNode.getParent()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  66.           checkSession();
  67.           NodeKey parentKey = node().getParentKey(sessionCache());
  68. >         return session().node(parentKey, null);
  69.       }
  70.   

src/main/java/org/modeshape/jcr/JcrSharedNode.java:45: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Node JcrSharedNode.getParent()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  43.    * @see JcrNode
  44.    */
  45. > @ThreadSafe
  46.   final class JcrSharedNode extends JcrNode {
  47.   

src/main/java/org/modeshape/jcr/JcrSharedNode.java:73: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrNode JcrSharedNode.getParent()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  71.       public AbstractJcrNode getParent() throws ItemNotFoundException, RepositoryException {
  72.           checkSession();
  73. >         return parent();
  74.       }
  75.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrNode JcrSystemNode.getParent()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/JcrVersionNode.java:33: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Node JcrVersionNode.getParent()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  31.    * Convenience wrapper around a version {@link JcrNode node}.
  32.    */
  33. > class JcrVersionNode extends JcrSystemNode implements Version {
  34.   
  35.       private static final Version[] EMPTY_VERSION_ARRAY = new Version[0];

src/main/java/org/modeshape/jcr/JcrVersionNode.java:33: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrNode JcrVersionNode.getParent()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  31.    * Convenience wrapper around a version {@link JcrNode node}.
  32.    */
  33. > class JcrVersionNode extends JcrSystemNode implements Version {
  34.   
  35.       private static final Version[] EMPTY_VERSION_ARRAY = new Version[0];

src/main/java/org/modeshape/jcr/JcrVersionNode.java:49: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `JcrVersionHistoryNode JcrVersionNode.getParent()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  47.       @Override
  48.       public JcrVersionHistoryNode getParent() throws ItemNotFoundException, RepositoryException {
  49. >         return (JcrVersionHistoryNode)super.getParent();
  50.       }
  51.   

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:124: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `NodeKey LazyCachedNode.getParentKey(NodeCache)` indirectly writes to field `this.key.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  122.               // This is idempotent, so it's okay if another thread sneaks in here and recalculates the object before we do ...
  123.               WorkspaceCache wsCache = workspaceCache(cache);
  124. >             parent = wsCache.translator().getParentKey(document(wsCache), wsCache.getWorkspaceKey(), key.getWorkspaceKey());
  125.           }
  126.           return parent;

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:123: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `NodeCache NodeCache.unwrap()` of un-annotated interface `org.modeshape.jcr.cache.NodeCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  121.           if (parent == null) {
  122.               // This is idempotent, so it's okay if another thread sneaks in here and recalculates the object before we do ...
  123. >             WorkspaceCache wsCache = workspaceCache(cache);
  124.               parent = wsCache.translator().getParentKey(document(wsCache), wsCache.getWorkspaceKey(), key.getWorkspaceKey());
  125.           }

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:317: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  315.               return newParent;
  316.           }
  317. >         CachedNode cachedNode = nodeInWorkspace(session(cache));
  318.           // if it is null, it means it has been removed in the meantime from the ws
  319.           return cachedNode != null ? cachedNode.getParentKey(cache) : null;

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:132: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `NodeKey LazyCachedNode.getParentKeyInAnyWorkspace(NodeCache)` indirectly writes to field `this.key.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  130.       public NodeKey getParentKeyInAnyWorkspace( NodeCache cache ) {
  131.           WorkspaceCache wsCache = workspaceCache(cache);
  132. >         return wsCache.translator().getParentKey(document(wsCache), key.getWorkspaceKey(), key.getWorkspaceKey());
  133.       }
  134.   

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:131: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `NodeCache NodeCache.unwrap()` of un-annotated interface `org.modeshape.jcr.cache.NodeCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  129.       @Override
  130.       public NodeKey getParentKeyInAnyWorkspace( NodeCache cache ) {
  131. >         WorkspaceCache wsCache = workspaceCache(cache);
  132.           return wsCache.translator().getParentKey(document(wsCache), key.getWorkspaceKey(), key.getWorkspaceKey());
  133.       }

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:327: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  325.               return newParent;
  326.           }
  327. >         CachedNode cachedNode = nodeInWorkspace(session(cache));
  328.           // if it is null, it means it has been removed in the meantime from the ws
  329.           return cachedNode != null ? cachedNode.getParentKeyInAnyWorkspace(cache) : null;

src/main/java/org/modeshape/jcr/JcrNode.java:74: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `CachedNode SessionCache.getNode(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  72.       public String getPath() throws RepositoryException {
  73.           // checkSession(); ideally we don't have to do this, because getting the path is a useful thing and is used in 'toString'
  74. >         return path().getString(namespaces());
  75.       }
  76.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `CachedNode SessionCache.getNode(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`.
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:302: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReference LazyCachedNode$ParentReferenceToSelf.childReferenceInParent()` of un-annotated interface `org.modeshape.jcr.cache.document.LazyCachedNode$ParentReferenceToSelf`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  300.           if (parent != null) {
  301.               Path parentPath = parent.getPath(wsCache);
  302. >             return wsCache.pathFactory().create(parentPath, getSegment(wsCache));
  303.           }
  304.           // check that the node hasn't been removed in the meantime

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:299: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Path LazyCachedNode.getPath(NodeCache)` indirectly writes to field `this.key.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  297.       public Path getPath( NodeCache cache ) {
  298.           WorkspaceCache wsCache = workspaceCache(cache);
  299. >         CachedNode parent = parent(wsCache);
  300.           if (parent != null) {
  301.               Path parentPath = parent.getPath(wsCache);

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:460: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  458.       public Path getPath( NodeCache cache ) {
  459.           AbstractSessionCache session = session(cache);
  460. >         CachedNode parent = parent(session);
  461.           if (parent != null) {
  462.               Path parentPath = parent.getPath(session);

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:316: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Path LazyCachedNode.getPath(PathCache)` indirectly writes to field `this.key.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  314.           NodeCache cache = pathCache.getCache();
  315.           WorkspaceCache wsCache = workspaceCache(cache);
  316. >         CachedNode parent = parent(wsCache);
  317.           if (parent != null) {
  318.               Path parentPath = pathCache.getPath(parent);

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:319: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReference LazyCachedNode$ParentReferenceToSelf.childReferenceInParent()` of un-annotated interface `org.modeshape.jcr.cache.document.LazyCachedNode$ParentReferenceToSelf`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  317.           if (parent != null) {
  318.               Path parentPath = pathCache.getPath(parent);
  319. >             return wsCache.pathFactory().create(parentPath, getSegment(wsCache));
  320.           }
  321.           // check that the node hasn't been removed in the meantime

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:318: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Path LazyCachedNode.getPath(PathCache)` indirectly mutates container `pathCache.paths` via call to `put` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  316.           CachedNode parent = parent(wsCache);
  317.           if (parent != null) {
  318. >             Path parentPath = pathCache.getPath(parent);
  319.               return wsCache.pathFactory().create(parentPath, getSegment(wsCache));
  320.           }

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:478: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  476.           NodeCache cache = pathCache.getCache();
  477.           AbstractSessionCache session = session(cache);
  478. >         CachedNode parent = parent(session);
  479.           if (parent != null) {
  480.               Path parentPath = pathCache.getPath(parent);

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:480: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Path SessionNode.getPath(PathCache)` indirectly mutates container `pathCache.paths` via call to `put` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  478.           CachedNode parent = parent(session);
  479.           if (parent != null) {
  480. >             Path parentPath = pathCache.getPath(parent);
  481.               return session.pathFactory().create(parentPath, getSegment(session, parent));
  482.           }

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:498: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Map LazyCachedNode.getPermissions(NodeCache)` indirectly mutates container `keysWithName` via call to `add` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  496.       @Override
  497.       public Map<String, Set<String>> getPermissions( NodeCache cache ) {
  498. >         if (!hasACL(cache)) {
  499.               return null;
  500.           }

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:508: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReferences CachedNode.getChildReferences(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  506.   
  507.               Map<String, Set<String>> permissions = new HashMap<>();
  508. >             ChildReferences permissionsReference = aclNode.getChildReferences(cache);
  509.               for (ChildReference permissionReference : permissionsReference) {
  510.                   CachedNode permission = cache.getNode(permissionReference);

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1488: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1486.       @Override
  1487.       public Map<String, Set<String>> getPermissions( NodeCache cache ) {
  1488. >         if (!hasACL(cache)) {
  1489.               return null;
  1490.           }

src/main/java/org/modeshape/jcr/JcrVersionNode.java:77: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `javax.jcr.version.Version[] JcrVersionNode.getPredecessors()` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  75.       @Override
  76.       public Version[] getPredecessors() throws RepositoryException {
  77. >         return getNodesForProperty(JcrLexicon.PREDECESSORS);
  78.       }
  79.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2104: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Item AbstractJcrNode.getPrimaryItem()` indirectly writes to field `nodeType.key.sourceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2102.           checkSession();
  2103.           // Get the primary item name from this node's type ...
  2104. >         NodeType primaryType = getPrimaryNodeType();
  2105.           String primaryItemNameString = primaryType.getPrimaryItemName();
  2106.           if (primaryItemNameString == null) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2114: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Item AbstractJcrNode.getPrimaryItem()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2112.               if (primaryItemPath.size() == 1 && !primaryItemPath.isAbsolute()) {
  2113.                   try {
  2114. >                     return session.node(node(), primaryItemPath);
  2115.                   } catch (PathNotFoundException e) {
  2116.                       // Must not be any child by that name, so now look for a property on the parent node ...

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2105: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getString(NamespaceRegistry)` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  2103.           // Get the primary item name from this node's type ...
  2104.           NodeType primaryType = getPrimaryNodeType();
  2105. >         String primaryItemNameString = primaryType.getPrimaryItemName();
  2106.           if (primaryItemNameString == null) {
  2107.               I18n msg = JcrI18n.noPrimaryItemNameDefinedOnPrimaryType;

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Item JcrSystemNode.getPrimaryItem()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/JcrNodeType.java:529: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getString(NamespaceRegistry)` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  527.   
  528.           // Translate the name to the correct prefix. Need to check the session to support url-remapping.
  529. >         return primaryItemName.getString(context.getNamespaceRegistry());
  530.       }
  531.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:101: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `NodeType AbstractJcrNode.getPrimaryNodeType()` indirectly writes to field `nodeType.key.sourceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  99.    * The abstract base class for all {@link Node} implementations.
  100.    */
  101. > @ThreadSafe
  102.   abstract class AbstractJcrNode extends AbstractJcrItem implements Node {
  103.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2278: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `JcrNodeType AbstractJcrNode.getPrimaryNodeType()` indirectly writes to field `nodeType.key.sourceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2276.       public JcrNodeType getPrimaryNodeType() throws RepositoryException {
  2277.           checkSession();
  2278. >         return session().nodeTypeManager().getNodeType(node().getPrimaryType(sessionCache()));
  2279.       }
  2280.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `JcrNodeType JcrSystemNode.getPrimaryNodeType()` indirectly writes to field `nodeType.key.sourceKey` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:347: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Name LazyCachedNode.getPrimaryType(NodeCache)` indirectly mutates container `props` via call to `put` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  345.       @Override
  346.       public Name getPrimaryType( NodeCache cache ) {
  347. >         Property prop = getProperty(JcrLexicon.PRIMARY_TYPE, cache);
  348.           assert prop != null;
  349.           WorkspaceCache wsCache = workspaceCache(cache);

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:350: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Object Property.getFirstValue()` of un-annotated interface `org.modeshape.jcr.value.Property`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  348.           assert prop != null;
  349.           WorkspaceCache wsCache = workspaceCache(cache);
  350. >         return wsCache.nameFactory().create(prop.getFirstValue());
  351.       }
  352.   

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:495: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  493.       public Name getPrimaryType( NodeCache cache ) {
  494.           AbstractSessionCache session = session(cache);
  495. >         Property prop = getProperty(JcrLexicon.PRIMARY_TYPE, session);
  496.           NameFactory nameFactory = session.nameFactory();
  497.           return prop != null ? nameFactory.create(prop.getFirstValue()) : nameFactory.create((Object)null);

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2289: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `CachedNode SessionCache.getNode(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  2287.        */
  2288.       Name getPrimaryTypeName() throws ItemNotFoundException, InvalidItemStateException {
  2289. >         return node().getPrimaryType(sessionCache());
  2290.       }
  2291.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2072: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `CachedNode SessionCache.getNode(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  2070.       public PropertyIterator getProperties() throws RepositoryException {
  2071.           checkSession();
  2072. >         Iterator<Property> iter = node().getProperties(sessionCache());
  2073.           return new JcrPropertyIterator(findJcrProperties(iter));
  2074.       }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2073: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `PropertyIterator AbstractJcrNode.getProperties()` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2071.           checkSession();
  2072.           Iterator<Property> iter = node().getProperties(sessionCache());
  2073. >         return new JcrPropertyIterator(findJcrProperties(iter));
  2074.       }
  2075.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `PropertyIterator JcrSystemNode.getProperties()` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2096: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `CachedNode SessionCache.getNode(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  2094.               return new JcrPropertyIterator(Collections.singletonList((javax.jcr.Property)prop));
  2095.           }
  2096. >         Iterator<Property> propIter = node().getProperties(patterns, sessionCache());
  2097.           return new JcrPropertyIterator(findJcrProperties(propIter));
  2098.       }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2097: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `PropertyIterator AbstractJcrNode.getProperties(java.lang.String[])` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2095.           }
  2096.           Iterator<Property> propIter = node().getProperties(patterns, sessionCache());
  2097. >         return new JcrPropertyIterator(findJcrProperties(propIter));
  2098.       }
  2099.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2092: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `PropertyIterator AbstractJcrNode.getProperties(java.lang.String[])` indirectly reads without synchronization from `definition.checker`. Potentially races with write in method `AbstractJcrNode.setProperty(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2090.               // This is a literal, so just look up by name ...
  2091.               Name literal = nameFrom((String)patterns.get(0));
  2092. >             AbstractJcrProperty prop = getProperty(literal);
  2093.               if (prop == null) return JcrEmptyPropertyIterator.INSTANCE;
  2094.               return new JcrPropertyIterator(Collections.singletonList((javax.jcr.Property)prop));

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `PropertyIterator JcrSystemNode.getProperties(java.lang.String[])` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2079: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `PropertyIterator AbstractJcrNode.getProperties(String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2077.       public PropertyIterator getProperties( String namePattern ) throws RepositoryException {
  2078.           if (namePattern.length() == 0) return JcrEmptyPropertyIterator.INSTANCE;
  2079. >         if ("*".equals(namePattern)) return getProperties();
  2080.           return getProperties(patternStringToGlobArray(namePattern));
  2081.       }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2080: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Object Property.getFirstValue()` of un-annotated interface `org.modeshape.jcr.value.Property`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  2078.           if (namePattern.length() == 0) return JcrEmptyPropertyIterator.INSTANCE;
  2079.           if ("*".equals(namePattern)) return getProperties();
  2080. >         return getProperties(patternStringToGlobArray(namePattern));
  2081.       }
  2082.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `PropertyIterator JcrSystemNode.getProperties(String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:447: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Iterable Document.fields()` of un-annotated interface `org.infinispan.schematic.document.Document`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  445.           WorkspaceCache wsCache = workspaceCache(cache);
  446.           final NamespaceRegistry registry = wsCache.context().getNamespaceRegistry();
  447. >         return new PatternIterator<Property>(getProperties(wsCache), namePatterns) {
  448.               @Override
  449.               protected String matchable( Property value ) {

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:804: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  802.           final AbstractSessionCache session = session(cache);
  803.           final NamespaceRegistry registry = session.context().getNamespaceRegistry();
  804. >         return new PatternIterator<Property>(getProperties(session), namePatterns) {
  805.               @Override
  806.               protected String matchable( Property value ) {

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:436: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Iterable Document.fields()` of un-annotated interface `org.infinispan.schematic.document.Document`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  434.           if (!propertiesFullyLoaded) {
  435.               WorkspaceCache wsCache = workspaceCache(cache);
  436. >             wsCache.translator().getProperties(document(wsCache), properties());
  437.               this.propertiesFullyLoaded = true;
  438.           }

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:778: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  776.       public Iterator<Property> getProperties( final NodeCache cache ) {
  777.           final AbstractSessionCache session = session(cache);
  778. >         final CachedNode raw = nodeInWorkspace(session);
  779.           final ConcurrentMap<Name, Property> changedProperties = this.changedProperties;
  780.           Iterable<Property> rawProps = raw == null ? null : new Iterable<Property>() {

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:416: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Iterable Document.fields()` of un-annotated interface `org.infinispan.schematic.document.Document`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  414.           if (!propertiesFullyLoaded) {
  415.               WorkspaceCache wsCache = workspaceCache(cache);
  416. >             wsCache.translator().getProperties(document(wsCache), properties());
  417.               this.propertiesFullyLoaded = true;
  418.           }

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:751: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  749.       public Properties getPropertiesByName( final NodeCache cache ) {
  750.           final AbstractSessionCache session = session(cache);
  751. >         final CachedNode raw = nodeInWorkspace(session);
  752.           final ConcurrentMap<Name, Property> changedProperties = this.changedProperties;
  753.           final ConcurrentMap<Name, Name> removedProperties = this.removedProperties;

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:101: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Property AbstractJcrNode.getProperty(String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  99.    * The abstract base class for all {@link Node} implementations.
  100.    */
  101. > @ThreadSafe
  102.   abstract class AbstractJcrNode extends AbstractJcrItem implements Node {
  103.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:331: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Path$Segment Path.getLastSegment()` of un-annotated interface `org.modeshape.jcr.value.Path`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  329.                   throw new PathNotFoundException(msg.text(relativePath, location(), workspaceName()));
  330.               }
  331. >             propertyName = path.getLastSegment().getName();
  332.           } else {
  333.               propertyName = nameFrom(relativePath);

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:336: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.getProperty(String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  334.           }
  335.           // It's just a name, so look for it directly ...
  336. >         AbstractJcrProperty result = getProperty(propertyName);
  337.           if (result != null) return result;
  338.           I18n msg = JcrI18n.pathNotFoundRelativeTo;

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:320: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.getProperty(String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  318.               if (path.size() > 1) {
  319.                   try {
  320. >                     AbstractJcrItem item = session.findItem(key, path);
  321.                       if (item instanceof AbstractJcrProperty) {
  322.                           return (AbstractJcrProperty)item;

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty JcrSystemNode.getProperty(String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:358: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Set CachedNode.getMixinTypes(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  356.               if (p != null) {
  357.                   Name primaryType = node.getPrimaryType(cache);
  358. >                 Set<Name> mixinTypes = node.getMixinTypes(cache);
  359.                   prop = createJcrProperty(p, primaryType, mixinTypes);
  360.                   if (prop != null) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:359: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.getProperty(Name)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  357.                   Name primaryType = node.getPrimaryType(cache);
  358.                   Set<Name> mixinTypes = node.getMixinTypes(cache);
  359. >                 prop = createJcrProperty(p, primaryType, mixinTypes);
  360.                   if (prop != null) {
  361.                       AbstractJcrProperty newJcrProperty = jcrProperties.putIfAbsent(propertyName, prop);

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:406: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Property LazyCachedNode.getProperty(Name,NodeCache)` mutates container `props` via call to `put` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  404.               property = wsCache.translator().getProperty(document(wsCache), name);
  405.               if (property != null) {
  406. >                 props.put(name, property);
  407.               }
  408.           }

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:401: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Property LazyCachedNode.getProperty(Name,NodeCache)` reads without synchronization from container `props` via call to `get`. Potentially races with write in method `LazyCachedNode.getProperty(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  399.                                    NodeCache cache ) {
  400.           Map<Name, Property> props = properties();
  401. >         Property property = props.get(name);
  402.           if (property == null && !propertiesFullyLoaded) {
  403.               WorkspaceCache wsCache = workspaceCache(cache);

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:404: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Object Document.get(String)` of un-annotated interface `org.infinispan.schematic.document.Document`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  402.           if (property == null && !propertiesFullyLoaded) {
  403.               WorkspaceCache wsCache = workspaceCache(cache);
  404. >             property = wsCache.translator().getProperty(document(wsCache), name);
  405.               if (property != null) {
  406.                   props.put(name, property);

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:740: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  738.           // Otherwise, delegate to the workspace node (if it exists) ...
  739.           AbstractSessionCache session = session(cache);
  740. >         CachedNode raw = nodeInWorkspace(session);
  741.           return raw != null ? raw.getProperty(name, session) : null;
  742.       }

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:375: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Iterable Document.fields()` of un-annotated interface `org.infinispan.schematic.document.Document`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  373.           if (propertiesFullyLoaded) return properties().size();
  374.           WorkspaceCache wsCache = workspaceCache(cache);
  375. >         return wsCache.translator().countProperties(document(wsCache));
  376.       }
  377.   

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:708: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  706.           // Delegate to the workspace node (if it exists) ...
  707.           AbstractSessionCache session = session(cache);
  708. >         CachedNode raw = nodeInWorkspace(session);
  709.           return raw != null ? count + raw.getPropertyCount(session) : count;
  710.       }

src/main/java/org/modeshape/jcr/JcrNodeType.java:45: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Collection Multimap.values()` of un-annotated interface `org.modeshape.common.collection.Multimap`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  43.    * ModeShape implementation of JCR {@link NodeType}s.
  44.    */
  45. > @ThreadSafe
  46.   class JcrNodeType implements NodeType, Namespaced {
  47.   

src/main/java/org/modeshape/jcr/JcrNodeType.java:459: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Collection Multimap.values()` of un-annotated interface `org.modeshape.common.collection.Multimap`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  457.       public JcrPropertyDefinition[] getPropertyDefinitions() {
  458.           // Always have to make a copy to prevent changes ...
  459. >         Collection<JcrPropertyDefinition> definitions = this.allDefinitions.allPropertyDefinitions();
  460.           return definitions.toArray(new JcrPropertyDefinition[definitions.size()]);
  461.       }

src/main/java/org/modeshape/jcr/JcrWorkspace.java:72: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `QueryManager JcrWorkspace.getQueryManager()` indirectly reads without synchronization from `this.queryManager`. Potentially races with write in method `JcrWorkspace.getQueryManager()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  70.    * instantiates the various components when needed.
  71.    */
  72. > @ThreadSafe
  73.   class JcrWorkspace implements org.modeshape.jcr.api.Workspace {
  74.   

src/main/java/org/modeshape/jcr/JcrWorkspace.java:588: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `JcrQueryManager JcrWorkspace.getQueryManager()` reads without synchronization from `this.queryManager`. Potentially races with write in method `JcrWorkspace.getQueryManager()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  586.       public JcrQueryManager getQueryManager() throws RepositoryException {
  587.           session.checkLive();
  588. >         if (this.queryManager == null) {
  589.               try {
  590.                   lock.lock();

src/main/java/org/modeshape/jcr/JcrWorkspace.java:72: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `QueryManager JcrWorkspace.getQueryManager()` indirectly reads without synchronization from `this.queryManager`. Potentially races with write in method `JcrWorkspace.getQueryManager()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  70.    * instantiates the various components when needed.
  71.    */
  72. > @ThreadSafe
  73.   class JcrWorkspace implements org.modeshape.jcr.api.Workspace {
  74.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2147: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `PropertyDefinition Property.getDefinition()` of un-annotated interface `javax.jcr.Property`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  2145.       @Override
  2146.       public final PropertyIterator getReferences() throws RepositoryException {
  2147. >         return getReferences(null);
  2148.       }
  2149.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2153: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `PropertyDefinition Property.getDefinition()` of un-annotated interface `javax.jcr.Property`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  2151.       public final PropertyIterator getReferences( String propertyName ) throws RepositoryException {
  2152.           checkSession();
  2153. >         return propertiesOnOtherNodesReferencingThis(propertyName, PropertyType.REFERENCE);
  2154.       }
  2155.   

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:477: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Document Document.getDocument(String)` of un-annotated interface `org.infinispan.schematic.document.Document`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  475.           // Get the referrers ...
  476.           WorkspaceCache wsCache = workspaceCache(cache);
  477. >         Map<NodeKey, Integer> strongCounts = wsCache.translator().getReferrerCounts(document(wsCache), ReferenceType.STRONG);
  478.           Map<NodeKey, Integer> weakCounts = wsCache.translator().getReferrerCounts(document(wsCache), ReferenceType.WEAK);
  479.           return ReferrerCounts.create(strongCounts, weakCounts);

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:653: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  651.           ReferrerChanges changes = referrerChanges(false);
  652.           // Check the persisted node ...
  653. >         CachedNode persisted = nodeInWorkspace(session);
  654.           if (persisted == null) {
  655.               if (changes == null) return null;

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:470: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Document Document.getDocument(String)` of un-annotated interface `org.infinispan.schematic.document.Document`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  468.           // Get the referrers ...
  469.           WorkspaceCache wsCache = workspaceCache(cache);
  470. >         return wsCache.translator().getReferrers(document(wsCache), type);
  471.       }
  472.   

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:633: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  631.           ReferrerChanges changes = referrerChanges(false);
  632.           // Check the persisted node ...
  633. >         CachedNode persisted = nodeInWorkspace(session);
  634.           if (persisted == null) {
  635.               if (changes == null) return Collections.emptySet();

src/main/java/org/modeshape/jcr/JcrObservationManager.java:180: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `EventListenerIterator JcrObservationManager.getRegisteredEventListeners()` indirectly reads without synchronization from `this.session.context`. Potentially races with write in method `JcrObservationManager.setUserData(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  178.       @Override
  179.       public EventListenerIterator getRegisteredEventListeners() throws RepositoryException {
  180. >         checkSession(); // make sure session is still active
  181.           return new JcrEventListenerIterator(Collections.unmodifiableSet(this.listeners));
  182.       }

src/main/java/org/modeshape/jcr/JcrWorkspace.java:682: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `JcrRepositoryManager JcrWorkspace.getRepositoryManager()` indirectly reads without synchronization from `this.repositoryManager`. Potentially races with write in method `JcrWorkspace.getRepositoryManager()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  680.       public JcrRepositoryManager getRepositoryManager() throws AccessDeniedException, RepositoryException {
  681.           session.checkLive();
  682. >         return repositoryManager();
  683.       }
  684.   

src/main/java/org/modeshape/jcr/JcrWorkspace.java:72: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `RepositoryManager JcrWorkspace.getRepositoryManager()` indirectly reads without synchronization from `this.repositoryManager`. Potentially races with write in method `JcrWorkspace.getRepositoryManager()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  70.    * instantiates the various components when needed.
  71.    */
  72. > @ThreadSafe
  73.   class JcrWorkspace implements org.modeshape.jcr.api.Workspace {
  74.   

src/main/java/org/modeshape/jcr/JcrRepositoryManager.java:53: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `JcrRepositoryMonitor JcrRepositoryManager.getRepositoryMonitor()` indirectly reads without synchronization from `this.monitor`. Potentially races with write in method `JcrRepositoryManager.repositoryMonitor()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  51.       public JcrRepositoryMonitor getRepositoryMonitor() throws RepositoryException {
  52.           session().checkLive();
  53. >         return repositoryMonitor();
  54.       }
  55.   

src/main/java/org/modeshape/jcr/JcrRepositoryManager.java:28: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `RepositoryMonitor JcrRepositoryManager.getRepositoryMonitor()` indirectly reads without synchronization from `this.monitor`. Potentially races with write in method `JcrRepositoryManager.repositoryMonitor()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  26.   import org.modeshape.jcr.value.Path;
  27.   
  28. > public class JcrRepositoryManager implements RepositoryManager {
  29.       private final Lock lock = new ReentrantLock();
  30.       private final JcrWorkspace workspace;

src/main/java/org/modeshape/jcr/JcrRepositoriesContainer.java:104: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String NamedRepository.getName()` of un-annotated interface `org.modeshape.jcr.api.NamedRepository`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  102.   
  103.           if (repositoryURL.toLowerCase().startsWith(JNDI_PROTOCOL)) {
  104. >             Set<String> jndiRepositories = new JNDIRepositoryLookup().repositoryNames(parameters, repositoryURL);
  105.               repositoryNames.addAll(jndiRepositories);
  106.           } else {

src/main/java/org/modeshape/jcr/RepositoryNodeTypeManager.java:289: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `NodeTypeSchemata RepositoryNodeTypeManager.getRepositorySchemata()` indirectly writes to field `mutableTable.extraColumns` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  287.           if (schemata != null) return schemata;
  288.           // This is idempotent, so it's okay not to lock ...
  289. >         schemata = new NodeTypeSchemata(context, nodeTypesCache, includeColumnsForInheritedProperties,
  290.                                           includePseudoColumnsInSelectStar);
  291.           return schemata;

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:55: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Version JcrVersionHistoryNode.getRootVersion()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  53.    * Convenience wrapper around a version history {@link JcrNode node}.
  54.    */
  55. > @ThreadSafe
  56.   final class JcrVersionHistoryNode extends JcrSystemNode implements VersionHistory {
  57.   

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:87: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `JcrVersionNode JcrVersionHistoryNode.getRootVersion()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  85.       @Override
  86.       public JcrVersionNode getRootVersion() throws RepositoryException {
  87. >         return (JcrVersionNode)childNode(JcrLexicon.ROOT_VERSION, Type.VERSION);
  88.       }
  89.   

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:279: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Path$Segment LazyCachedNode.getSegment(NodeCache)` indirectly writes to field `this.key.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  277.       @Override
  278.       public Segment getSegment( NodeCache cache ) {
  279. >         return parentReferenceToSelf(workspaceCache(cache)).getSegment();
  280.       }
  281.   

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:414: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  412.       public Segment getSegment( NodeCache cache ) {
  413.           AbstractSessionCache session = session(cache);
  414. >         CachedNode parent = parent(session);
  415.           return getSegment(cache, parent);
  416.       }

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:429: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReference ChildReferences.getChild(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.ChildReferences`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  427.                                           CachedNode parent ) {
  428.           if (parent != null) {
  429. >             ChildReference ref = parent.getChildReferences(cache).getChild(key);
  430.               if (ref == null) {
  431.                   // This node doesn't exist in the parent

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:293: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Path$Segment LazyCachedNode.getSegment(WorkspaceCache)` indirectly writes to field `this.key.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  291.        */
  292.       protected Segment getSegment( WorkspaceCache cache ) {
  293. >         return parentReferenceToSelf(cache).getSegment();
  294.       }
  295.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3053: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Set CachedNode.getMixinTypes(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  3051.       @Override
  3052.       public NodeIterator getSharedSet() throws RepositoryException {
  3053. >         if (isShareable()) {
  3054.               // Find the nodes that make up this shared set ...
  3055.               return sharedSet().getSharedNodes();

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3055: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `NodeIterator AbstractJcrNode.getSharedSet()` indirectly writes to field `parentKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3053.           if (isShareable()) {
  3054.               // Find the nodes that make up this shared set ...
  3055. >             return sharedSet().getSharedNodes();
  3056.           }
  3057.           // Otherwise, the shared set is just this node ...

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `NodeIterator JcrSystemNode.getSharedSet()` indirectly writes to field `parentKey.workspaceKey` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/Connectors.java:777: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String Connectors$Snapshot.getSourceNameAtKey(String)` reads without synchronization from container `this.sourceKeyToConnectorMap` via call to `get`. Potentially races with write in method `Connectors$Snapshot.shutdownConnectors()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  775.            */
  776.           public String getSourceNameAtKey( String sourceKey ) {
  777. >             Connector connector = sourceKeyToConnectorMap.get(sourceKey);
  778.               return connector != null ? connector.getSourceName() : null;
  779.           }

src/main/java/org/modeshape/jcr/value/binary/CassandraBinaryStore.java:65: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String CassandraBinaryStore.getStoredMimeType(BinaryValue)` indirectly reads without synchronization from `this.session`. Potentially races with write in method `CassandraBinaryStore.start()`.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  63.       protected String getStoredMimeType( BinaryValue source ) throws BinaryStoreException {
  64.           try {
  65. >             checkContentExists(source);
  66.               ResultSet rs = session.execute("SELECT mime_type FROM modeshape.binary WHERE cid = '" + source.getKey() + "';");
  67.               Row row = rs.one();

src/main/java/org/modeshape/jcr/value/binary/DatabaseBinaryStore.java:260: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String DatabaseBinaryStore.getStoredMimeType(BinaryValue)` indirectly reads without synchronization from `this.dataSource`. Potentially races with write in method `DatabaseBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  258.       @Override
  259.       protected String getStoredMimeType( final BinaryValue source ) throws BinaryStoreException {
  260. >         return dbCall(new DBCallable<String>() {
  261.               @Override
  262.               public String execute( Connection connection ) throws Exception {

src/main/java/org/modeshape/jcr/value/binary/FileSystemBinaryStore.java:591: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `BinaryKey BinaryValue.getKey()` of un-annotated interface `org.modeshape.jcr.value.BinaryValue`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  589.       @Override
  590.       protected String getStoredMimeType( BinaryValue binaryValue ) throws BinaryStoreException {
  591. >         if (!binaryValueExists(binaryValue)) {
  592.               throw new BinaryStoreException(JcrI18n.unableToFindBinaryValue.text(binaryValue.getKey(), directory));
  593.           }

src/main/java/org/modeshape/jcr/value/binary/MongodbBinaryStore.java:283: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String MongodbBinaryStore.getStoredMimeType(BinaryValue)` reads without synchronization from `this.db`. Potentially races with write in method `MongodbBinaryStore.start()`.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  281.       @Override
  282.       protected String getStoredMimeType( BinaryValue source ) throws BinaryStoreException {
  283. >         if (!db.collectionExists(source.getKey().toString())) {
  284.               throw new BinaryStoreException(JcrI18n.unableToFindBinaryValue.text(source.getKey(), db.getName()));
  285.           }

src/main/java/org/modeshape/jcr/value/binary/MongodbBinaryStore.java:287: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Object DBObject.get(String)` of un-annotated interface `com.mongodb.DBObject`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`.
  285.           }
  286.           DBCollection content = db.getCollection(source.getKey().toString());
  287. >         return (String)getAttribute(content, FIELD_MIME_TYPE);
  288.       }
  289.   

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:487: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `BinaryKey BinaryValue.getKey()` of un-annotated interface `org.modeshape.jcr.value.BinaryValue`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  485.       @Override
  486.       protected String getStoredMimeType( BinaryValue binary ) throws BinaryStoreException {
  487. >         BinaryKey key = binary.getKey();
  488.           Metadata metadata = metadataCache.get(metadataKeyFrom(key));
  489.           if (metadata == null) {

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:488: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String InfinispanBinaryStore.getStoredMimeType(BinaryValue)` reads without synchronization from `this.metadataCache`. Potentially races with write in method `InfinispanBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  486.       protected String getStoredMimeType( BinaryValue binary ) throws BinaryStoreException {
  487.           BinaryKey key = binary.getKey();
  488. >         Metadata metadata = metadataCache.get(metadataKeyFrom(key));
  489.           if (metadata == null) {
  490.               String msg = JcrI18n.unableToFindBinaryValueInCache.text(key, metadataCache.getName());

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1700: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getString(NamespaceRegistry)` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1698.                           sb.append(',');
  1699.                       }
  1700. >                     sb.append(" -").append(name.getString(registry));
  1701.                   }
  1702.               }

src/main/java/org/modeshape/jcr/JcrVersionNode.java:91: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `javax.jcr.version.Version[] JcrVersionNode.getSuccessors()` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  89.       @Override
  90.       public Version[] getSuccessors() throws RepositoryException {
  91. >         return getNodesForProperty(JcrLexicon.SUCCESSORS);
  92.       }
  93.   

src/main/java/org/modeshape/jcr/value/binary/AbstractBinaryStore.java:129: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `String AbstractBinaryStore.getText(BinaryValue)` indirectly writes to field `binary.mimeType` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  127.           if (binary instanceof InMemoryBinaryValue) {
  128.               // The extracted text will never be stored, so try directly using the text extractors ...
  129. >             return extractors.extract((InMemoryBinaryValue)binary, new TextExtractorContext(detector()));
  130.           }
  131.   

src/main/java/org/modeshape/jcr/value/binary/AbstractBinaryStore.java:137: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `String AbstractBinaryStore.getText(BinaryValue)` indirectly mutates container `this.extractors.extractionResults` via call to `add` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  135.               if (latch == null) {
  136.                   // There is no latch, so just compute the text here ...
  137. >                 latch = extractors.extract(this, binary, new TextExtractorContext(detector()));
  138.               }
  139.               // There was a latch, so wait till the work is done ...

src/main/java/org/modeshape/jcr/value/binary/AbstractBinaryStore.java:134: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `BinaryKey BinaryValue.getKey()` of un-annotated interface `org.modeshape.jcr.value.BinaryValue`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  132.           // there isn't any text available, so wait for a job to finish and then return the result
  133.           try {
  134. >             CountDownLatch latch = extractors.getWorkerLatch(binary.getKey(), false);
  135.               if (latch == null) {
  136.                   // There is no latch, so just compute the text here ...

src/main/java/org/modeshape/jcr/value/binary/CompositeBinaryStore.java:319: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `BinaryKey BinaryValue.getKey()` of un-annotated interface `org.modeshape.jcr.value.BinaryValue`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.BinaryStore` is annotated `@ThreadSafe`.
  317.               BinaryStore bs = entry.getValue();
  318.               try {
  319. >                 if (bs.hasBinary(binary.getKey())) {
  320.                       return bs.getText(binary);
  321.                   }

src/main/java/org/modeshape/jcr/value/binary/CompositeBinaryStore.java:308: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `String CompositeBinaryStore.getText(BinaryValue)` indirectly writes to field `binary.mimeType` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.BinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  306.   
  307.               // The extracted text will never be stored, so try directly using the text extractors ...
  308. >             return extractors.extract((InMemoryBinaryValue)binary, new TextExtractorContext(detector));
  309.           }
  310.   

src/main/java/org/modeshape/jcr/cache/change/RecordingChanges.java:329: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `DateTime RecordingChanges.getTimestamp()` reads without synchronization from `this.timestamp`. Potentially races with write in method `RecordingChanges.freeze(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  327.       @Override
  328.       public DateTime getTimestamp() {
  329. >         return timestamp;
  330.       }
  331.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2134: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Set CachedNode.getMixinTypes(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  2132.       @Override
  2133.       public final String getUUID() throws UnsupportedRepositoryOperationException, RepositoryException {
  2134. >         if (!isReferenceable()) {
  2135.               throw new UnsupportedRepositoryOperationException();
  2136.           }

src/main/java/org/modeshape/jcr/cache/change/RecordingChanges.java:334: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Map RecordingChanges.getUserData()` reads without synchronization from `this.userData`. Potentially races with write in method `RecordingChanges.freeze(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  332.       @Override
  333.       public Map<String, String> getUserData() {
  334. >         return userData;
  335.       }
  336.   

src/main/java/org/modeshape/jcr/cache/change/RecordingChanges.java:339: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String RecordingChanges.getUserId()` reads without synchronization from `this.userId`. Potentially races with write in method `RecordingChanges.freeze(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  337.       @Override
  338.       public String getUserId() {
  339. >         return userId;
  340.       }
  341.   

src/main/java/org/modeshape/jcr/ExecutionContext.java:821: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Collection Multimap.get(Object)` of un-annotated interface `org.modeshape.common.collection.Multimap`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.ValueFactories` is annotated `@ThreadSafe`.
  819.           public ValueFactory<?> getValueFactory( Object prototype ) {
  820.               CheckArg.isNotNull(prototype, "prototype");
  821. >             PropertyType inferredType = PropertyType.discoverType(prototype);
  822.               assert inferredType != null;
  823.               return getValueFactory(inferredType);

src/main/java/org/modeshape/jcr/value/basic/AbstractValueFactories.java:85: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Collection Multimap.get(Object)` of un-annotated interface `org.modeshape.common.collection.Multimap`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  83.       public ValueFactory<?> getValueFactory( Object prototype ) {
  84.           CheckArg.isNotNull(prototype, "prototype");
  85. >         PropertyType inferredType = PropertyType.discoverType(prototype);
  86.           assert inferredType != null;
  87.           return getValueFactory(inferredType);

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:55: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Version JcrVersionHistoryNode.getVersion(String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  53.    * Convenience wrapper around a version history {@link JcrNode node}.
  54.    */
  55. > @ThreadSafe
  56.   final class JcrVersionHistoryNode extends JcrSystemNode implements VersionHistory {
  57.   

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:93: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `JcrVersionNode JcrVersionHistoryNode.getVersion(String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  91.       public JcrVersionNode getVersion( String versionName ) throws VersionException, RepositoryException {
  92.           try {
  93. >             return (JcrVersionNode)getNode(versionName);
  94.           } catch (PathNotFoundException pnfe) {
  95.               throw new VersionException(JcrI18n.invalidVersionName.text(versionName, getPath()));

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:55: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Version JcrVersionHistoryNode.getVersionByLabel(String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  53.    * Convenience wrapper around a version history {@link JcrNode node}.
  54.    */
  55. > @ThreadSafe
  56.   final class JcrVersionHistoryNode extends JcrSystemNode implements VersionHistory {
  57.   

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:102: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `JcrVersionNode JcrVersionHistoryNode.getVersionByLabel(String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  100.       public JcrVersionNode getVersionByLabel( String label ) throws VersionException, RepositoryException {
  101.           try {
  102. >             javax.jcr.Property prop = versionLabels().getProperty(nameFrom(label));
  103.               if (prop == null) {
  104.                   throw new VersionException(JcrI18n.labeledNodeNotFound.text(label, getPath()));

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:104: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Path.getString(NamespaceRegistry)` of un-annotated interface `org.modeshape.jcr.value.Path`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  102.               javax.jcr.Property prop = versionLabels().getProperty(nameFrom(label));
  103.               if (prop == null) {
  104. >                 throw new VersionException(JcrI18n.labeledNodeNotFound.text(label, getPath()));
  105.               }
  106.               return (JcrVersionNode)prop.getNode();

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:101: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `VersionHistory AbstractJcrNode.getVersionHistory()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  99.    * The abstract base class for all {@link Node} implementations.
  100.    */
  101. > @ThreadSafe
  102.   abstract class AbstractJcrNode extends AbstractJcrItem implements Node {
  103.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3285: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `JcrVersionHistoryNode AbstractJcrNode.getVersionHistory()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3283.       @Override
  3284.       public JcrVersionHistoryNode getVersionHistory() throws UnsupportedRepositoryOperationException, RepositoryException {
  3285. >         return versionManager().getVersionHistory(this);
  3286.       }
  3287.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `JcrVersionHistoryNode JcrSystemNode.getVersionHistory()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:118: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `java.lang.String[] JcrVersionHistoryNode.getVersionLabels()` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  116.           List<String> labels = new ArrayList<String>();
  117.   
  118. >         PropertyIterator iter = versionLabels().getProperties();
  119.           while (iter.hasNext()) {
  120.               javax.jcr.Property property = iter.nextProperty();

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:122: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Property.getName()` of un-annotated interface `javax.jcr.Property`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  120.               javax.jcr.Property property = iter.nextProperty();
  121.               if (property.getType() == PropertyType.REFERENCE) {
  122. >                 labels.add(property.getName());
  123.               }
  124.           }

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:157: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `java.lang.String[] JcrVersionHistoryNode.getVersionLabels(Version)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  155.       @Override
  156.       public String[] getVersionLabels( Version version ) throws RepositoryException {
  157. >         Set<String> labels = versionLabelsFor(version);
  158.           return labels.toArray(new String[labels.size()]);
  159.       }

src/main/java/org/modeshape/jcr/JcrWorkspace.java:72: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `VersionManager JcrWorkspace.getVersionManager()` indirectly reads without synchronization from `this.versionManager`. Potentially races with write in method `JcrWorkspace.versionManager()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  70.    * instantiates the various components when needed.
  71.    */
  72. > @ThreadSafe
  73.   class JcrWorkspace implements org.modeshape.jcr.api.Workspace {
  74.   

src/main/java/org/modeshape/jcr/JcrWorkspace.java:664: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `JcrVersionManager JcrWorkspace.getVersionManager()` indirectly reads without synchronization from `this.versionManager`. Potentially races with write in method `JcrWorkspace.versionManager()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  662.       public JcrVersionManager getVersionManager() throws UnsupportedRepositoryOperationException, RepositoryException {
  663.           session.checkLive();
  664. >         return versionManager();
  665.       }
  666.   

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:384: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `String JcrVersionHistoryNode.getVersionableIdentifier()` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  382.       public String getVersionableIdentifier() throws RepositoryException {
  383.           // ModeShape uses a node's UUID as it's identifier
  384. >         return getVersionableUUID();
  385.       }
  386.   

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:163: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `String JcrVersionHistoryNode.getVersionableUUID()` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  161.       @Override
  162.       public String getVersionableUUID() throws RepositoryException {
  163. >         return getProperty(JcrLexicon.VERSIONABLE_UUID).getString();
  164.       }
  165.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2158: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `PropertyDefinition Property.getDefinition()` of un-annotated interface `javax.jcr.Property`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  2156.       @Override
  2157.       public PropertyIterator getWeakReferences() throws RepositoryException {
  2158. >         return getWeakReferences(null);
  2159.       }
  2160.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `PropertyDefinition Property.getDefinition()` of un-annotated interface `javax.jcr.Property`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`.
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2164: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `PropertyDefinition Property.getDefinition()` of un-annotated interface `javax.jcr.Property`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  2162.       public PropertyIterator getWeakReferences( String propertyName ) throws RepositoryException {
  2163.           checkSession();
  2164. >         return propertiesOnOtherNodesReferencingThis(propertyName, PropertyType.WEAKREFERENCE);
  2165.       }
  2166.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `PropertyDefinition Property.getDefinition()` of un-annotated interface `javax.jcr.Property`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`.
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:491: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean LazyCachedNode.hasACL(NodeCache)` indirectly mutates container `keysWithName` via call to `add` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  489.       public boolean hasACL( NodeCache cache ) {
  490.           if (hasACL == null) {
  491. >             hasACL = getChildReferences(cache).getChild(ModeShapeLexicon.ACCESS_LIST_NODE_NAME) != null;
  492.           }
  493.           return hasACL;

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1483: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1481.       @Override
  1482.       public boolean hasACL( NodeCache cache ) {
  1483. >         return getChildReferences(cache).getChild(ModeShapeLexicon.ACCESS_LIST_NODE_NAME) != null;
  1484.       }
  1485.   

src/main/java/org/modeshape/jcr/cache/document/BucketedChildReferences.java:125: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean BucketedChildReferences.hasChild(NodeKey)` indirectly reads without synchronization from container `this.rangeBucketsById` via call to `get`. Potentially races with write in method `BucketedChildReferences.getChildCount(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  123.       @Override
  124.       public boolean hasChild( NodeKey key ) {
  125. >         return getChild(key) != null;
  126.       }
  127.   

src/main/java/org/modeshape/jcr/cache/document/SessionChildReferences.java:131: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean ChildReferences.hasChild(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.ChildReferences`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  129.       @Override
  130.       public boolean hasChild( NodeKey key ) {
  131. >         return persisted.hasChild(key) ||
  132.                  (appended != null && appended.hasChild(key)) ||
  133.                  (changedChildren != null && changedChildren.inserted(key) != null);

src/main/java/org/modeshape/jcr/JcrNodeType.java:208: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean Multimap.isEmpty()` of un-annotated interface `org.modeshape.common.collection.Multimap`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  206.        */
  207.       boolean hasChildNodeDefinitions() {
  208. >         return allDefinitions.anyChildNodeDefinitions();
  209.       }
  210.   

src/main/java/org/modeshape/jcr/Connectors.java:756: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean Connectors$Snapshot.hasConnectors()` reads without synchronization from container `this.sourceKeyToConnectorMap` via call to `isEmpty`. Potentially races with write in method `Connectors$Snapshot.shutdownConnectors()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  754.            */
  755.           public boolean hasConnectors() {
  756. >             return !sourceKeyToConnectorMap.isEmpty();
  757.           }
  758.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:734: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean AbstractJcrNode.hasNode(String)` indirectly reads without synchronization from `this.session.rootNode.key.workspaceKey`. Potentially races with write in method `AbstractJcrNode.addNode(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  732.                   if (path.getLastSegment().isSelfReference()) return true;
  733.                   if (path.getLastSegment().isParentReference()) {
  734. >                     return !isRoot() && session.hasPermission(this.getParent().getPath(), ModeShapePermissions.READ);
  735.                   }
  736.               }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:740: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Set CachedNode.getAdditionalParentKeys(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  738.               if (path.size() > 1) {
  739.                   try {
  740. >                     AbstractJcrNode node = session().node(node(), path);
  741.                       return node != null && session().hasPermission(node.getPath(), ModeShapePermissions.READ);
  742.                   } catch (PathNotFoundException e) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:757: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean AbstractJcrNode.hasNode(String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  755.               return false;
  756.           }
  757. >         Node node = session().node(ref.getKey(), null);
  758.           return session.hasPermission(node.getPath(), ModeShapePermissions.READ);
  759.       }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:720: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean AbstractJcrNode.hasNode(String)` indirectly reads without synchronization from `nodeKey.workspaceKey`. Potentially races with write in method `AbstractJcrNode.addNode(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  718.           if (relativePath.equals(".")) return true;
  719.           if (relativePath.equals("..")) {
  720. >             return !isRoot() && session.hasPermission(this.getParent().getPath(), ModeShapePermissions.READ);
  721.           }
  722.           int indexOfFirstSlash = relativePath.indexOf('/');

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean JcrSystemNode.hasNode(String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2266: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReferences CachedNode.getChildReferences(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  2264.           checkSession();
  2265.           // this should check permissions via the resolver
  2266. >         return getNodes().hasNext();
  2267.       }
  2268.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReferences CachedNode.getChildReferences(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`.
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2272: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `CachedNode SessionCache.getNode(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  2270.       public boolean hasProperties() throws RepositoryException {
  2271.           checkSession();
  2272. >         return node().hasProperties(sessionCache());
  2273.       }
  2274.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `CachedNode SessionCache.getNode(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`.
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:384: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Iterable Document.fields()` of un-annotated interface `org.infinispan.schematic.document.Document`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  382.           if (propertiesFullyLoaded) return false;
  383.           WorkspaceCache wsCache = workspaceCache(cache);
  384. >         return wsCache.translator().hasProperties(document(wsCache));
  385.       }
  386.   

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:717: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  715.           // Delegate to the workspace node (if it exists) ...
  716.           AbstractSessionCache session = session(cache);
  717. >         CachedNode raw = nodeInWorkspace(session);
  718.           return raw != null ? raw.hasProperties(session) : false;
  719.       }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2248: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean AbstractJcrNode.hasProperty(String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2246.           if (relPath.indexOf('/') >= 0 || relPath.startsWith("[")) {
  2247.               try {
  2248. >                 getProperty(relPath);
  2249.                   return true;
  2250.               } catch (PathNotFoundException e) {

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean JcrSystemNode.hasProperty(String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:530: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `CachedNode SessionCache.getNode(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  528.       final boolean hasProperty( Name name ) throws RepositoryException {
  529.           if (jcrProperties.containsKey(name)) return true;
  530. >         return node().hasProperty(name, sessionCache());
  531.       }
  532.   

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:394: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Object Document.get(String)` of un-annotated interface `org.infinispan.schematic.document.Document`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  392.           if (propertiesFullyLoaded) return false;
  393.           WorkspaceCache wsCache = workspaceCache(cache);
  394. >         return wsCache.translator().hasProperty(document(wsCache), name);
  395.       }
  396.   

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:728: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  726.           // Otherwise, delegate to the workspace node (if it exists) ...
  727.           AbstractSessionCache session = session(cache);
  728. >         CachedNode raw = nodeInWorkspace(session);
  729.           return raw != null ? raw.hasProperty(name, session) : false;
  730.       }

src/main/java/org/modeshape/jcr/JcrNodeType.java:226: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean Multimap.isEmpty()` of un-annotated interface `org.modeshape.common.collection.Multimap`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  224.        */
  225.       boolean hasPropertyDefinitions() {
  226. >         return allDefinitions.anyPropertyDefinitions();
  227.       }
  228.   

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:168: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean JcrVersionHistoryNode.hasVersionLabel(String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  166.       @Override
  167.       public boolean hasVersionLabel( String label ) throws RepositoryException {
  168. >         return versionLabels().hasProperty(label);
  169.       }
  170.   

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:174: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean JcrVersionHistoryNode.hasVersionLabel(Version,String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  172.       public boolean hasVersionLabel( Version version,
  173.                                       String label ) throws RepositoryException {
  174. >         return versionLabelsFor(version).contains(label);
  175.       }
  176.   

src/main/java/org/modeshape/jcr/JcrLockManager.java:216: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean JcrLockManager.holdsLock(String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  214.       @Override
  215.       public boolean holdsLock( String absPath ) throws PathNotFoundException, RepositoryException {
  216. >         AbstractJcrNode node = session.node(session.absolutePathFor(absPath));
  217.           return lockManager.findLockFor(node.key()) != null;
  218.       }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:285: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `NodeKey SessionCache.getRootKey()` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  283.        */
  284.       final String identifierPath() throws RepositoryException {
  285. >         return "[" + getIdentifier() + "]";
  286.       }
  287.   

src/main/java/org/modeshape/jcr/RepositoryIndexManager.java:220: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void RepositoryIndexManager.importIndexDefinitions()` indirectly reads with synchronization from container `byProvider` via call to `get`. Potentially races with unsynchronized write in method `RepositoryIndexManager.registerIndexes(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  218.           if (!defns.isEmpty()) {
  219.               IndexDefinition[] array = defns.toArray(new IndexDefinition[defns.size()]);
  220. >             registerIndexes(array, true);
  221.               // Wait while the indexes get created ...
  222.               try {

src/main/java/org/modeshape/jcr/JcrWorkspace.java:736: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.importXML(String,InputStream,int)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  734.           try {
  735.               XMLReader parser = XMLReaderFactory.createXMLReader();
  736. >             parser.setContentHandler(getImportContentHandler(parentAbsPath, uuidBehavior));
  737.               parser.parse(new InputSource(in));
  738.           } catch (EnclosingSAXException ese) {

src/main/java/org/modeshape/jcr/JcrWorkspace.java:737: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void XMLReader.parse(InputSource)` of un-annotated interface `org.xml.sax.XMLReader`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  735.               XMLReader parser = XMLReaderFactory.createXMLReader();
  736.               parser.setContentHandler(getImportContentHandler(parentAbsPath, uuidBehavior));
  737. >             parser.parse(new InputSource(in));
  738.           } catch (EnclosingSAXException ese) {
  739.               Exception cause = ese.getException();

src/main/java/org/modeshape/jcr/clustering/ClusteringService.java:564: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ClusteringService$ForkedClusteringService.init()` mutates container `existingForksForChannel` via call to `add` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.clustering.ClusteringService` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  562.                           FORK_STACKS_BY_CHANNEL_NAME.put(mainChannelName, existingForksForChannel);
  563.                       }
  564. >                     existingForksForChannel.add(forkStackId);
  565.                   }
  566.   

src/main/java/org/modeshape/jcr/clustering/ClusteringService.java:559: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ClusteringService$ForkedClusteringService.init()` reads without synchronization from container `clustering.ClusteringService$ForkedClusteringService.FORK_STACKS_BY_CHANNEL_NAME` via call to `get`. Potentially races with write in method `ClusteringService$ForkedClusteringService.shutdown()`.
 Reporting because a superclass `class org.modeshape.jcr.clustering.ClusteringService` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  557.                   if (!alreadyHasForkProtocol) {
  558.                       String mainChannelName = mainChannel.getName();
  559. >                     List<String> existingForksForChannel = FORK_STACKS_BY_CHANNEL_NAME.get(mainChannelName);
  560.                       if (existingForksForChannel == null) {
  561.                           existingForksForChannel = new ArrayList<>();

src/main/java/org/modeshape/jcr/clustering/ClusteringService.java:541: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ClusteringService$ForkedClusteringService.init()` writes to field `this.channel` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.clustering.ClusteringService` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  539.                   // and use the name of the cluster as the stack id
  540.                   this.channel = new ForkChannel(mainChannel, forkStackId, FORK_CHANNEL_NAME, true, ProtocolStack.ABOVE,
  541. >                                                topProtocol.getClass(), new CENTRAL_LOCK());
  542.   
  543.                   // always add central lock to the stack

src/main/java/org/modeshape/jcr/clustering/ClusteringService.java:544: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ClusteringService$ForkedClusteringService.init()` reads without synchronization from `this.channel`. Potentially races with write in method `ClusteringService$ForkedClusteringService.shutdown()`.
 Reporting because a superclass `class org.modeshape.jcr.clustering.ClusteringService` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  542.   
  543.                   // always add central lock to the stack
  544. >                 this.lockService = new LockService(this.channel);
  545.   
  546.                   // Add a listener through which we'll know what's going on within the cluster ...

src/main/java/org/modeshape/jcr/clustering/ClusteringService.java:562: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ClusteringService$ForkedClusteringService.init()` mutates container `clustering.ClusteringService$ForkedClusteringService.FORK_STACKS_BY_CHANNEL_NAME` via call to `put` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.clustering.ClusteringService` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  560.                       if (existingForksForChannel == null) {
  561.                           existingForksForChannel = new ArrayList<>();
  562. >                         FORK_STACKS_BY_CHANNEL_NAME.put(mainChannelName, existingForksForChannel);
  563.                       }
  564.                       existingForksForChannel.add(forkStackId);

src/main/java/org/modeshape/jcr/clustering/ClusteringService.java:458: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ClusteringService$StandaloneClusteringService.init()` writes to field `this.channel` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.clustering.ClusteringService` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  456.           protected void init() {
  457.               try {
  458. >                 this.channel = newChannel(jgroupsConfig);
  459.   
  460.                   ProtocolStack protocolStack = channel.getProtocolStack();

src/main/java/org/modeshape/jcr/clustering/ClusteringService.java:460: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ClusteringService$StandaloneClusteringService.init()` reads without synchronization from `this.channel`. Potentially races with write in method `ClusteringService$StandaloneClusteringService.init()`.
 Reporting because a superclass `class org.modeshape.jcr.clustering.ClusteringService` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  458.                   this.channel = newChannel(jgroupsConfig);
  459.   
  460. >                 ProtocolStack protocolStack = channel.getProtocolStack();
  461.                   Protocol centralLock = protocolStack.findProtocol(CENTRAL_LOCK.class);
  462.                   if (centralLock == null) {

src/main/java/org/modeshape/jcr/clustering/ClusteringService.java:469: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ClusteringService$StandaloneClusteringService.init()` writes to field `this.lockService` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.clustering.ClusteringService` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  467.                       protocolStack.addProtocol(lockingProtocol);
  468.                   }
  469. >                 this.lockService = new LockService(this.channel);
  470.   
  471.                   // Add a listener through which we'll know what's going on within the cluster ...

src/main/java/org/modeshape/jcr/mimetype/ContentDetector.java:59: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContentDetector.initDetector(ClassLoader)` reads without synchronization from `this.detector`. Potentially races with write in method `ContentDetector.initDetector(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  57.               this.detector = new DefaultDetector(MimeTypes.getDefaultMimeTypes(loader));
  58.               if (logger.isDebugEnabled()) {
  59. >                 for (Detector detector : this.detector.getDetectors()) {
  60.                       logger.debug(" - Found TIKA detector: " + detector.getClass().getName());
  61.                   }                

src/main/java/org/modeshape/jcr/mimetype/ContentDetector.java:57: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContentDetector.initDetector(ClassLoader)` writes to field `this.detector` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  55.           try {
  56.               // this will also load ModeShape's custom-mimetypes.xml because it's placed in a org.apache.tika.mime package
  57. >             this.detector = new DefaultDetector(MimeTypes.getDefaultMimeTypes(loader));
  58.               if (logger.isDebugEnabled()) {
  59.                   for (Detector detector : this.detector.getDetectors()) {

src/main/java/org/modeshape/jcr/mimetype/NameOnlyDetector.java:54: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NameOnlyDetector.initDetector(ClassLoader)` writes to field `this.detector` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  52.           // this will also load ModeShape's custom-mimetypes.xml because it's placed in a org.apache.tika.mime package
  53.           try {
  54. >             this.detector = MimeTypes.getDefaultMimeTypes(loader);
  55.           } catch (Throwable t) {
  56.               throw new SystemFailureException(JcrI18n.unableToInitializeMimeTypeDetector.text(t.getMessage()), t);

src/main/java/org/modeshape/jcr/Connectors.java:118: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Connectors.initialize()` indirectly reads with synchronization from `nodeKey.workspaceKey`. Potentially races with unsynchronized write in method `Connectors.isReadonlyPath(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  116.           loadStoredProjections(false);
  117.           // creates any preconfigured projections
  118. >         createPreconfiguredProjections();
  119.           // load the projections, but with all pre-configured projections and validating each projection
  120.           loadStoredProjections(true);

src/main/java/org/modeshape/jcr/RepositoryIndexManager.java:172: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `RepositoryIndexManager$ScanningTasks RepositoryIndexManager.initialize()` indirectly reads with synchronization from container `byProvider` via call to `get`. Potentially races with unsynchronized write in method `RepositoryIndexManager.registerIndexes(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  170.           }
  171.           // Re-read the index definitions in case there were disabled index definitions that used the now-available provider ...
  172. >         RepositoryIndexes indexes = readIndexDefinitions();
  173.   
  174.           // Notify the providers of all the index definitions (which we'll treat as "new" since we're just starting up) ...

src/main/java/org/modeshape/jcr/Connectors.java:494: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `LocalDocumentStore DocumentStore.localStore()` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  492.   
  493.           // Set the ExtraPropertiesStore instance, which is unique to this connector ...
  494. >         LocalDocumentStore store = repository.documentStore().localStore();
  495.           String name = connector.getSourceName();
  496.           String sourceKey = NodeKey.keyForSourceName(name);

src/main/java/org/modeshape/jcr/Connectors.java:448: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Iterable Document.fields()` of un-annotated interface `org.infinispan.schematic.document.Document`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  446.           try {
  447.               // Instantiate the connector and set the 'name' field ...
  448. >             Connector connector = component.createInstance(getClass().getClassLoader());
  449.   
  450.               // Set the repository name field ...

src/main/java/org/modeshape/jcr/JcrWorkspace.java:477: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void MutableCachedNode.addInternalProperty(String,Object)` of un-annotated interface `org.modeshape.jcr.cache.MutableCachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  475.                       // Use the JCR add child here to perform the parent validations
  476.                       cloneKey = parentNode.key().withId(sourceNode.key().getIdentifier());
  477. >                     parentNode.addChildNode(newNodeName, sourceNode.getPrimaryTypeName(), cloneKey, skipVersioningValidation,
  478.                                               false);
  479.                   } else {

src/main/java/org/modeshape/jcr/JcrWorkspace.java:381: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.internalClone(String,String,String,boolean,boolean)` indirectly writes to field `sourceKey.sourceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  379.               }
  380.   
  381. >             validateCloneForExternalNodes(sameWorkspace, sourceSession, sourceNode, parentNode);
  382.               
  383.               NodeTypes nodeTypes = repository().nodeTypeManager().getNodeTypes();

src/main/java/org/modeshape/jcr/JcrWorkspace.java:482: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.internalClone(String,String,String,boolean,boolean)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  480.                       cloneKey = parentNode.key();
  481.                   }
  482. >                 deepClone(sourceSession, sourceNode.key(), cloneSession, cloneKey);
  483.               }
  484.           } catch (ItemNotFoundException e) {

src/main/java/org/modeshape/jcr/JcrWorkspace.java:430: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.internalClone(String,String,String,boolean,boolean)` indirectly writes to field `srcKey.sourceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  428.                               cloneSession.aclAdded(permissions.size());
  429.                           }
  430. >                         boolean isExternal = !srcKey.getSourceKey().equalsIgnoreCase(sourceCache.getRootKey().getSourceKey());
  431.                           if (isExternal && session.nodeExists(srcKey) && !removeExisting) {
  432.                               throw new ItemExistsException(JcrI18n.itemAlreadyExistsWithUuid.text(srcKey, workspaceName,

src/main/java/org/modeshape/jcr/JcrWorkspace.java:349: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.internalClone(String,String,String,boolean,boolean)` indirectly writes to field `parentKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  347.               Name newNodeName = null;
  348.               if (destPath.isIdentifier()) {
  349. >                 AbstractJcrNode existingDestNode = cloneSession.node(destPath);
  350.                   if (!existingDestNode.isRoot()) {
  351.                       parentNode = existingDestNode.getParent();

src/main/java/org/modeshape/jcr/JcrWorkspace.java:376: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.internalClone(String,String,String,boolean,boolean)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  374.               AbstractJcrNode sourceNode = sourceSession.node(srcPath);
  375.               JcrLockManager lockManager = session.lockManager();
  376. >             javax.jcr.lock.Lock lock = lockManager.getLockIfExists(sourceNode);
  377.               if (lock != null && !lock.isLockOwningSession()) {
  378.                   throw new LockException(srcAbsPath);

src/main/java/org/modeshape/jcr/JcrWorkspace.java:416: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.internalClone(String,String,String,boolean,boolean)` indirectly writes to field `sourceKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  414.                   SessionCache sourceCache = sourceSession.cache();
  415.                   Set<NodeKey> sourceKeys = sourceCache.getNodeKeysAtAndBelow(sourceNode.key());
  416. >                 sourceKeys = filterNodeKeysForClone(sourceKeys, sourceCache);
  417.   
  418.                   for (NodeKey srcKey : sourceKeys) {

src/main/java/org/modeshape/jcr/JcrWorkspace.java:310: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JcrWorkspace.internalClone(String,String,String,boolean,boolean)` indirectly reads without synchronization from `nodeKey.workspaceKey`. Potentially races with write in method `JcrWorkspace.deleteWorkspace(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  308.           if (sameWorkspace && removeExisting) {
  309.               // This is a special case of cloning within the same workspace but removing the original, which equates to a move ...
  310. >             move(srcAbsPath, destAbsPath);
  311.               return;
  312.           }

src/main/java/org/modeshape/jcr/JcrWorkspace.java:305: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.internalClone(String,String,String,boolean,boolean)` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  303.           CheckArg.isNotEmpty(destAbsPath, "destAbsPath");
  304.   
  305. >         validateCrossWorkspaceAction(srcWorkspace);
  306.   
  307.           final boolean sameWorkspace = getName().equals(srcWorkspace);

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3170: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.internalRemove(boolean)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3168.           }
  3169.           try {
  3170. >             parent.checkForLock();
  3171.               session.checkPermission(this, ModeShapePermissions.REMOVE);
  3172.               // MODE-1920: check permission to remove child nodes

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3171: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.internalRemove(boolean)` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3169.           try {
  3170.               parent.checkForLock();
  3171. >             session.checkPermission(this, ModeShapePermissions.REMOVE);
  3172.               // MODE-1920: check permission to remove child nodes
  3173.               session.checkPermission(parent.path(), ModeShapePermissions.REMOVE_CHILD_NODES);

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3179: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean NodeTypes$ReusableNodeDefinitionSet.appliesTo(NodeTypes,Name,Set)` of un-annotated interface `org.modeshape.jcr.NodeTypes$ReusableNodeDefinitionSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  3177.           }
  3178.   
  3179. >         if (!skipVersioningValidation && !parent.isCheckedOut()) {
  3180.               // The parent node is checked in, so we can only remove this node if this node has an OPV of 'ignore'.
  3181.               // This is probably rarely the case, so the extra work is acceptable

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:157: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Path$Segment Path.getLastSegment()` of un-annotated interface `org.modeshape.jcr.value.Path`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  155.                   if (parent.getPath(cache).isAtOrBelow(parentOfPath)) {
  156.                       ChildReference ref = parent.getChildReferences(cache).getChild(key);
  157. >                     if (ref != null && ref.getSegment().equals(path.getLastSegment())) return true;
  158.                   }
  159.               }

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:148: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean LazyCachedNode.isAtOrBelow(NodeCache,Path)` indirectly writes to field `this.key.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  146.       public boolean isAtOrBelow( NodeCache cache,
  147.                                   Path path ) {
  148. >         Path aPath = getPath(cache);
  149.           if (path.isAtOrAbove(aPath)) return true;
  150.           Set<NodeKey> additionalParents = getAdditionalParentKeys(cache);

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:381: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  379.       public boolean isAtOrBelow( NodeCache cache,
  380.                                   Path path ) {
  381. >         Path aPath = getPath(cache);
  382.           if (path.isAtOrAbove(aPath)) return true;
  383.           ChangedAdditionalParents additionalParents = additionalParents();

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3222: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean NodeTypes$ReusableNodeDefinitionSet.appliesTo(NodeTypes,Name,Set)` of un-annotated interface `org.modeshape.jcr.NodeTypes$ReusableNodeDefinitionSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  3220.           while (node != null) {
  3221.               // If the node has an OPV of 'ignore' ...
  3222. >             NodeDefinition defn = node.getDefinition();
  3223.               if (defn.getOnParentVersion() == OnParentVersionAction.IGNORE) {
  3224.                   // This node is not or cannot be checked in ...

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean NodeTypes$ReusableNodeDefinitionSet.appliesTo(NodeTypes,Name,Set)` of un-annotated interface `org.modeshape.jcr.NodeTypes$ReusableNodeDefinitionSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`.
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:1698: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean WritableSessionCache.isDestroyed(NodeKey)` reads without synchronization from `this.changedNodes`. Potentially races with write in method `WritableSessionCache.save()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1696.       @Override
  1697.       public boolean isDestroyed( NodeKey key ) {
  1698. >         return changedNodes.get(key) == REMOVED;
  1699.       }
  1700.   

src/main/java/org/modeshape/jcr/cache/change/RecordingChanges.java:248: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean RecordingChanges.isEmpty()` reads without synchronization from `this.nodeKeys`. Potentially races with write in method `RecordingChanges.setChangedNodes(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  246.       @Override
  247.       public boolean isEmpty() {
  248. >         return events.isEmpty() && nodeKeys.isEmpty(); // not all changed nodes cause events (e.g., shared nodes)
  249.       }
  250.   

src/main/java/org/modeshape/jcr/JcrVersionNode.java:145: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean JcrVersionNode.isEventualSuccessorOf(JcrVersionNode)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  143.           }
  144.   
  145. >         for (Version successor : other.getSuccessors()) {
  146.               if (isEventualSuccessorOf((JcrVersionNode) successor)) {
  147.                   return true;

src/main/java/org/modeshape/jcr/JcrVersionNode.java:141: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean JcrVersionNode.isEventualSuccessorOf(JcrVersionNode)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  139.   
  140.       boolean isEventualSuccessorOf( JcrVersionNode other ) throws RepositoryException {
  141. >         if (isLinearSuccessorOf(other)) {
  142.               return true;
  143.           }

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:485: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean Document.getBoolean(String,boolean)` of un-annotated interface `org.infinispan.schematic.document.Document`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  483.       public boolean isExcludedFromSearch( NodeCache cache ) {
  484.           WorkspaceCache wsCache = workspaceCache(cache);
  485. >         return !wsCache.translator().isQueryable(document(wsCache));
  486.       }
  487.   

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1472: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1470.               return isExcludedFromSearch;
  1471.           }
  1472. >         CachedNode persistedNode = nodeInWorkspace(session(cache));
  1473.           // if the node does not exist yet, it is queryable by default
  1474.           return persistedNode != null && persistedNode.isExcludedFromSearch(cache);

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:266: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `NodeKey SessionCache.getRootKey()` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  264.        */
  265.       protected final boolean isExternal() {
  266. >         return !key().getSourceKey().equals(session().cache().getRootKey().getSourceKey());
  267.       }
  268.   

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:526: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `NodeKey NodeCache.getRootKey()` of un-annotated interface `org.modeshape.jcr.cache.NodeCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  524.       @Override
  525.       public boolean isExternal( NodeCache cache) {
  526. >         return !getKey().getSourceKey().equals(cache.getRootKey().getSourceKey());
  527.       }
  528.   

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1605: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `NodeKey NodeCache.getRootKey()` of un-annotated interface `org.modeshape.jcr.cache.NodeCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1603.       @Override
  1604.       public boolean isExternal( NodeCache cache ) {
  1605. >         return !getKey().getSourceKey().equals(cache.getRootKey().getSourceKey());
  1606.       }
  1607.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:257: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `NodeKey SessionCache.getRootKey()` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  255.        */
  256.       protected final boolean isForeign() {
  257. >         return session().isForeignKey(key());
  258.       }
  259.   

src/main/java/org/modeshape/jcr/JcrVersionNode.java:126: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `CachedNode SessionCache.getNode(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`.
  124.   
  125.       boolean isLinearSuccessorOf( JcrVersionNode other ) throws RepositoryException {
  126. >         if (!other.hasProperty(JcrLexicon.SUCCESSORS)) return false;
  127.   
  128.           Value[] successors = other.getProperty(JcrLexicon.SUCCESSORS).getValues();

src/main/java/org/modeshape/jcr/JcrVersionNode.java:128: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean JcrVersionNode.isLinearSuccessorOf(JcrVersionNode)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  126.           if (!other.hasProperty(JcrLexicon.SUCCESSORS)) return false;
  127.   
  128. >         Value[] successors = other.getProperty(JcrLexicon.SUCCESSORS).getValues();
  129.   
  130.           String id = getIdentifier();

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:554: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Set CachedNode.getMixinTypes(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  552.   
  553.       boolean isLockable() throws RepositoryException {
  554. >         return isNodeType(JcrMixLexicon.LOCKABLE);
  555.       }
  556.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3342: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  3340.       public boolean isLocked() throws RepositoryException {
  3341.           // Session's liveness will be checked in 'lockManager()' ...
  3342. >         return session.lockManager().isLocked(this);
  3343.       }
  3344.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`.
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/JcrLockManager.java:156: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean JcrLockManager.isLocked(String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  154.       @Override
  155.       public boolean isLocked( String absPath ) throws PathNotFoundException, RepositoryException {
  156. >         return getLowestLockAlongPath(session.node(session.absolutePathFor(absPath))) != null;
  157.       }
  158.   

src/main/java/org/modeshape/jcr/JcrLockManager.java:160: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  158.   
  159.       public boolean isLocked( AbstractJcrNode node ) throws PathNotFoundException, RepositoryException {
  160. >         return getLowestLockAlongPath(node) != null;
  161.       }
  162.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:643: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean AbstractJcrNode.isLockedByAnotherSession()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  641.       protected final boolean isLockedByAnotherSession() throws RepositoryException {
  642.           try {
  643. >             checkForLock();
  644.               return false;
  645.           } catch (LockException e) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3374: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `CachedNode SessionCache.getNode(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  3372.       public boolean isModified() {
  3373.           try {
  3374. >             CachedNode node = node();
  3375.               if (node instanceof MutableCachedNode) {
  3376.                   MutableCachedNode mutable = (MutableCachedNode)node;

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `CachedNode SessionCache.getNode(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`.
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3363: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `CachedNode SessionCache.getNode(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  3361.       public boolean isNew() {
  3362.           try {
  3363. >             CachedNode node = node();
  3364.               return node instanceof MutableCachedNode && ((MutableCachedNode)node).isNew();
  3365.           } catch (RepositoryException e) {

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `CachedNode SessionCache.getNode(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`.
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2317: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Set CachedNode.getMixinTypes(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  2315.       @Override
  2316.       public boolean isNodeType( String nodeTypeName ) throws RepositoryException {
  2317. >         return isNodeType(nameFrom(nodeTypeName));
  2318.       }
  2319.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Set CachedNode.getMixinTypes(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`.
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2339: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Set CachedNode.getMixinTypes(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  2337.               if (nodeTypes.isTypeOrSubtype(primaryTypeName, nodeTypeName)) return true;
  2338.               // Check the mixins ...
  2339. >             Set<Name> mixinTypes = node.getMixinTypes(cache);
  2340.               if (nodeTypes.isTypeOrSubtype(mixinTypes, nodeTypeName)) return true;
  2341.           } catch (ItemNotFoundException e) {

src/main/java/org/modeshape/jcr/RepositoryNodeTypeManager.java:314: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean RepositoryNodeTypeManager.isNodeTypeInUse(Name)` indirectly writes to field `mutableTable.extraColumns` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  312.           assert command != null : "Could not parse " + expression;
  313.   
  314. >         Schemata schemata = getRepositorySchemata();
  315.   
  316.           // Now query the entire repository for any nodes that use this node type ...

src/main/java/org/modeshape/jcr/RepositoryNodeTypeManager.java:323: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `QueryContext QueryEngine.createQueryContext(ExecutionContext,RepositoryCache,Set,Map,Schemata,RepositoryIndexes,NodeTypes,BufferManager,PlanHints,Map)` of un-annotated interface `org.modeshape.jcr.query.QueryEngine`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  321.           NodeTypes nodeTypes = repository.nodeTypeManager().getNodeTypes();
  322.           RepositoryIndexes indexDefns = repository.queryManager().getIndexes();
  323. >         CancellableQuery query = queryManager.query(context, repoCache, workspaceNames, overridden, command, schemata,
  324.                                                       indexDefns, nodeTypes, null, null);
  325.           try {

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:151: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  149.       public final boolean isPropertyModified( SessionCache cache,
  150.                                                Name propertyName ) {
  151. >         return !isNew && changedProperties.containsKey(propertyName) && isPropertyInWorkspaceCache(cache, propertyName);
  152.       }
  153.   

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:145: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  143.       public final boolean isPropertyNew( SessionCache cache,
  144.                                           Name propertyName ) {
  145. >         return isNew || (changedProperties.containsKey(propertyName) && !isPropertyInWorkspaceCache(cache, propertyName));
  146.       }
  147.   

src/main/java/org/modeshape/jcr/Connectors.java:636: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean Connectors.isReadonlyPath(Path,JcrSession)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  634.       protected boolean isReadonlyPath( Path path,
  635.                                         JcrSession session ) throws RepositoryException {
  636. >         AbstractJcrNode node = session.node(path);
  637.           Connector connector = getConnectorForSourceKey(node.key().getSourceKey());
  638.           return connector != null && connector.isReadonly();

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:546: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Set CachedNode.getMixinTypes(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  544.           try {
  545.               CachedNode node = node();
  546. >             return nodeTypes.isReferenceable(node.getPrimaryType(cache), node.getMixinTypes(cache));
  547.           } catch (ItemNotFoundException e) {
  548.               // The node has been removed, so do nothing

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3392: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Repository Session.getRepository()` of un-annotated interface `javax.jcr.Session`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  3390.               if (!this.key.equals(thatKey)) return false;
  3391.               // Make sure they are the same repository ...
  3392. >             return super.isSameRepository(otherItem);
  3393.           }
  3394.           return false;

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Repository Session.getRepository()` of un-annotated interface `javax.jcr.Session`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`.
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrItem.java:132: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Repository Session.getRepository()` of un-annotated interface `javax.jcr.Session`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  130.           assert getSession() != null;
  131.           assert otherItem.getSession() != null;
  132. >         assert getSession().getRepository() != null;
  133.           assert otherItem.getSession().getRepository() != null;
  134.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:558: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Set CachedNode.getMixinTypes(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  556.   
  557.       boolean isShareable() throws RepositoryException {
  558. >         return isNodeType(JcrMixLexicon.SHAREABLE);
  559.       }
  560.   

src/main/java/org/modeshape/jcr/JcrNode.java:82: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Set CachedNode.getAdditionalParentKeys(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  80.           // the share-related logic needs to be done here ...
  81.           try {
  82. >             return isShareable() && sharedSet().getSize() > 1;
  83.           } catch (RepositoryException e) {
  84.               // Shouldn't really happen, but just in case ...

src/main/java/org/modeshape/jcr/JcrRepository.java:601: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean JcrRepository.isSingleValueDescriptor(String)` reads without synchronization from container `this.descriptors` via call to `get`. Potentially races with write in method `JcrRepository.apply(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  599.       public boolean isSingleValueDescriptor( String key ) {
  600.           if (key == null) return true;
  601. >         return descriptors.get(key) instanceof JcrValue;
  602.       }
  603.   

src/main/java/org/modeshape/jcr/cache/document/SessionChildReferences.java:211: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Iterator ChildReferences.iterator(ChildReferences$Context)` of un-annotated interface `org.modeshape.jcr.cache.ChildReferences`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  209.       public Iterator<ChildReference> iterator( Context context ) {
  210.           if (changedChildren != null && !changedChildren.isEmpty()) context = new WithChanges(context, changedChildren);
  211. >         return createIterator(context);
  212.       }
  213.   

src/main/java/org/modeshape/jcr/cache/document/BucketedChildReferences.java:233: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReferences$Changes ChildReferences$Context.changes()` of un-annotated interface `org.modeshape.jcr.cache.ChildReferences$Context`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  231.               if (pattern instanceof Pattern) {
  232.                   // at least one wildcard is being used somewhere, so there isn't any optimization that can be performed
  233. >                 return super.iterator(context, namePatterns, registry);                 
  234.               } else {
  235.                   // this is a simple string which we'll collect

src/main/java/org/modeshape/jcr/cache/document/BucketedChildReferences.java:173: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Iterator BucketedChildReferences.iterator(Name,ChildReferences$Context)` indirectly reads without synchronization from container `this.rangeBucketsById` via call to `get`. Potentially races with write in method `BucketedChildReferences.getChildCount(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  171.       public Iterator<ChildReference> iterator( Name name, Context context ) {
  172.           // since SNS are not support, simply check if there is a node with this name or not
  173. >         ChildReference ref = getChild(name, 1, context);
  174.           return ref != null ? Collections.singletonList(ref).iterator() : Collections.<ChildReference>emptyListIterator();
  175.       }

src/main/java/org/modeshape/jcr/cache/document/SessionChildReferences.java:192: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Iterator ChildReferences.iterator(Name,ChildReferences$Context)` of un-annotated interface `org.modeshape.jcr.cache.ChildReferences`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  190.                                                 Context context ) {
  191.           if (changedChildren != null && !changedChildren.isEmpty()) context = new WithChanges(context, changedChildren);
  192. >         return createIterator(name, context);
  193.       }
  194.   

src/main/java/org/modeshape/jcr/journal/ClusteredJournal.java:169: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String ClusteredJournal.journalId()` indirectly reads without synchronization from `this.localJournal.journalId`. Potentially races with write in method `ClusteredJournal.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  167.       @Override
  168.       public String journalId() {
  169. >         return localJournal.journalId();
  170.       }
  171.   

src/main/java/org/modeshape/jcr/journal/LocalJournal.java:320: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String LocalJournal.journalId()` reads without synchronization from `this.journalId`. Potentially races with write in method `LocalJournal.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  318.       @Override
  319.       public String journalId() {
  320. >         return journalId;
  321.       }
  322.   

src/main/java/org/modeshape/jcr/journal/ClusteredJournal.java:147: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `JournalRecord ClusteredJournal.lastRecord()` indirectly reads without synchronization from `this.localJournal.records`. Potentially races with write in method `ClusteredJournal.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  145.       @Override
  146.       public JournalRecord lastRecord() {
  147. >         return localJournal.lastRecord();
  148.       }
  149.   

src/main/java/org/modeshape/jcr/journal/LocalJournal.java:227: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `JournalRecord LocalJournal.lastRecord()` reads without synchronization from `this.records`. Potentially races with write in method `LocalJournal.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  225.       @Override
  226.       public JournalRecord lastRecord() {
  227. >         return this.records == null || this.records.isEmpty() ? null : this.records.lastEntry().getValue();
  228.       }
  229.   

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1364: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1362.           // Find the referenced node ...
  1363.           SessionNode child = session.mutable(childKey);
  1364. >         if (!child.isNew() && this.key.equals(child.getParentKey(cache))) {
  1365.               // Already a linked child under this parent
  1366.               return false;

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1360: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean SessionNode.linkChild(SessionCache,NodeKey,Name)` indirectly reads without synchronization from container `session.changedNodes` via call to `get`. Potentially races with write in method `SessionNode.deepClone(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1358.                                 Name name ) {
  1359.           WritableSessionCache session = writableSession(cache);
  1360. >         session.assertInSession(this);
  1361.   
  1362.           // Find the referenced node ...

src/main/java/org/modeshape/jcr/cache/document/BucketedChildReferences.java:273: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `BucketedChildReferences$Bucket BucketedChildReferences.loadBucket(BucketId)` reads without synchronization from container `this.rangeBucketsById` via call to `get`. Potentially races with write in method `BucketedChildReferences.getChildCount(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  271.   
  272.       protected Bucket loadBucket(BucketId bucketId) {
  273. >         Bucket bucket = rangeBucketsById.get(bucketId);
  274.           if (bucket != null) {
  275.               return bucket;

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3310: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Lock AbstractJcrNode.lock(boolean,boolean)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3308.           RepositoryException {
  3309.           // Session's liveness will be checked in 'lockManager()' ...
  3310. >         return session.lockManager().lock(this, isDeep, isSessionScoped, Long.MAX_VALUE, null);
  3311.       }
  3312.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Lock JcrSystemNode.lock(boolean,boolean)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/JcrLockManager.java:238: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Lock JcrLockManager.lock(String,boolean,boolean,long,String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  236.           throws LockException, PathNotFoundException, AccessDeniedException, InvalidItemStateException, RepositoryException {
  237.           AbstractJcrNode node = session.node(session.absolutePathFor(absPath));
  238. >         return lock(node, isDeep, isSessionScoped, timeoutHint, ownerInfo);
  239.       }
  240.   

src/main/java/org/modeshape/jcr/JcrLockManager.java:237: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Lock JcrLockManager.lock(String,boolean,boolean,long,String)` indirectly reads without synchronization from `nodeKey.workspaceKey`. Potentially races with write in method `JcrLockManager.getLockIfExists(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  235.                         String ownerInfo )
  236.           throws LockException, PathNotFoundException, AccessDeniedException, InvalidItemStateException, RepositoryException {
  237. >         AbstractJcrNode node = session.node(session.absolutePathFor(absPath));
  238.           return lock(node, isDeep, isSessionScoped, timeoutHint, ownerInfo);
  239.       }

src/main/java/org/modeshape/jcr/JcrLockManager.java:274: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `MutableCachedNode MutableCachedNode.createChild(SessionCache,NodeKey,Name,Iterable)` of un-annotated interface `org.modeshape.jcr.cache.MutableCachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  272.   
  273.           // Try to obtain the lock ...
  274. >         ModeShapeLock lock = lockManager.lock(session, node.node(), isDeep, isSessionScoped, timeoutHint, ownerInfo);
  275.           String token = lock.getLockToken();
  276.           lockTokens.add(token);

src/main/java/org/modeshape/jcr/JcrLockManager.java:277: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Lock JcrLockManager.lock(AbstractJcrNode,boolean,boolean,long,String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  275.           String token = lock.getLockToken();
  276.           lockTokens.add(token);
  277. >         return lock.lockFor(session);
  278.       }
  279.   

src/main/java/org/modeshape/jcr/RepositoryLockManager.java:353: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `MutableCachedNode MutableCachedNode.createChild(SessionCache,NodeKey,Name,Iterable)` of un-annotated interface `org.modeshape.jcr.cache.MutableCachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  351.           try {
  352.               // Store the lock within the system area ...
  353. >             system.storeLock(lock);
  354.   
  355.               // Update the persistent node ...

src/main/java/org/modeshape/jcr/JcrWorkspace.java:574: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `JcrLockManager JcrWorkspace.lockManager()` reads without synchronization from `this.lockManager`. Potentially races with write in method `JcrWorkspace.lockManager()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  572.   
  573.       final JcrLockManager lockManager() {
  574. >         if (lockManager == null) {
  575.               try {
  576.                   lock.lock();

src/main/java/org/modeshape/jcr/RepositoryLockManager.java:243: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `NodeKey RepositoryLockManager.lockedNodeKeyFromLockKey(NodeKey)` indirectly writes to field `key.identifier` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  241.       protected final NodeKey lockedNodeKeyFromLockKey( NodeKey key ) {
  242.           // The identifier of the lock key contains "mode:lock-" followed by the full key of the locked node ...
  243. >         String identifier = key.getIdentifier();
  244.           return new NodeKey(identifier.substring(KEY_OFFSET));
  245.       }

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:404: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getString(NamespaceRegistry)` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  402.                   SessionNode node = changedNodes.get(key);
  403.                   if (node != null && node.hasChanges()) {
  404. >                     SAVE_LOGGER.trace(" #{0} {1}", s, node.getString(registry));
  405.                       ++changes;
  406.                   }

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:402: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WritableSessionCache.logChangesBeingSaved(Iterable,Map,Iterable,Map)` reads without synchronization from `this.changedNodes`. Potentially races with write in method `WritableSessionCache.save()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  400.                                 s, txn, username, id);
  401.               for (NodeKey key : firstNodesInOrder) {
  402. >                 SessionNode node = changedNodes.get(key);
  403.                   if (node != null && node.hasChanges()) {
  404.                       SAVE_LOGGER.trace(" #{0} {1}", s, node.getString(registry));

src/main/java/org/modeshape/jcr/bus/ClusteredChangeBus.java:138: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String ChangeSet.getProcessKey()` of un-annotated interface `org.modeshape.jcr.cache.change.ChangeSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  136.                            changeSet.getWorkspaceName(),
  137.                            changeSet.getUserId(),
  138. >                          changeSet.getProcessKey(),
  139.                            changeSet.getTimestamp());
  140.   

src/main/java/org/modeshape/jcr/bus/ClusteredChangeBus.java:126: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String ChangeSet.getProcessKey()` of un-annotated interface `org.modeshape.jcr.cache.change.ChangeSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  124.                            changeSet.getWorkspaceName(),
  125.                            changeSet.getUserData(),
  126. >                          changeSet.getProcessKey(),
  127.                            changeSet.getTimestamp());
  128.           }

src/main/java/org/modeshape/jcr/value/binary/CassandraBinaryStore.java:199: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void CassandraBinaryStore.markAsUnused(Iterable)` reads without synchronization from `this.session`. Potentially races with write in method `CassandraBinaryStore.start()`.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  197.       @Override
  198.       public void markAsUnused( Iterable<BinaryKey> keys ) throws BinaryStoreException {
  199. >         PreparedStatement preparedStatement = session.prepare("UPDATE modeshape.binary SET usage = ?, usage_time = ? WHERE cid = ?");
  200.           try {
  201.               for (BinaryKey key : keys) {

src/main/java/org/modeshape/jcr/value/binary/DatabaseBinaryStore.java:236: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void DatabaseBinaryStore.markAsUnused(Iterable)` indirectly reads without synchronization from `this.dataSource`. Potentially races with write in method `DatabaseBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  234.       @Override
  235.       public void markAsUnused( final Iterable<BinaryKey> keys ) throws BinaryStoreException {
  236. >         dbCall(new DBCallable<Void>() {
  237.               @Override
  238.               public Void execute( Connection connection ) throws Exception {

src/main/java/org/modeshape/jcr/value/binary/MongodbBinaryStore.java:251: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MongodbBinaryStore.markAsUnused(Iterable)` reads without synchronization from `this.db`. Potentially races with write in method `MongodbBinaryStore.start()`.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  249.           for (BinaryKey key : keys) {
  250.               // silently ignore if content does not exist
  251. >             if (db.collectionExists(key.toString())) {
  252.                   DBCollection content = db.getCollection(key.toString());
  253.                   setAttribute(content, FIELD_UNUSED, true);

src/main/java/org/modeshape/jcr/value/binary/MongodbBinaryStore.java:253: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Object DBObject.get(String)` of un-annotated interface `com.mongodb.DBObject`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`.
  251.               if (db.collectionExists(key.toString())) {
  252.                   DBCollection content = db.getCollection(key.toString());
  253. >                 setAttribute(content, FIELD_UNUSED, true);
  254.                   setAttribute(content, FIELD_UNUSED_SINCE, System.currentTimeMillis());
  255.               }

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:324: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void InfinispanBinaryStore.markAsUnused(Iterable)` reads with synchronization from `this.metadataCache`. Potentially races with unsynchronized write in method `InfinispanBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  322.               try {
  323.                   final String metadataKey = metadataKeyFrom(binaryKey);
  324. >                 final Metadata metadata = metadataCache.get(metadataKey);
  325.                   // we use the copy of the original object to avoid changes cache values in case of errors
  326.                   if (metadata == null || metadata.isUnused()) {

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:321: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void InfinispanBinaryStore.markAsUnused(Iterable)` reads with synchronization from `this.lockFactory`. Potentially races with unsynchronized write in method `InfinispanBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  319.               // Try to mark the metadata as unused. We loop here in case other processes (not other threads in this process,
  320.               // which are handled via locks) are doing the same thing.
  321. >             Lock lock = lockFactory.writeLock(lockKeyFrom(binaryKey));
  322.               try {
  323.                   final String metadataKey = metadataKeyFrom(binaryKey);

src/main/java/org/modeshape/jcr/value/binary/CassandraBinaryStore.java:190: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void CassandraBinaryStore.markAsUsed(Iterable)` reads without synchronization from `this.session`. Potentially races with write in method `CassandraBinaryStore.start()`.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  188.           try {
  189.               for (BinaryKey key : keys) {
  190. >                 session.execute("UPDATE modeshape.binary SET usage=1 where cid='" + key + "';");
  191.               }
  192.           } catch (RuntimeException e) {

src/main/java/org/modeshape/jcr/value/binary/DatabaseBinaryStore.java:224: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void DatabaseBinaryStore.markAsUsed(Iterable)` indirectly reads without synchronization from `this.dataSource`. Potentially races with write in method `DatabaseBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  222.       @Override
  223.       public void markAsUsed(final Iterable<BinaryKey> keys ) throws BinaryStoreException {
  224. >         dbCall(new DBCallable<Object>() {
  225.               @SuppressWarnings( "synthetic-access" )
  226.               @Override

src/main/java/org/modeshape/jcr/value/binary/MongodbBinaryStore.java:239: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MongodbBinaryStore.markAsUsed(Iterable)` reads without synchronization from `this.db`. Potentially races with write in method `MongodbBinaryStore.start()`.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  237.       public void markAsUsed( Iterable<BinaryKey> keys ) {
  238.           for (BinaryKey key : keys) {
  239. >             if (db.collectionExists(key.toString())) {
  240.                   DBCollection content = db.getCollection(key.toString());
  241.                   setAttribute(content, FIELD_UNUSED, false);

src/main/java/org/modeshape/jcr/value/binary/MongodbBinaryStore.java:241: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Object DBObject.get(String)` of un-annotated interface `com.mongodb.DBObject`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`.
  239.               if (db.collectionExists(key.toString())) {
  240.                   DBCollection content = db.getCollection(key.toString());
  241. >                 setAttribute(content, FIELD_UNUSED, false);
  242.                   setAttribute(content, FIELD_UNUSED_SINCE, null);
  243.               }

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:297: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void InfinispanBinaryStore.markAsUsed(Iterable)` reads with synchronization from `this.lockFactory`. Potentially races with unsynchronized write in method `InfinispanBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  295.       public void markAsUsed( Iterable<BinaryKey> keys ) throws BinaryStoreException {
  296.           for (BinaryKey binaryKey : keys) {
  297. >             Lock lock = lockFactory.writeLock(lockKeyFrom(binaryKey));
  298.               try {
  299.                   final String metadataKey = metadataKeyFrom(binaryKey);

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:300: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void InfinispanBinaryStore.markAsUsed(Iterable)` reads with synchronization from `this.metadataCache`. Potentially races with unsynchronized write in method `InfinispanBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  298.               try {
  299.                   final String metadataKey = metadataKeyFrom(binaryKey);
  300. >                 final Metadata metadata = metadataCache.get(metadataKey);
  301.                   // we use the copy of the original object to avoid changes cache values in case of errors
  302.                   if (metadata == null) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3016: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `NodeIterator AbstractJcrNode.merge(String,boolean)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3014.           CheckArg.isNotNull(srcWorkspace, "srcWorkspace");
  3015.           checkNotProtected();
  3016. >         return versionManager().merge(this, srcWorkspace, bestEffort, false);
  3017.       }
  3018.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3015: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean NodeTypes$ReusableNodeDefinitionSet.appliesTo(NodeTypes,Name,Set)` of un-annotated interface `org.modeshape.jcr.NodeTypes$ReusableNodeDefinitionSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  3013.   
  3014.           CheckArg.isNotNull(srcWorkspace, "srcWorkspace");
  3015. >         checkNotProtected();
  3016.           return versionManager().merge(this, srcWorkspace, bestEffort, false);
  3017.       }

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `NodeIterator JcrSystemNode.merge(String,boolean)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/mimetype/TikaMimeTypeDetector.java:62: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `InputStream Binary.getStream()` of un-annotated interface `javax.jcr.Binary`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  60.           }
  61.   
  62. >         InputStream stream = binaryValue.getStream();
  63.           if (stream instanceof SelfClosingInputStream) {
  64.               //we need to avoid the SelfClosingInputStream because Tika will read and mark from this stream multiple times

src/main/java/org/modeshape/jcr/JcrWorkspace.java:555: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void Transactions$Transaction.commit()` of un-annotated interface `org.modeshape.jcr.txn.Transactions$Transaction`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  553.           JcrSession moveSession = this.session.spawnSession(false);
  554.           moveSession.move(srcAbsPath, destAbsPath);
  555. >         moveSession.save();
  556.       }
  557.   

src/main/java/org/modeshape/jcr/JcrWorkspace.java:554: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.move(String,String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  552.           // Create a new JCR session, perform the move, and then save the session ...
  553.           JcrSession moveSession = this.session.spawnSession(false);
  554. >         moveSession.move(srcAbsPath, destAbsPath);
  555.           moveSession.save();
  556.       }

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1232: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `NodeCache NodeCache.unwrap()` of un-annotated interface `org.modeshape.jcr.cache.NodeCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1230.   
  1231.           // Remove the child from this node ...
  1232. >         WritableSessionCache session = writableSession(cache);
  1233.           session.assertInSession(this);
  1234.           SessionNode node = removeChildFromNode(session, key);

src/main/java/org/modeshape/jcr/value/binary/CompositeBinaryStore.java:203: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void CompositeBinaryStore.moveValue(BinaryKey,String)` indirectly writes to field `this.defaultBinaryStore` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.BinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  201.       public void moveValue( BinaryKey key,
  202.                              String destination ) throws BinaryStoreException {
  203. >         moveValue(key, null, destination);
  204.       }
  205.   

src/main/java/org/modeshape/jcr/value/binary/CompositeBinaryStore.java:173: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `BinaryKey CompositeBinaryStore.moveValue(BinaryKey,String,String)` indirectly writes to field `this.defaultBinaryStore` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.BinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  171.               sourceStore = findBinaryStoreContainingKey(key);
  172.           } else {
  173. >             sourceStore = selectBinaryStore(source);
  174.           }
  175.   

src/main/java/org/modeshape/jcr/value/binary/CompositeBinaryStore.java:188: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `BinaryKey BinaryValue.getKey()` of un-annotated interface `org.modeshape.jcr.value.BinaryValue`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.BinaryStore` is annotated `@ThreadSafe`.
  186.           }
  187.   
  188. >         final BinaryValue binaryValue = storeValue(sourceStore.getInputStream(key), destination, false);
  189.           sourceStore.markAsUnused(java.util.Collections.singleton(key));
  190.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:212: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `MutableCachedNode SessionCache.mutable(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  210.   
  211.       protected final MutableCachedNode mutable() {
  212. >         return sessionCache().mutable(key);
  213.       }
  214.   

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:99: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `MutableCachedNode WritableSessionCache.mutable(NodeKey)` indirectly reads with synchronization from `this.changedNodes`. Potentially races with unsynchronized write in method `WritableSessionCache.clearState()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  97.    * A writable {@link SessionCache} implementation capable of making transient changes and saving them.
  98.    */
  99. > @ThreadSafe
  100.   public class WritableSessionCache extends AbstractSessionCache {
  101.   

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:191: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `SessionNode WritableSessionCache.mutable(NodeKey)` reads with synchronization from `this.changedNodes`. Potentially races with unsynchronized write in method `WritableSessionCache.clearState()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  189.           try {
  190.               lock.lock();
  191. >             sessionNode = changedNodes.get(key);
  192.           } finally {
  193.               lock.unlock();

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:221: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `CachedNode SessionCache.getNode(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  219.       protected final MutableCachedNode mutableParent() throws RepositoryException {
  220.           SessionCache cache = sessionCache();
  221. >         return cache.mutable(parentKey());
  222.       }
  223.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:243: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Name CachedNode.getName(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  241.   
  242.       protected Name name() throws RepositoryException {
  243. >         return node().getName(sessionCache());
  244.       }
  245.   

src/main/java/org/modeshape/jcr/JcrSharedNode.java:97: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Name JcrSharedNode.name()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  95.       @Override
  96.       protected Name name() throws RepositoryException {
  97. >         return segment().getName();
  98.       }
  99.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:201: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `CachedNode SessionCache.getNode(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  199.        */
  200.       protected final CachedNode node() throws ItemNotFoundException, InvalidItemStateException {
  201. >         CachedNode node = sessionCache().getNode(key);
  202.           if (node == null) {
  203.               if (sessionCache().isDestroyed(key)) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2907: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean NodeTypes$ReusableNodeDefinitionSet.appliesTo(NodeTypes,Name,Set)` of un-annotated interface `org.modeshape.jcr.NodeTypes$ReusableNodeDefinitionSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  2905.               SiblingCounter siblingCounter = SiblingCounter.alter(SiblingCounter.create(parent, cache), -1);
  2906.               boolean skipProtected = false;
  2907. >             NodeDefinitionSet childDefns = nodeTypes.findChildNodeDefinitions(parentPrimaryType, parentMixins);
  2908.               JcrNodeDefinition childDefn = childDefns.findBestDefinitionForChild(nodeName, primaryType, skipProtected,
  2909.                                                                                   siblingCounter);

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2869: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean NodeTypes$ReusableNodeDefinitionSet.appliesTo(NodeTypes,Name,Set)` of un-annotated interface `org.modeshape.jcr.NodeTypes$ReusableNodeDefinitionSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  2867.               SiblingCounter siblingCounter = SiblingCounter.create(parent, cache);
  2868.               boolean skipProtected = true;
  2869. >             NodeDefinitionSet childDefns = nodeTypes.findChildNodeDefinitions(parentPrimaryType, parentMixins);
  2870.               JcrNodeDefinition childDefn = childDefns.findBestDefinitionForChild(nodeName, primaryType, skipProtected,
  2871.                                                                                   siblingCounter);

src/main/java/org/modeshape/jcr/JcrRootNode.java:41: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `NodeDefinitionId JcrRootNode.nodeDefinitionId()` reads without synchronization from `this.rootNodeDefnId`. Potentially races with write in method `JcrRootNode.nodeDefinitionId()`.
 Reporting because a superclass `class org.modeshape.jcr.AbstractJcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  39.       @Override
  40.       NodeDefinitionId nodeDefinitionId() throws RepositoryException {
  41. >         if (rootNodeDefnId == null) {
  42.               // Idempotent so we can do this without a lock ...
  43.               rootNodeDefnId = session.workspace().nodeTypeManager().getRootNodeDefinition().getId();

src/main/java/org/modeshape/jcr/JcrRootNode.java:43: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `NodeDefinitionId JcrRootNode.nodeDefinitionId()` writes to field `this.rootNodeDefnId` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.AbstractJcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  41.           if (rootNodeDefnId == null) {
  42.               // Idempotent so we can do this without a lock ...
  43. >             rootNodeDefnId = session.workspace().nodeTypeManager().getRootNodeDefinition().getId();
  44.           }
  45.           return rootNodeDefnId;

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:309: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  307.        */
  308.       protected CachedNode nodeInWorkspace( AbstractSessionCache session ) {
  309. >         return isNew() ? null : session.getWorkspace().getNode(key);
  310.       }
  311.   

src/main/java/org/modeshape/jcr/cache/change/RecordingChanges.java:132: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Path$Segment Path.getLastSegment()` of un-annotated interface `org.modeshape.jcr.value.Path`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  130.                                Name primaryType,
  131.                                Set<Name> mixinTypes ) {
  132. >         events.add(new NodeRenamed(key, newPath, oldName, filterName(primaryType), filterNameSet(mixinTypes)));
  133.       }
  134.   

src/main/java/org/modeshape/jcr/JcrWorkspace.java:628: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `JcrNodeTypeManager JcrWorkspace.nodeTypeManager()` reads without synchronization from `this.nodeTypeManager`. Potentially races with write in method `JcrWorkspace.getNodeTypeManager()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  626.   
  627.       final JcrNodeTypeManager nodeTypeManager() {
  628. >         if (nodeTypeManager == null) {
  629.               try {
  630.                   lock.lock();

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:158: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `NodeTypes RepositoryEnvironment.nodeTypes()` of un-annotated interface `org.modeshape.jcr.cache.RepositoryEnvironment`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  156.           RepositoryEnvironment repositoryEnvironment = workspaceCache().repositoryEnvironment();
  157.           if (repositoryEnvironment != null) {
  158. >             return repositoryEnvironment.nodeTypes();
  159.           }
  160.           return null;

src/main/java/org/modeshape/jcr/RepositoryIndexManager.java:206: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void IndexProvider$ProvidedIndexOperation.apply(String,IndexProvider$AtomicIndex)` of un-annotated interface `org.modeshape.jcr.spi.index.provider.IndexProvider$ProvidedIndexOperation`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  204.           // Notify all of the providers about the change in node types ...
  205.           for (IndexProvider provider : providers.values()) {
  206. >             provider.notify(updatedNodeTypes);
  207.           }
  208.       }

src/main/java/org/modeshape/jcr/BackupObserver.java:51: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Set ChangeSet.changedNodes()` of un-annotated interface `org.modeshape.jcr.cache.change.ChangeSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  49.           if (changeSet == null) return;
  50.           // Add all of the changed nodes to the queue ...
  51. >         changedNodes.addAll(changeSet.changedNodes());
  52.   
  53.           // We only care about the binary changes; workspace changes will be handled by always writing out the

src/main/java/org/modeshape/jcr/RepositoryIndexManager.java:600: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `RepositoryIndexManager$ScanningTasks RepositoryIndexManager.notify(ChangeSet)` mutates container `defns` via call to `add` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  598.                               defnsByProvider.put(providerName, defns);
  599.                           }
  600. >                         defns.add(defn);
  601.                       }
  602.                       // Then for each provider ...

src/main/java/org/modeshape/jcr/RepositoryIndexManager.java:575: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `RepositoryIndexManager$ScanningTasks RepositoryIndexManager.notify(ChangeSet)` indirectly mutates container `indexes` via call to `add` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  573.   
  574.               // Refresh the index definitions ...
  575. >             RepositoryIndexes indexes = readIndexDefinitions();
  576.               ScanningTasks feedback = new ScanningTasks();
  577.               if (!indexes.getIndexDefinitions().isEmpty()) {

src/main/java/org/modeshape/jcr/RepositoryIndexManager.java:646: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `RepositoryIndexManager$ScanningTasks RepositoryIndexManager.notify(ChangeSet)` indirectly mutates container `byProviderName` via call to `put` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  644.                           // It's a column definition being removed, so the index is changed ...
  645.                           Name indexName = removedPath.getSegment(3).getName();
  646. >                         changeInfoForProvider(changesByProviderName, providerName).removed(indexName);
  647.                       } else if (removedPath.size() > 3) {
  648.                           // Removing an index (or column definition), but all we care about is the name of the index

src/main/java/org/modeshape/jcr/RepositoryIndexManager.java:675: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `IndexDefinition$IndexKind IndexDefinition.getKind()` of un-annotated interface `org.modeshape.jcr.api.index.IndexDefinition`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  673.           }
  674.           // Refresh the index definitions ...
  675. >         RepositoryIndexes indexes = readIndexDefinitions();
  676.   
  677.           // And notify the affected providers ...

src/main/java/org/modeshape/jcr/RepositoryLockManager.java:510: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void RepositoryLockManager.notify(ChangeSet)` indirectly writes to field `lockKey.identifier` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  508.                           Map<Name, Property> props = added.getProperties();
  509.                           NodeKey lockKey = added.getKey();
  510. >                         ModeShapeLock lock = new ModeShapeLock(lockKey, props);
  511.                           locksByNodeKey.put(lock.getLockedNodeKey(), lock);
  512.                       }

src/main/java/org/modeshape/jcr/RepositoryLockManager.java:494: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String ChangeSet.getProcessKey()` of un-annotated interface `org.modeshape.jcr.cache.change.ChangeSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  492.               return;
  493.           }
  494. >         if (processId.equals(changeSet.getProcessKey())) {
  495.               // We generated these changes, so skip them ...
  496.               return;

src/main/java/org/modeshape/jcr/RepositoryNodeTypeManager.java:724: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void RepositoryNodeTypeManager.notify(ChangeSet)` indirectly reads with synchronization from `mutableTable.extraColumns`. Potentially races with unsynchronized write in method `RepositoryNodeTypeManager.getRepositorySchemata()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  722.   
  723.               // Unregister those that were removed ...
  724. >             unregisterNodeType(nodeTypesToDelete, false);
  725.           } catch (Throwable e) {
  726.               logger.error(e, JcrI18n.errorRefreshingNodeTypes, repository.name());

src/main/java/org/modeshape/jcr/RepositoryNodeTypeManager.java:687: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Name Path$Segment.getName()` of un-annotated interface `org.modeshape.jcr.value.Path$Segment`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  685.                   if (nodeTypesPath.isAncestorOf(removedPath)) {
  686.                       // Get the name of the node type ...
  687. >                     Name nodeTypeName = removedPath.getSegment(2).getName();
  688.                       if (removedPath.size() == 3) {
  689.                           nodeTypesToDelete.add(nodeTypeName);

src/main/java/org/modeshape/jcr/RepositoryStatistics.java:381: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Set ChangeSet.changedNodes()` of un-annotated interface `org.modeshape.jcr.cache.change.ChangeSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  379.           // Track all changes, even those that originate in remote processes ...
  380.   
  381. >         increment(ValueMetric.NODE_CHANGES, changeSet.changedNodes().size());
  382.           if (changeSet.getWorkspaceName() == null) {
  383.               // This is a change in the workspaces or repository metadata ...

src/main/java/org/modeshape/jcr/bus/ClusteredChangeBus.java:108: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String ChangeSet.getProcessKey()` of un-annotated interface `org.modeshape.jcr.cache.change.ChangeSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  106.               // We are in clustered mode, but there is only one participant in the cluster (us).
  107.               // So short-circuit the cluster and just notify the local observers ...
  108. >             consume(changeSet);
  109.               return;
  110.           }

src/main/java/org/modeshape/jcr/bus/RepositoryChangeBus.java:190: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void ChangeSetListener.notify(ChangeSet)` of un-annotated interface `org.modeshape.jcr.cache.change.ChangeSetListener`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.cache.change.Observable` is annotated `@ThreadSafe`.
  188.           for (ChangeSetListener listener : inThreadListeners) {
  189.               try {
  190. >                 listener.notify(changeSet);
  191.               } catch (RuntimeException e) {
  192.                   if (shutdown.get()) {

src/main/java/org/modeshape/jcr/journal/ClusteredJournal.java:71: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String ChangeSet.getWorkspaceName()` of un-annotated interface `org.modeshape.jcr.cache.change.ChangeSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  69.       @Override
  70.       public void notify( ChangeSet changeSet ) {
  71. >         localJournal.notify(changeSet);
  72.       }
  73.   

src/main/java/org/modeshape/jcr/journal/LocalJournal.java:172: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String ChangeSet.getWorkspaceName()` of un-annotated interface `org.modeshape.jcr.cache.change.ChangeSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  170.       public void notify( ChangeSet changeSet ) {
  171.           //do not store records from jcr:system
  172. >         boolean systemWorkspaceChanges = RepositoryConfiguration.SYSTEM_WORKSPACE_NAME.equalsIgnoreCase(changeSet.getWorkspaceName());
  173.           if (changeSet.isEmpty() || systemWorkspaceChanges) {
  174.               return;

src/main/java/org/modeshape/jcr/spi/index/provider/IndexProvider.java:1428: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Name Property.getName()` of un-annotated interface `org.modeshape.jcr.value.Property`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1426.               if (changeSet.getWorkspaceName() != null) {
  1427.                   // This is a change in the content of a workspace ...
  1428. >                 managedIndex.getIndexChangeAdapter().notify(changeSet);
  1429.               }
  1430.           }

src/main/java/org/modeshape/jcr/JcrWorkspace.java:648: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `JcrObservationManager JcrWorkspace.observationManager()` reads without synchronization from `this.observationManager`. Potentially races with write in method `JcrWorkspace.getObservationManager()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  646.   
  647.       final JcrObservationManager observationManager() {
  648. >         if (observationManager == null && session.isLive()) {
  649.               try {
  650.                   lock.lock();

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1371: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.orderBefore(String,String)` indirectly writes to field `nodeType.key.sourceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1369.   
  1370.           // Make sure ordering is supported on this node ...
  1371. >         if (!getPrimaryNodeType().hasOrderableChildNodes()) {
  1372.               String msg = JcrI18n.notOrderable.text(getPrimaryNodeType().getName(), location());
  1373.               throw new UnsupportedRepositoryOperationException(msg);

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1385: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReference ChildReferences.getChild(Path$Segment)` of un-annotated interface `org.modeshape.jcr.cache.ChildReferences`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1383.           SessionCache cache = session.cache();
  1384.           ChildReferences childRefs = node().getChildReferences(cache);
  1385. >         ChildReference srcRef = childRefs.getChild(srcPath.getLastSegment());
  1386.           if (srcRef == null) {
  1387.               String workspaceName = workspaceName();

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1381: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.orderBefore(String,String)` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1379.           }
  1380.   
  1381. >         session.checkPermission(this, ModeShapePermissions.ADD_NODE);
  1382.   
  1383.           SessionCache cache = session.cache();

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrSystemNode.orderBefore(String,String)` indirectly writes to field `nodeType.key.sourceKey` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/JcrSharedNode.java:77: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrNode JcrSharedNode.parent()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  75.   
  76.       protected AbstractJcrNode parent() throws ItemNotFoundException {
  77. >         return session().node(parentKey, null);
  78.       }
  79.   

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:333: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  331.   
  332.       protected CachedNode parent( AbstractSessionCache session ) {
  333. >         NodeKey parentKey = getParentKey(session);
  334.           if (parentKey == null) {
  335.               return null;

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:169: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  167.               return null;
  168.           }
  169. >         CachedNode parent = cache.getNode(parentKey);
  170.           if (parent == null) {
  171.               throw new NodeNotFoundException(parentKey);

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:165: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `CachedNode LazyCachedNode.parent(WorkspaceCache)` indirectly writes to field `this.key.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  163.   
  164.       protected CachedNode parent( WorkspaceCache cache ) {
  165. >         NodeKey parentKey = getParentKey(cache);
  166.           if (parentKey == null) {
  167.               return null;

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:216: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `CachedNode SessionCache.getNode(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  214.   
  215.       protected NodeKey parentKey() throws RepositoryException {
  216. >         return node().getParentKey(sessionCache());
  217.       }
  218.   

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:204: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `ChildReference LazyCachedNode.parentReferenceToSelf(WorkspaceCache)` indirectly writes to field `this.key.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  202.               }
  203.               // Get the current parent to compare with what we've cached ...
  204. >             currentParent = parent(cache);
  205.               if (currentParent == null && prts.isRoot()) {
  206.                   // We are the root and this never changes. Therefore, our 'parentRefToSelf' is always valid ...

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:207: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReference LazyCachedNode$ParentReferenceToSelf.childReferenceInParent()` of un-annotated interface `org.modeshape.jcr.cache.document.LazyCachedNode$ParentReferenceToSelf`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  205.               if (currentParent == null && prts.isRoot()) {
  206.                   // We are the root and this never changes. Therefore, our 'parentRefToSelf' is always valid ...
  207. >                 return prts.childReferenceInParent();
  208.               }
  209.               if (prts.isValid(currentParent)) {

src/main/java/org/modeshape/jcr/query/parse/QueryParsers.java:182: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `QueryCommand QueryParser.parseQuery(String,TypeSystem)` of un-annotated interface `org.modeshape.jcr.query.parse.QueryParser`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  180.               throw new IllegalArgumentException(GraphI18n.unknownQueryLanguage.text(language));
  181.           }
  182. >         return parser.parseQuery(query, typeSystem);
  183.       }
  184.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:226: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `CachedNode SessionCache.getNode(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  224.       @Override
  225.       Path path() throws ItemNotFoundException, InvalidItemStateException {
  226. >         return node().getPath(sessionCache());
  227.       }
  228.   

src/main/java/org/modeshape/jcr/JcrSharedNode.java:87: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Path JcrSharedNode.path()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  85.       @Override
  86.       Path path() throws ItemNotFoundException, InvalidItemStateException {
  87. >         AbstractJcrNode parent = parent();
  88.           CachedNode node = parent.node();
  89.           SessionCache cache = session.cache();

src/main/java/org/modeshape/jcr/JcrSharedNode.java:90: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReference ChildReferences.getChild(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.ChildReferences`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  88.           CachedNode node = parent.node();
  89.           SessionCache cache = session.cache();
  90. >         ChildReference childRef = node.getChildReferences(cache).getChild(sharedSet.key());
  91.           Path parentPath = parent.path();
  92.           return session().pathFactory().create(parentPath, childRef.getSegment());

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:1017: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `ChangeSet WritableSessionCache.persistChanges(Iterable,WorkspaceCache)` indirectly mutates container `parents` via call to `remove` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1015.                       doc = Schematic.newDocument();
  1016.                       translator.setKey(doc, key);
  1017. >                     translator.setParents(doc, newParent, null, additionalParents);
  1018.                       translator.addInternalProperties(doc, node.getAddedInternalProperties());
  1019.                       

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:1325: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `ChangeSet WritableSessionCache.persistChanges(Iterable,WorkspaceCache)` reads with synchronization from `this.replacedNodes`. Potentially races with unsynchronized write in method `WritableSessionCache.clearState()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1323.                       // We need to create the schematic entry for the new node ...
  1324.                       if (documentStore.storeDocument(keyStr, doc) != null) {
  1325. >                         if (replacedNodes != null && replacedNodes.contains(key)) {
  1326.                               // Then a node is being removed and recreated with the same key ...
  1327.                               documentStore.localStore().put(keyStr, doc);

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:982: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `ChangeSet WritableSessionCache.persistChanges(Iterable,WorkspaceCache)` reads with synchronization from container `this.referrerChangesForRemovedNodes` via call to `get`. Potentially races with unsynchronized write in method `WritableSessionCache.clearState(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  980.   
  981.                       // if there were any referrer changes for the removed nodes, we need to process them
  982. >                     ReferrerChanges referrerChanges = referrerChangesForRemovedNodes.get(key);
  983.                       if (referrerChanges != null) {
  984.                           EditableDocument doc = documentStore.edit(keyStr, false, acquireLock);

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:1083: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `ChangeSet WritableSessionCache.persistChanges(Iterable,WorkspaceCache)` indirectly mutates container `segments` via call to `add` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1081.                       if (mixinChanges != null && !mixinChanges.isEmpty()) {
  1082.                           Property oldProperty = translator.getProperty(doc, JcrLexicon.MIXIN_TYPES);
  1083. >                         translator.addPropertyValues(doc, JcrLexicon.MIXIN_TYPES, true, mixinChanges.getAdded(),
  1084.                                                        unusedBinaryKeys, usedBinaryKeys);
  1085.                           translator.removePropertyValues(doc, JcrLexicon.MIXIN_TYPES, mixinChanges.getRemoved(), unusedBinaryKeys,

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:1085: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `ChangeSet WritableSessionCache.persistChanges(Iterable,WorkspaceCache)` indirectly mutates container `array` via call to `remove` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1083.                           translator.addPropertyValues(doc, JcrLexicon.MIXIN_TYPES, true, mixinChanges.getAdded(),
  1084.                                                        unusedBinaryKeys, usedBinaryKeys);
  1085. >                         translator.removePropertyValues(doc, JcrLexicon.MIXIN_TYPES, mixinChanges.getRemoved(), unusedBinaryKeys,
  1086.                                                           usedBinaryKeys);
  1087.                           // the property was changed ...

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:1064: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `EditableArray EditableArray.addStringIfAbsent(String)` of un-annotated interface `org.infinispan.schematic.document.EditableArray`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1062.                           NodeKey oldParentKey = persisted.getParentKey(persistedCache);
  1063.                           if (!oldParentKey.equals(newParent) || (additionalParents != null && !additionalParents.isEmpty())) {
  1064. >                             translator.setParents(doc, node.newParent(), oldParentKey, additionalParents);
  1065.                           }
  1066.                           // We only want to fire the event if the node we're working with is in the same workspace as the current

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:1448: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `ChangeSet WritableSessionCache.persistChanges(Iterable,WorkspaceCache)` reads with synchronization from container `this.changedNodes` via call to `keySet`. Potentially races with unsynchronized write in method `WritableSessionCache.clearState(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1446.           }
  1447.   
  1448. >         changes.setChangedNodes(changedNodes.keySet()); // don't need to make a copy
  1449.           changes.freeze(userId, userData, timestamp);
  1450.           return changes;

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:962: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `ChangeSet WritableSessionCache.persistChanges(Iterable,WorkspaceCache)` indirectly reads with synchronization from `this.changedNodes`. Potentially races with unsynchronized write in method `WritableSessionCache.clearState()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  960.                       Path path = workspacePaths.getPath(persisted);
  961.                       NodeKey parentKey = persisted.getParentKey(persistedCache);
  962. >                     CachedNode parent = getNode(parentKey);
  963.                       Name parentPrimaryType;
  964.                       Set<Name> parentMixinTypes;

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:403: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Object MarshalledEntry.getKey()` of un-annotated interface `org.infinispan.marshall.core.MarshalledEntry`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.infinispan.persistence.spi.AdvancedCacheLoader$CacheLoaderTask` is annotated `@ThreadSafe`.
  401.                       public void processEntry( MarshalledEntry<Object, Object> marshalledEntry,
  402.                                                 AdvancedCacheLoader.TaskContext taskContext ) {
  403. >                         Object key = marshalledEntry.getKey();
  404.                           if (!(key instanceof String)) {
  405.                               return;

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:590: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Object MarshalledEntry.getKey()` of un-annotated interface `org.infinispan.marshall.core.MarshalledEntry`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.infinispan.persistence.spi.AdvancedCacheLoader$CacheLoaderTask` is annotated `@ThreadSafe`.
  588.                       public void processEntry( MarshalledEntry<Object, Object> marshalledEntry,
  589.                                                 AdvancedCacheLoader.TaskContext taskContext ) {
  590. >                         Object key = marshalledEntry.getKey();
  591.                           if (!(key instanceof String)) {
  592.                               return;

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2203: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `PropertyDefinition Property.getDefinition()` of un-annotated interface `javax.jcr.Property`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  2201.                   if (prop.getType() == referenceType) {
  2202.                       if (propertyName != null && !propertyName.equals(prop.getName())) continue;
  2203. >                     if (prop.getDefinition().isMultiple()) {
  2204.                           for (Value value : prop.getValues()) {
  2205.                               if (id.equals(value.getString())) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:458: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `JcrPropertyDefinition AbstractJcrNode.propertyDefinitionFor(Property,Name,Set,NodeTypes)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  456.           boolean single = property.isSingle();
  457.           boolean skipProtected = false;
  458. >         JcrPropertyDefinition defn = findBestPropertyDefinition(primaryType, mixinTypes, property, single, skipProtected, false,
  459.                                                                   nodeTypes);
  460.           if (defn != null) return defn;

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:472: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Set CachedNode.getMixinTypes(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  470.           CachedNode node = sessionCache().getNode(key);
  471.           String ptype = readable(node.getPrimaryType(sessionCache()));
  472. >         String mixins = readable(node.getMixinTypes(sessionCache()));
  473.           String pstr = property.getString(session.namespaces());
  474.           throw new ConstraintViolationException(JcrI18n.propertyNoLongerHasValidDefinition.text(pstr, loc, ptype, mixins));

src/main/java/org/modeshape/jcr/RepositoryIndexManager.java:816: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReference ChildReferences.getChild(Name)` of un-annotated interface `org.modeshape.jcr.cache.ChildReferences`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  814.               SessionCache systemCache = repository.createSystemSession(context, false);
  815.               SystemContent system = new SystemContent(systemCache);
  816. >             Collection<IndexDefinition> indexDefns = system.readAllIndexDefinitions(providers.keySet());
  817.               this.indexes = new Indexes(context, indexDefns, nodeTypes);
  818.               return this.indexes;

src/main/java/org/modeshape/jcr/RepositoryIndexManager.java:817: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `RepositoryIndexes RepositoryIndexManager.readIndexDefinitions()` indirectly mutates container `indexes` via call to `add` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  815.               SystemContent system = new SystemContent(systemCache);
  816.               Collection<IndexDefinition> indexDefns = system.readAllIndexDefinitions(providers.keySet());
  817. >             this.indexes = new Indexes(context, indexDefns, nodeTypes);
  818.               return this.indexes;
  819.           } catch (WorkspaceNotFoundException e) {

src/main/java/org/modeshape/jcr/journal/ClusteredJournal.java:190: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean ClusteredJournal.reconciliationCompleted()` reads without synchronization from `this.reconciliationLatch`. Potentially races with write in method `ClusteredJournal.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  188.       
  189.       protected boolean reconciliationCompleted() {
  190. >         return reconciliationLatch == null || reconciliationLatch.getCount() == 0;
  191.       }
  192.   

src/main/java/org/modeshape/jcr/journal/ClusteredJournal.java:154: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `ChangeJournal$Records ClusteredJournal.recordsNewerThan(DateTime,boolean,boolean)` indirectly reads without synchronization from `this.localJournal.records`. Potentially races with write in method `ClusteredJournal.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  152.                                        boolean inclusive,
  153.                                        boolean descendingOrder ) {
  154. >         return localJournal.recordsNewerThan(changeSetTime, inclusive, descendingOrder);
  155.       }
  156.   

src/main/java/org/modeshape/jcr/journal/LocalJournal.java:247: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `ChangeJournal$Records LocalJournal.recordsNewerThan(DateTime,boolean,boolean)` reads without synchronization from `this.records`. Potentially races with write in method `LocalJournal.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  245.           }
  246.   
  247. >         NavigableMap<Long, JournalRecord> subMap = records.tailMap(searchBound, true);
  248.           if (subMap.isEmpty()) {
  249.               return Records.EMPTY;

src/main/java/org/modeshape/jcr/journal/LocalJournal.java:244: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `ChangeJournal$Records LocalJournal.recordsNewerThan(DateTime,boolean,boolean)` reads without synchronization from `this.searchTimeDelta`. Potentially races with write in method `LocalJournal.withSearchTimeDelta(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  242.               //adjust the millis using a delta so that we are sure we catch everything in a cluster which may have differences in
  243.               //clock time
  244. >             searchBound = TIME_BASED_KEYS.getCounterStartingAt(changeSetMillisUTC - searchTimeDelta);
  245.           }
  246.   

src/main/java/org/modeshape/jcr/journal/LocalJournal.java:257: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `long DateTime.getMillisecondsInUtc()` of un-annotated interface `org.modeshape.jcr.api.value.DateTime`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  255.               Long timeBasedKey = timeBasedKeysIterator.next();
  256.               JournalRecord record = subMap.get(timeBasedKey);
  257. >             long recordChangeTimeMillisUTC = record.getChangeTimeMillis();
  258.               if (((recordChangeTimeMillisUTC == changeSetMillisUTC) && inclusive)
  259.                   || recordChangeTimeMillisUTC > changeSetMillisUTC) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2232: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Set CachedNode.getMixinTypes(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  2230.        */
  2231.       protected final NodeIterator referringNodes( ReferenceType referenceType ) throws RepositoryException {
  2232. >         if (!this.isReferenceable()) {
  2233.               return JcrEmptyNodeIterator.INSTANCE;
  2234.           }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3421: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void SessionCache.clear(CachedNode)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  3419.           CachedNode node = node(); // TCK: this should throw an exception if the node has been removed
  3420.           if (!keepChanges) {
  3421. >             session.cache().clear(node);
  3422.           }
  3423.       }

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void SessionCache.clear(CachedNode)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`.
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/RepositoryLockManager.java:123: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReference ChildReferences.getChild(Name)` of un-annotated interface `org.modeshape.jcr.cache.ChildReferences`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  121.               SessionCache systemCache = repository.createSystemSession(repository.context(), false);
  122.               SystemContent system = new SystemContent(systemCache);
  123. >             CachedNode locks = system.locksNode();
  124.               MutableCachedNode mutableLocks = null;
  125.               for (ChildReference ref : locks.getChildReferences(systemCache)) {

src/main/java/org/modeshape/jcr/SystemNamespaceRegistry.java:73: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean SystemNamespaceRegistry.refreshFromSystem()` reads with synchronization from `this.context`. Potentially races with unsynchronized write in method `SystemNamespaceRegistry.setContext(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  71.               lock.lock();
  72.               // Re-read and re-register all of the namespaces ...
  73. >             SessionCache systemCache = repository.createSystemSession(context, false);
  74.               SystemContent system = new SystemContent(systemCache);
  75.               Collection<Namespace> namespaces = system.readAllNamespaces();

src/main/java/org/modeshape/jcr/RepositoryIndexManager.java:233: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean IndexWriter.canBeSkipped()` of un-annotated interface `org.modeshape.jcr.spi.index.IndexWriter`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  231.   
  232.       protected void refreshIndexWriter() {
  233. >         indexWriter = CompositeIndexWriter.create(providers.values());
  234.       }
  235.   

src/main/java/org/modeshape/jcr/JcrRepository.java:909: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrRepository.refreshWorkspaces()` mutates container `this.descriptors` via call to `put` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  907.                   values[i++] = valueFor(factories, workspaceName);
  908.               }
  909. >             descriptors.put(Repository.REPOSITORY_WORKSPACES, values);
  910.           }
  911.       }

src/main/java/org/modeshape/jcr/SystemNamespaceRegistry.java:153: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void SystemNamespaceRegistry.register(Iterable)` indirectly reads with synchronization from `this.context`. Potentially races with unsynchronized write in method `SystemNamespaceRegistry.setContext(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  151.                   urisByPrefix.put(namespace.getPrefix(), namespace.getNamespaceUri());
  152.               }
  153. >             register(urisByPrefix);
  154.           } finally {
  155.               lock.unlock();

src/main/java/org/modeshape/jcr/SystemNamespaceRegistry.java:195: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String SystemNamespaceRegistry.register(String,String)` indirectly reads with synchronization from `this.context`. Potentially races with unsynchronized write in method `SystemNamespaceRegistry.setContext(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  193.               if (!namespaceUri.equals(previousCachedUriForPrefix)) {
  194.                   // And register it in the source ...
  195. >                 SystemContent systemContent = systemContent(false);
  196.                   systemContent.registerNamespaces(Collections.singletonMap(prefix, namespaceUri));
  197.                   systemContent.save();

src/main/java/org/modeshape/jcr/SystemNamespaceRegistry.java:169: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void SystemNamespaceRegistry.register(Map)` indirectly reads with synchronization from `this.context`. Potentially races with unsynchronized write in method `SystemNamespaceRegistry.setContext(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  167.           try {
  168.               lock.lock();
  169. >             SystemContent systemContent = systemContent(false);
  170.               systemContent.registerNamespaces(namespaceUrisByPrefix);
  171.               systemContent.save();

src/main/java/org/modeshape/jcr/RepositoryIndexManager.java:322: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void RepositoryIndexManager.register(IndexProvider)` indirectly reads with synchronization from container `byProvider` via call to `get`. Potentially races with unsynchronized write in method `RepositoryIndexManager.registerIndexes(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  320.   
  321.           // Re-read the index definitions in case there were disabled index definitions that used the now-available provider ...
  322. >         readIndexDefinitions();
  323.   
  324.           // Refresh the index writer ...

src/main/java/org/modeshape/jcr/RepositoryIndexManager.java:436: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void RepositoryIndexManager.registerIndex(IndexDefinition,boolean)` indirectly mutates container `indexes` via call to `add` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  434.                                  boolean allowUpdate )
  435.           throws InvalidIndexDefinitionException, IndexExistsException, RepositoryException {
  436. >         registerIndexes(new IndexDefinition[] {indexDefinition}, allowUpdate);
  437.       }
  438.   

src/main/java/org/modeshape/jcr/RepositoryIndexManager.java:529: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void RepositoryIndexManager.registerIndexes(org.modeshape.jcr.api.index.IndexDefinition[],boolean)` indirectly mutates container `indexes` via call to `add` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  527.   
  528.           // Refresh the immutable snapshot ...
  529. >         this.indexes = readIndexDefinitions();
  530.       }
  531.   

src/main/java/org/modeshape/jcr/RepositoryIndexManager.java:490: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void AbstractProblems.addError(I18n,java.lang.Object[])` of un-annotated interface `org.modeshape.common.collection.AbstractProblems`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  488.                   if (defn.getKind() == IndexKind.NODE_TYPE) {
  489.                       // must be single-column indexes
  490. >                     problems.addError(JcrI18n.nodeTypeIndexMustHaveOneColumn, defn.getName());
  491.                   }
  492.               }

src/main/java/org/modeshape/jcr/JcrNamespaceRegistry.java:391: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String JcrNamespaceRegistry.registerNamespace(String)` indirectly reads without synchronization from `this.session.workspace.nodeTypeManager`. Potentially races with write in method `JcrNamespaceRegistry.unregisterNamespace(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  389.               prefix = registry.getPrefixForNamespaceUri(uri, true);
  390.               // Signal the local node type manager ...
  391. >             session.signalNamespaceChanges(global);
  392.               return prefix;
  393.           } catch (RuntimeException e) {

src/main/java/org/modeshape/jcr/JcrNamespaceRegistry.java:378: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `String JcrNamespaceRegistry.registerNamespace(String)` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  376.                   global = true;
  377.                   try {
  378. >                     session.checkWorkspacePermission(session.workspaceName(), ModeShapePermissions.REGISTER_NAMESPACE);
  379.                   } catch (AccessControlException ace) {
  380.                       throw new AccessDeniedException(ace);

src/main/java/org/modeshape/jcr/JcrWorkspace.java:887: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.reindex()` indirectly writes to field `childKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  885.           session.checkPermission(workspaceName, Path.ROOT_PATH, ModeShapePermissions.INDEX_WORKSPACE);
  886.           // Then reindex ...
  887. >         repository().runningState().queryManager().reindexContent(this);
  888.       }
  889.   

src/main/java/org/modeshape/jcr/JcrWorkspace.java:885: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.reindex()` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  883.       public void reindex() throws RepositoryException {
  884.           // First check permissions ...
  885. >         session.checkPermission(workspaceName, Path.ROOT_PATH, ModeShapePermissions.INDEX_WORKSPACE);
  886.           // Then reindex ...
  887.           repository().runningState().queryManager().reindexContent(this);

src/main/java/org/modeshape/jcr/JcrWorkspace.java:897: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.reindex(String)` indirectly writes to field `childKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  895.               session.checkPermission(workspaceName, path, ModeShapePermissions.INDEX_WORKSPACE);
  896.               // Then reindex ...
  897. >             repository().runningState().queryManager().reindexContent(this, path, Integer.MAX_VALUE);
  898.           } catch (ValueFormatException e) {
  899.               throw new RepositoryException(e.getMessage());

src/main/java/org/modeshape/jcr/JcrWorkspace.java:895: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.reindex(String)` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  893.               // First check permissions ...
  894.               Path path = session.pathFactory().create(pathStr);
  895. >             session.checkPermission(workspaceName, path, ModeShapePermissions.INDEX_WORKSPACE);
  896.               // Then reindex ...
  897.               repository().runningState().queryManager().reindexContent(this, path, Integer.MAX_VALUE);

src/main/java/org/modeshape/jcr/JcrWorkspace.java:934: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Future JcrWorkspace.reindexAsync()` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  932.       public Future<Boolean> reindexAsync() throws RepositoryException {
  933.           // First check permissions ...
  934. >         session.checkPermission(workspaceName, Path.ROOT_PATH, ModeShapePermissions.INDEX_WORKSPACE);
  935.           // Then reindex ...
  936.           return repository().runningState().queryManager().reindexContentAsync(this);

src/main/java/org/modeshape/jcr/JcrWorkspace.java:944: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Future JcrWorkspace.reindexAsync(String)` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  942.               // First check permissions ...
  943.               Path path = session.pathFactory().create(pathStr);
  944. >             session.checkPermission(workspaceName, path, ModeShapePermissions.INDEX_WORKSPACE);
  945.               // Then reindex ...
  946.               return repository().runningState().queryManager().reindexContentAsync(this, path, Integer.MAX_VALUE);

src/main/java/org/modeshape/jcr/JcrWorkspace.java:914: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.reindexSince(long)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  912.           }
  913.           
  914. >         runningState.queryManager().reindexSince(this, timestamp);
  915.       }
  916.   

src/main/java/org/modeshape/jcr/JcrWorkspace.java:906: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.reindexSince(long)` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  904.       public void reindexSince( long timestamp ) throws RepositoryException {
  905.           // First check permissions ...
  906. >         session.checkPermission(workspaceName, Path.ROOT_PATH, ModeShapePermissions.INDEX_WORKSPACE);
  907.           
  908.           // then if the journal is available

src/main/java/org/modeshape/jcr/JcrWorkspace.java:920: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Future JcrWorkspace.reindexSinceAsync(long)` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  918.       public Future<Boolean> reindexSinceAsync( long timestamp ) throws RepositoryException {
  919.           // First check permissions ...
  920. >         session.checkPermission(workspaceName, Path.ROOT_PATH, ModeShapePermissions.INDEX_WORKSPACE);
  921.   
  922.           // then if the journal is available

src/main/java/org/modeshape/jcr/JcrWorkspace.java:928: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Iterator ChangeJournal.changedNodesSince(long)` of un-annotated interface `org.modeshape.jcr.journal.ChangeJournal`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  926.           }
  927.   
  928. >         return runningState.queryManager().reindexSinceAsync(this, timestamp);
  929.       }
  930.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3445: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.remove()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3443.           // Since this node might be shareable, we want to implement 'remove()' by calling 'removeShare()',
  3444.           // which will behave correctly even if it is not shareable ...
  3445. >         removeShare();
  3446.       }
  3447.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrSystemNode.remove()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1588: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1586.               throw new UnsupportedOperationException(JcrI18n.aclsOnExternalNodesNotAllowed.text());
  1587.           }
  1588. >         if (hasACL(cache)) {
  1589.               NodeKey aclNodeKey = getChildReferences(cache).getChild(ModeShapeLexicon.ACCESS_LIST_NODE_NAME).getKey();
  1590.               MutableCachedNode mutableACLNode = cache.mutable(aclNodeKey);

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1101: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1099.           writableSession(cache).assertInSession(this);
  1100.           CachedNode raw = null;
  1101. >         for (Iterator<Property> propertyIterator = getProperties(cache); propertyIterator.hasNext();) {
  1102.               Name name = propertyIterator.next().getName();
  1103.               changedProperties.remove(name);

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1114: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void SessionNode.removeAllProperties(SessionCache)` indirectly mutates container `changes.addedStrong` via call to `put` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1112.                   }
  1113.               }
  1114. >             processPropertyChange(cache, name, null);
  1115.           }
  1116.       }

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:973: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  971.   
  972.       protected void removeAllReferences( SessionCache cache ) {
  973. >         for (Iterator<Property> it = this.getProperties(cache); it.hasNext();) {
  974.               Property property = it.next();
  975.               if (!property.isReference()) {

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:979: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void SessionNode.removeAllReferences(SessionCache)` indirectly mutates container `changes.addedStrong` via call to `put` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  977.               }
  978.   
  979. >             this.addOrRemoveReferrers(cache, null, property, property.getValues(), false);
  980.           }
  981.       }

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1218: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `NodeCache NodeCache.unwrap()` of un-annotated interface `org.modeshape.jcr.cache.NodeCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1216.                                NodeKey key ) {
  1217.           // Remove the child from this node ...
  1218. >         WritableSessionCache session = writableSession(cache);
  1219.           session.assertInSession(this);
  1220.           removeChildFromNode(session, key);

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1253: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1251.           // First, manipulate the child node. But we have to see whether this node is a primary parent or an additional parent ...
  1252.           SessionNode child = session.mutable(childKey);
  1253. >         if (child.getParentKey(session).equals(this.key)) {
  1254.               // The child's parent is this node. If there are additional parents, then we should pick the first additional parent
  1255.               // and use it as the new primary parent ...

src/main/java/org/modeshape/jcr/JcrObservationManager.java:197: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JcrObservationManager.removeEventListener(EventListener)` indirectly reads without synchronization from `this.session.context`. Potentially races with write in method `JcrObservationManager.setUserData(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  195.       @Override
  196.       public void removeEventListener( EventListener listener ) throws RepositoryException {
  197. >         checkSession(); // make sure session is still active
  198.           CheckArg.isNotNull(listener, "listener");
  199.           for (Iterator<JcrListenerAdapter> adapterIterator = listeners.iterator(); adapterIterator.hasNext(); ) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1652: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.removeExistingProperty(Name)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1650.        */
  1651.       final AbstractJcrProperty removeExistingProperty( Name name ) throws VersionException, LockException, RepositoryException {
  1652. >         AbstractJcrProperty existing = getProperty(name);
  1653.           if (existing != null) {
  1654.               existing.remove();

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1654: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `AbstractJcrProperty AbstractJcrNode.removeExistingProperty(Name)` indirectly reads without synchronization from `definition.checker`. Potentially races with write in method `AbstractJcrNode.setProperty(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1652.           AbstractJcrProperty existing = getProperty(name);
  1653.           if (existing != null) {
  1654. >             existing.remove();
  1655.               return existing;
  1656.           }

src/main/java/org/modeshape/jcr/JcrLockManager.java:124: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReference ChildReferences.getChild(Name)` of un-annotated interface `org.modeshape.jcr.cache.ChildReferences`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  122.           // Change the lock to be no longer held by a session ...
  123.           try {
  124. >             if (!lockManager.setHeldBySession(session, lockToken, false)) {
  125.                   // Generally not expected, because if the lock exists we can always change the lock-held value to false
  126.                   // even when it is already false ...

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2634: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AbstractJcrNode.removeMixin(String)` indirectly reads without synchronization from `definition.checker`. Potentially races with write in method `AbstractJcrNode.setProperty(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2632.                       // the mixin type would not have been added due to the conflict
  2633.                       if (propertyDefinition.isMultiple()) {
  2634. >                         match = nodeTypes.findPropertyDefinition(session, primaryTypeName, newMixinNames,
  2635.                                                                    JcrNodeType.RESIDUAL_NAME, property.getValues(), true);
  2636.                       } else {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2678: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.removeMixin(String)` indirectly writes to field `nodeType.key.sourceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2676.                       NodeDefinitionSet childDefns = nodeTypes.findChildNodeDefinitions(primaryTypeName, newMixinNames);
  2677.                       JcrNodeDefinition match = childDefns.findBestDefinitionForChild(JcrNodeType.RESIDUAL_NAME,
  2678. >                                                                                     child.getPrimaryNodeType().getInternalName(),
  2679.                                                                                       skipProtected, siblingCounter);
  2680.                       if (match == null) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2617: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.removeMixin(String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2615.               // match the residual definition for the node.
  2616.               // ------------------------------------------------------------------------------
  2617. >             for (PropertyIterator iter = getProperties(); iter.hasNext();) {
  2618.                   javax.jcr.Property property = iter.nextProperty();
  2619.                   PropertyDefinition propertyDefinition = property.getDefinition();

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2637: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.removeMixin(String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2635.                                                                    JcrNodeType.RESIDUAL_NAME, property.getValues(), true);
  2636.                       } else {
  2637. >                         match = nodeTypes.findPropertyDefinition(session, primaryTypeName, newMixinNames,
  2638.                                                                    JcrNodeType.RESIDUAL_NAME, property.getValue(), true, true);
  2639.                       }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2568: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.removeMixin(String)` indirectly writes to field `parentKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2566.           if (JcrMixLexicon.SHAREABLE.equals(removedMixinName) && isShareable()) {
  2567.               // Can only remove the shareable mixin if there are no other shared nodes
  2568. >             NodeIterator shared = getSharedSet();
  2569.               long numShared = shared.getSize();
  2570.               if (numShared > 1L) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2553: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean NodeTypes$ReusableNodeDefinitionSet.appliesTo(NodeTypes,Name,Set)` of un-annotated interface `org.modeshape.jcr.NodeTypes$ReusableNodeDefinitionSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  2551.           checkSession();
  2552.           checkForLock();
  2553. >         checkForCheckedOut();
  2554.           session.checkPermission(this, ModeShapePermissions.SET_PROPERTY);
  2555.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2552: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.removeMixin(String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2550.   
  2551.           checkSession();
  2552. >         checkForLock();
  2553.           checkForCheckedOut();
  2554.           session.checkPermission(this, ModeShapePermissions.SET_PROPERTY);

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2592: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.removeMixin(String)` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2590.               Lock lock = getLockIfExists();
  2591.               if (lock != null) {
  2592. >                 unlock();
  2593.               }
  2594.           }

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrSystemNode.removeMixin(String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:587: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ExecutionContext SessionCache.getContext()` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  585.                       return;
  586.                   }
  587. >                 Property mixinTypes = cache.getContext().getPropertyFactory().create(JcrLexicon.MIXIN_TYPES, values);
  588.                   Property existing2 = changedProperties().put(mixinTypes.getName(), mixinTypes);
  589.                   if (existing2 == existing) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:535: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `MutableCachedNode SessionCache.mutable(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  533.       boolean removeProperty( AbstractJcrProperty property ) {
  534.           if (jcrProperties.remove(property.name(), property)) {
  535. >             mutable().removeProperty(sessionCache(), property.name());
  536.               return true;
  537.           }

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1089: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1087.               // Determine if the existing node already contained this property ...
  1088.               AbstractSessionCache session = session(cache);
  1089. >             CachedNode raw = nodeInWorkspace(session);
  1090.               if (raw.hasProperty(name, cache)) {
  1091.                   removedProperties.put(name, name);

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1094: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void SessionNode.removeProperty(SessionCache,Name)` indirectly mutates container `changes.addedStrong` via call to `put` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1092.               }
  1093.           }
  1094. >         processPropertyChange(cache, name, null);
  1095.       }
  1096.   

src/main/java/org/modeshape/jcr/journal/LocalJournal.java:212: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void LocalJournal.removeRecordsOlderThan(long)` reads without synchronization from `this.journalDB`. Potentially races with write in method `LocalJournal.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  210.           NavigableMap<Long, JournalRecord> toRemove = this.records.headMap(searchBound);
  211.           toRemove.clear();
  212. >         journalDB.commit();
  213.           journalDB.compact();
  214.       }

src/main/java/org/modeshape/jcr/journal/LocalJournal.java:210: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void LocalJournal.removeRecordsOlderThan(long)` reads without synchronization from `this.records`. Potentially races with write in method `LocalJournal.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  208.           long searchBound = TIME_BASED_KEYS.getCounterEndingAt(millisInUtc);
  209.           LOGGER.debug("Removing records older than " + searchBound);
  210. >         NavigableMap<Long, JournalRecord> toRemove = this.records.headMap(searchBound);
  211.           toRemove.clear();
  212.           journalDB.commit();

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:693: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void SessionNode.removeReferrer(SessionCache,Property,NodeKey,CachedNode$ReferenceType)` indirectly mutates container `changes.addedWeak` via call to `remove` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  691.           switch (type) {
  692.               case WEAK:
  693. >                 changes.removeWeakReferrer(property, referrerKey);
  694.                   break;
  695.               case STRONG:

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:696: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void SessionNode.removeReferrer(SessionCache,Property,NodeKey,CachedNode$ReferenceType)` indirectly mutates container `changes.addedStrong` via call to `remove` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  694.                   break;
  695.               case STRONG:
  696. >                 changes.removeStrongReferrer(property, referrerKey);
  697.                   break;
  698.               case BOTH:

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3149: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.removeShare()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3147.       @Override
  3148.       public void removeShare() throws VersionException, LockException, ConstraintViolationException, RepositoryException {
  3149. >         internalRemove(false);
  3150.       }
  3151.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrSystemNode.removeShare()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3122: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.removeSharedSet()` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3120.                           AbstractJcrNode parent = nodeInSharedSet.getParent();
  3121.                           parent.checkForLock();
  3122. >                         session.checkPermission(nodeInSharedSet, ModeShapePermissions.REMOVE);
  3123.   
  3124.                           if (nodeInSharedSet != this) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3113: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.removeSharedSet()` indirectly writes to field `parentKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3111.               if (sharedSet.getSize() != 1) {
  3112.                   // There's more than one shared
  3113. >                 NodeIterator sharedSetNodes = sharedSet.getSharedNodes();
  3114.                   List<AbstractJcrNode> shared = new ArrayList<AbstractJcrNode>();
  3115.                   while (sharedSetNodes.hasNext()) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3111: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Set CachedNode.getAdditionalParentKeys(NodeCache)` of un-annotated interface `org.modeshape.jcr.cache.CachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  3109.               // Remove all of the node is the shared set ...
  3110.               SharedSet sharedSet = sharedSet();
  3111. >             if (sharedSet.getSize() != 1) {
  3112.                   // There's more than one shared
  3113.                   NodeIterator sharedSetNodes = sharedSet.getSharedNodes();

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3121: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.removeSharedSet()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3119.                       try {
  3120.                           AbstractJcrNode parent = nodeInSharedSet.getParent();
  3121. >                         parent.checkForLock();
  3122.                           session.checkPermission(nodeInSharedSet, ModeShapePermissions.REMOVE);
  3123.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrSystemNode.removeSharedSet()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/value/binary/CassandraBinaryStore.java:219: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void CassandraBinaryStore.removeValuesUnusedLongerThan(long,TimeUnit)` reads without synchronization from `this.session`. Potentially races with write in method `CassandraBinaryStore.start()`.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  217.               // the indexed column in the where clause. This is a limitation of Cassandra.
  218.               // So we have to do some tricks here
  219. >             ResultSet rs = session.execute("SELECT cid from modeshape.binary where usage=0 and usage_time < "
  220.                                              + deadline.getTime() + " allow filtering;");
  221.   

src/main/java/org/modeshape/jcr/value/binary/DatabaseBinaryStore.java:248: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void DatabaseBinaryStore.removeValuesUnusedLongerThan(long,TimeUnit)` indirectly reads without synchronization from `this.dataSource`. Potentially races with write in method `DatabaseBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  246.       public void removeValuesUnusedLongerThan( final long minimumAge,
  247.                                                 final TimeUnit unit ) throws BinaryStoreException {
  248. >         dbCall(new DBCallable<Void>() {
  249.               @Override
  250.               public Void execute( Connection connection ) throws Exception {

src/main/java/org/modeshape/jcr/value/binary/MongodbBinaryStore.java:263: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MongodbBinaryStore.removeValuesUnusedLongerThan(long,TimeUnit)` indirectly reads without synchronization from `this.db`. Potentially races with write in method `MongodbBinaryStore.start()`.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  261.                                                 TimeUnit unit ) {
  262.           long deadline = System.currentTimeMillis() - unit.toMillis(minimumAge);
  263. >         Set<String> keys = getStoredKeys(false);
  264.           for (String key : keys) {
  265.               DBCollection content = db.getCollection(key);

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:351: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void InfinispanBinaryStore.removeValuesUnusedLongerThan(long,TimeUnit)` reads without synchronization from `this.metadataCache`. Potentially races with write in method `InfinispanBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  349.   
  350.           // determine type of cache store
  351. >         List<StoreConfiguration> storeConfigurations = metadataCache.getCacheConfiguration().persistence().stores();
  352.           boolean cacheLoaderShared = storeConfigurations != null && !storeConfigurations.isEmpty()
  353.                                       && storeConfigurations.get(0).shared();

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:372: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void InfinispanBinaryStore.removeValuesUnusedLongerThan(long,TimeUnit)` reads with synchronization from `this.blobCache`. Potentially races with unsynchronized write in method `InfinispanBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  370.                   InfinispanBinaryStore.Lock lock = lockFactory.writeLock(key);
  371.                   try {
  372. >                     removeUnusedBinaryValue(metadataCache, blobCache, key);
  373.                   } finally {
  374.                       lock.unlock();

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:354: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `EmbeddedCacheManager Cache.getCacheManager()` of un-annotated interface `org.infinispan.Cache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  352.           boolean cacheLoaderShared = storeConfigurations != null && !storeConfigurations.isEmpty()
  353.                                       && storeConfigurations.get(0).shared();
  354. >         boolean isCoordinator = metadataCache.getCacheManager().isCoordinator();
  355.   
  356.           if (!isCoordinator && cacheLoaderShared) {

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:370: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void InfinispanBinaryStore.removeValuesUnusedLongerThan(long,TimeUnit)` reads with synchronization from `this.lockFactory`. Potentially races with unsynchronized write in method `InfinispanBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  368.               Map<String, String> result = task.execute();
  369.               for (String key : result.values()) {
  370. >                 InfinispanBinaryStore.Lock lock = lockFactory.writeLock(key);
  371.                   try {
  372.                       removeUnusedBinaryValue(metadataCache, blobCache, key);

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:181: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrVersionHistoryNode.removeVersion(String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  179.           throws ReferentialIntegrityException, AccessDeniedException, UnsupportedRepositoryOperationException, VersionException,
  180.           RepositoryException {
  181. >         JcrVersionNode version = getVersion(versionName);
  182.           removeVersion(version);
  183.       }

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:182: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrVersionHistoryNode.removeVersion(String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  180.           RepositoryException {
  181.           JcrVersionNode version = getVersion(versionName);
  182. >         removeVersion(version);
  183.       }
  184.   

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:259: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void SessionCache.destroy(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  257.   
  258.           system.mutable(key).removeChild(system, version.key);
  259. >         system.destroy(version.key);
  260.           try {
  261.               system.save();

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:198: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrVersionHistoryNode.removeVersion(Version)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  196.           JcrVersionNode version = (JcrVersionNode)versionToBeRemoved;
  197.   
  198. >         validateIncomingReferences(version);
  199.   
  200.           String versionId = version.getIdentifier();

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:203: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrVersionHistoryNode.removeVersion(Version)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  201.   
  202.           // Get the predecessors and successors for the version being removed ...
  203. >         AbstractJcrProperty predecessors = version.getProperty(JcrLexicon.PREDECESSORS);
  204.           AbstractJcrProperty successors = version.getProperty(JcrLexicon.SUCCESSORS);
  205.   

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:216: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JcrVersionHistoryNode.removeVersion(Version)` indirectly reads without synchronization from `nodeKey.workspaceKey`. Potentially races with write in method `JcrVersionHistoryNode.addVersionLabel(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  214.               // Add each of the successors from the version's predecessor ...
  215.               NodeKey predecessorKey = ((NodeKeyReference)((JcrValue)predecessorValue).value()).getNodeKey();
  216. >             AbstractJcrNode predecessor = session().node(predecessorKey, null);
  217.               MutableCachedNode predecessorSystem = system.mutable(predecessor.key());
  218.   

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:349: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `int Transaction.getStatus()` of un-annotated interface `javax.transaction.Transaction`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  347.   
  348.           // Use a separate system session to remove the REFERENCE property on the 'nt:versionLabels' child node ...
  349. >         SessionCache system = session.createSystemCache(false);
  350.           system.mutable(versionLabels.key()).removeProperty(system, propName);
  351.           system.save();

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:342: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrVersionHistoryNode.removeVersionLabel(String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  340.           try {
  341.               // This throws a PNFE if the named property doesn't already exist
  342. >             propName = versionLabels.getProperty(label).name();
  343.           } catch (PathNotFoundException pnfe) {
  344.               // This gets thrown if the label doesn't already exist

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:337: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrVersionHistoryNode.removeVersionLabel(String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  335.       @Override
  336.       public void removeVersionLabel( String label ) throws VersionException, RepositoryException {
  337. >         AbstractJcrNode versionLabels = versionLabels();
  338.   
  339.           Name propName = null;

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1337: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1335.           WritableSessionCache session = writableSession(cache);
  1336.           session.assertInSession(this);
  1337. >         ChildReferences references = getChildReferences(session);
  1338.           if (!references.hasChild(key)) throw new NodeNotFoundException(key);
  1339.   

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1351: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void SessionNode.renameChild(SessionCache,NodeKey,Name)` indirectly mutates container `newNames` via call to `put` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1349.           } else {
  1350.               // Now perform the rename ...
  1351. >             changedChildren.renameTo(key, newName);
  1352.           }
  1353.       }

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:2096: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void SessionNode$ChangedChildren.renameTo(NodeKey,Name)` mutates container `newNames` via call to `put` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2094.                   }
  2095.               }
  2096. >             newNames.put(key, newName);
  2097.           }
  2098.   

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1294: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1292.           session.assertInSession(this);
  1293.   
  1294. >         ChildReferences references = getChildReferences(session);
  1295.           ChildReference before = null;
  1296.           if (nextNode != null) {

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:244: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  242.                                                         NodeKey oldParent,
  243.                                                         NodeKey existingAdditionalParent ) {
  244. >         assert getAdditionalParentKeys(cache).contains(existingAdditionalParent);
  245.           newParent = existingAdditionalParent;
  246.           ChangedAdditionalParents additionalParents = this.additionalParents.get();

src/main/java/org/modeshape/jcr/JcrWorkspace.java:686: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `JcrRepositoryManager JcrWorkspace.repositoryManager()` reads without synchronization from `this.repositoryManager`. Potentially races with write in method `JcrWorkspace.getRepositoryManager()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  684.   
  685.       final JcrRepositoryManager repositoryManager() {
  686. >         if (repositoryManager == null) {
  687.               try {
  688.                   lock.lock();

src/main/java/org/modeshape/jcr/JcrRepositoryManager.java:65: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `JcrRepositoryMonitor JcrRepositoryManager.repositoryMonitor()` reads without synchronization from `this.monitor`. Potentially races with write in method `JcrRepositoryManager.repositoryMonitor()`.
 Reporting because this access may occur on a background thread.
  63.               }
  64.           }
  65. >         return monitor;
  66.       }
  67.   

src/main/java/org/modeshape/jcr/JcrWorkspace.java:564: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.restore(javax.jcr.version.Version[],boolean)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  562.           InvalidItemStateException, RepositoryException {
  563.           session.checkLive();
  564. >         versionManager().restore(versions, removeExisting);
  565.       }
  566.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3243: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.restore(String,boolean)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3241.           throws VersionException, ItemExistsException, UnsupportedRepositoryOperationException, LockException,
  3242.           InvalidItemStateException, RepositoryException {
  3243. >         restore(getVersionHistory().getVersion(versionName), removeExisting);
  3244.       }
  3245.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrSystemNode.restore(String,boolean)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3252: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean NodeTypes$ReusableNodeDefinitionSet.appliesTo(NodeTypes,Name,Set)` of un-annotated interface `org.modeshape.jcr.NodeTypes$ReusableNodeDefinitionSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  3250.           LockException, RepositoryException {
  3251.           try {
  3252. >             checkNotProtected();
  3253.           } catch (ConstraintViolationException cve) {
  3254.               throw new UnsupportedRepositoryOperationException(cve);

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3256: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.restore(Version,boolean)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3254.               throw new UnsupportedRepositoryOperationException(cve);
  3255.           }
  3256. >         versionManager().restoreAtAbsPath(getPath(), version, removeExisting, false);
  3257.       }
  3258.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrSystemNode.restore(Version,boolean)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3272: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.restore(Version,String,boolean)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3270.           Path actualPath = pathFactory.create(path(), relPathAsPath).getCanonicalPath();
  3271.   
  3272. >         versionManager().restoreAtAbsPath(session.stringFactory().create(actualPath), version, removeExisting, false);
  3273.       }
  3274.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3265: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean NodeTypes$ReusableNodeDefinitionSet.appliesTo(NodeTypes,Name,Set)` of un-annotated interface `org.modeshape.jcr.NodeTypes$ReusableNodeDefinitionSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  3263.           throws PathNotFoundException, ItemExistsException, VersionException, ConstraintViolationException,
  3264.           UnsupportedRepositoryOperationException, LockException, InvalidItemStateException, RepositoryException {
  3265. >         checkNotProtected();
  3266.   
  3267.           PathFactory pathFactory = session.pathFactory();

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrSystemNode.restore(Version,String,boolean)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3280: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.restoreByLabel(String,boolean)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3278.           throws VersionException, ItemExistsException, UnsupportedRepositoryOperationException, LockException,
  3279.           InvalidItemStateException, RepositoryException {
  3280. >         restore(getVersionHistory().getVersionByLabel(versionLabel), removeExisting);
  3281.       }
  3282.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrSystemNode.restoreByLabel(String,boolean)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/JcrRepositoryManager.java:86: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Problems JcrRepositoryManager.restoreRepository(File,RestoreOptions)` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  84.       @Override
  85.       public Problems restoreRepository( File backupDirectory, RestoreOptions options ) throws RepositoryException {
  86. >         session().checkPermission(Path.ROOT_PATH, ModeShapePermissions.RESTORE);
  87.           return repository().runningState().backupService().restoreRepository(repository(), backupDirectory, options);
  88.       }

src/main/java/org/modeshape/jcr/RepositoryStatistics.java:659: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `long DurationActivity.getDuration(TimeUnit)` of un-annotated interface `org.modeshape.jcr.api.monitor.DurationActivity`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  657.               int i = 0;
  658.               for (DurationActivity record : records) {
  659. >                 values[i++] = record != null ? record.getDuration(TimeUnit.MILLISECONDS) : 0L;
  660.                   this.largestDurations.add(record);
  661.                   while (this.largestDurations.size() > this.retentionSize) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3411: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void Transactions$Transaction.commit()` of un-annotated interface `org.modeshape.jcr.txn.Transactions$Transaction`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  3409.           if (this.isRoot()) {
  3410.               // Just call save on the session (it's more efficient) ...
  3411. >             session.save();
  3412.           } else {
  3413.               session.save(this);

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3413: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.save()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3411.               session.save();
  3412.           } else {
  3413. >             session.save(this);
  3414.           }
  3415.       }

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrSystemNode.save()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:432: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WritableSessionCache.save()` indirectly reads with synchronization from `this.changedNodes`. Potentially races with unsynchronized write in method `WritableSessionCache.clearState()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  430.       @Override
  431.       public void save() {
  432. >         save((PreSave)null);
  433.       }
  434.   

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:758: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SessionCache SessionCache.unwrap()` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  756.   
  757.           // Try getting locks on both sessions ...
  758. >         final WritableSessionCache that = (WritableSessionCache)other.unwrap();
  759.           Lock thisLock = this.lock.writeLock();
  760.           Lock thatLock = that.lock.writeLock();

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:824: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WritableSessionCache.save(Set,SessionCache,SessionCache$PreSave)` indirectly reads with synchronization from `this.replacedNodes`. Potentially races with unsynchronized write in method `WritableSessionCache.clearState()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  822.                           // Now persist the changes ...
  823.                           logChangesBeingSaved(savedNodesInOrder, this.changedNodes, that.changedNodesInOrder, that.changedNodes);
  824. >                         events1 = persistChanges(savedNodesInOrder, thisPersistedCache);
  825.                           // If there are any binary changes, add a function which will update the binary store
  826.                           if (events1.hasBinaryChanges()) {

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:775: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WritableSessionCache.save(Set,SessionCache,SessionCache$PreSave)` reads with synchronization from `this.changedNodes`. Potentially races with unsynchronized write in method `WritableSessionCache.clearState()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  773.               if (preSaveOperation != null) {
  774.                   SaveContext saveContext = new BasicSaveContext(context());
  775. >                 for (MutableCachedNode node : this.changedNodes.values()) {
  776.                       if (node == REMOVED || !toBeSaved.contains(node.getKey())) {
  777.                           continue;

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:796: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WritableSessionCache.save(Set,SessionCache,SessionCache$PreSave)` indirectly reads with synchronization from container `this.changedNodes` via call to `keySet`. Potentially races with unsynchronized write in method `WritableSessionCache.clearState(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  794.                       try {
  795.                           // Lock the nodes in Infinispan and bring the latest version of these nodes in the shared workspace cache
  796. >                         WorkspaceCache thisPersistedCache = lockNodes(savedNodesInOrder);
  797.                           WorkspaceCache thatPersistedCache = that.lockNodes(that.changedNodesInOrder);
  798.   

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:647: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WritableSessionCache.save(SessionCache,SessionCache$PreSave)` indirectly reads with synchronization from `this.replacedNodes`. Potentially races with unsynchronized write in method `WritableSessionCache.clearState()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  645.                           logChangesBeingSaved(this.changedNodesInOrder, this.changedNodes, that.changedNodesInOrder,
  646.                                                that.changedNodes);
  647. >                         events1 = persistChanges(this.changedNodesInOrder, thisPersistedCache);
  648.                           // If there are any binary changes, add a function which will update the binary store
  649.                           if (events1.hasBinaryChanges()) {

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:600: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SessionCache SessionCache.unwrap()` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  598.   
  599.           // Try getting locks on both sessions ...
  600. >         final WritableSessionCache that = (WritableSessionCache)other.unwrap();
  601.           Lock thisLock = this.lock.writeLock();
  602.           Lock thatLock = that.lock.writeLock();

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:614: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WritableSessionCache.save(SessionCache,SessionCache$PreSave)` reads with synchronization from container `this.changedNodes` via call to `size`. Potentially races with unsynchronized write in method `WritableSessionCache.clearState(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  612.               runPreSaveBeforeTransaction(preSaveOperation);
  613.   
  614. >             final int numNodes = this.changedNodes.size() + that.changedNodes.size();
  615.   
  616.               int repeat = txns.isCurrentlyInTransaction() ? 1 : MAX_REPEAT_FOR_LOCK_ACQUISITION_TIMEOUT;

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:612: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WritableSessionCache.save(SessionCache,SessionCache$PreSave)` indirectly reads with synchronization from `this.changedNodes`. Potentially races with unsynchronized write in method `WritableSessionCache.clearState()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  610.   
  611.               // Before we start the transaction, apply the pre-save operations to the new and changed nodes ...
  612. >             runPreSaveBeforeTransaction(preSaveOperation);
  613.   
  614.               final int numNodes = this.changedNodes.size() + that.changedNodes.size();

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:449: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WritableSessionCache.save(SessionCache$PreSave)` reads with synchronization from container `this.changedNodes` via call to `size`. Potentially races with unsynchronized write in method `WritableSessionCache.clearState(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  447.               runPreSaveBeforeTransaction(preSaveOperation);
  448.   
  449. >             final int numNodes = this.changedNodes.size();
  450.   
  451.               int repeat = txns.isCurrentlyInTransaction() ? 1 : MAX_REPEAT_FOR_LOCK_ACQUISITION_TIMEOUT;

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:477: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WritableSessionCache.save(SessionCache$PreSave)` indirectly reads with synchronization from `this.replacedNodes`. Potentially races with unsynchronized write in method `WritableSessionCache.clearState()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  475.                       // Now persist the changes ...
  476.                       logChangesBeingSaved(this.changedNodesInOrder, this.changedNodes, null, null);
  477. >                     events = persistChanges(this.changedNodesInOrder, persistedCache);
  478.   
  479.                       // If there are any binary changes, add a function which will update the binary store

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:447: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WritableSessionCache.save(SessionCache$PreSave)` indirectly reads with synchronization from `this.changedNodes`. Potentially races with unsynchronized write in method `WritableSessionCache.clearState()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  445.   
  446.               // Before we start the transaction, apply the pre-save operations to the new and changed nodes ...
  447. >             runPreSaveBeforeTransaction(preSaveOperation);
  448.   
  449.               final int numNodes = this.changedNodes.size();

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:247: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `CachedNode SessionCache.getNode(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  245.   
  246.       protected Segment segment() throws RepositoryException {
  247. >         return node().getSegment(sessionCache());
  248.       }
  249.   

src/main/java/org/modeshape/jcr/JcrSharedNode.java:105: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReference ChildReferences.getChild(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.ChildReferences`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  103.           CachedNode node = parent.node();
  104.           SessionCache cache = session.cache();
  105. >         ChildReference childRef = node.getChildReferences(cache).getChild(sharedSet.key());
  106.           return childRef.getSegment();
  107.       }

src/main/java/org/modeshape/jcr/JcrSharedNode.java:102: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Path$Segment JcrSharedNode.segment()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  100.       @Override
  101.       protected Segment segment() throws RepositoryException {
  102. >         AbstractJcrNode parent = parent();
  103.           CachedNode node = parent.node();
  104.           SessionCache cache = session.cache();

src/main/java/org/modeshape/jcr/clustering/ClusteringService.java:269: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean ClusteringService.sendMessage(Serializable)` indirectly reads without synchronization from `this.channel`. Potentially races with write in method `ClusteringService.restart()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  267.   
  268.           if (LOGGER.isDebugEnabled()) {
  269. >             LOGGER.debug("Sending payload {0} in cluster {1} ", payload, clusterName());
  270.           }
  271.           try {

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:295: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `NodeCache NodeCache.unwrap()` of un-annotated interface `org.modeshape.jcr.cache.NodeCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  293.   
  294.       protected final AbstractSessionCache session( NodeCache cache ) {
  295. >         return (AbstractSessionCache)cache.unwrap();
  296.       }
  297.   

src/main/java/org/modeshape/jcr/cache/change/RecordingChanges.java:291: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void RecordingChanges.setChangedNodes(Set)` writes to field `this.nodeKeys` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  289.       public void setChangedNodes( Set<NodeKey> keys ) {
  290.           if (keys != null) {
  291. >             this.nodeKeys = Collections.unmodifiableSet(new HashSet<NodeKey>(keys));
  292.           }
  293.       }

src/main/java/org/modeshape/jcr/value/binary/MongodbBinaryStore.java:194: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void MongodbBinaryStore.setChunkSize(int)` writes to field `this.chunkSize` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  192.        */
  193.       public void setChunkSize( int chunkSize ) {
  194. >         this.chunkSize = chunkSize;
  195.       }
  196.   

src/main/java/org/modeshape/jcr/SystemNamespaceRegistry.java:60: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void SystemNamespaceRegistry.setContext(ExecutionContext)` writes to field `this.context` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  58.   
  59.       void setContext( ExecutionContext context ) {
  60. >         this.context = context;
  61.       }
  62.   

src/main/java/org/modeshape/jcr/RepositoryLockManager.java:406: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `ChildReference ChildReferences.getChild(Name)` of un-annotated interface `org.modeshape.jcr.cache.ChildReferences`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  404.   
  405.           // Mark the session as held/unheld ...
  406. >         if (!system.changeLockHeldBySession(lockToken, value)) {
  407.               return false;
  408.           }

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:88: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `MutableCachedNode$PermissionChanges SessionNode.setPermissions(SessionCache,Map)` indirectly mutates container `changes.addedStrong` via call to `put` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  86.    * save operations) are immediately reflected.
  87.    */
  88. > @ThreadSafe
  89.   public class SessionNode implements MutableCachedNode {
  90.   

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1564: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `MutableCachedNode MutableCachedNode.createChild(SessionCache,NodeKey,Name,Property,org.modeshape.jcr.value.Property[])` of un-annotated interface `org.modeshape.jcr.cache.MutableCachedNode`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1562.                   Property privileges = propertyFactory.create(ModeShapeLexicon.PERMISSION_PRIVILEGES_NAME,
  1563.                                                                privilegesByPrincipalName.get(principal));
  1564. >                 aclNode.createChild(cache, null, principalName, primaryType, principalProp, privileges);
  1565.               } else {
  1566.                   //there already is a child node for this principal, so we just need to update its privileges

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1545: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `SessionNode$PermissionChanges SessionNode.setPermissions(SessionCache,Map)` indirectly mutates container `changes.addedStrong` via call to `put` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1543.               org.modeshape.jcr.value.Property primaryType = propertyFactory.create(JcrLexicon.PRIMARY_TYPE,
  1544.                                                                                     ModeShapeLexicon.ACCESS_LIST_NODE_TYPE);
  1545. >             aclNode = this.createChild(cache, null, ModeShapeLexicon.ACCESS_LIST_NODE_NAME, primaryType);
  1546.               permissionsReferences = ImmutableChildReferences.EmptyChildReferences.INSTANCE;
  1547.           }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2431: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.setPrimaryType(String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2429.               Property prop = iter.next();
  2430.               try {
  2431. >                 createJcrProperty(prop, newPrimaryTypeName, mixinTypeNames);
  2432.               } catch (ConstraintViolationException e) {
  2433.                   // Change the message ...

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2472: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.setPrimaryType(String)` indirectly writes to field `defn.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2470.   
  2471.           // And auto-create any properties that are defined by the new primary type ...
  2472. >         autoCreateItemsFor(newPrimaryType);
  2473.   
  2474.           // Since we've changed the primary type, release the cached property definition IDs for the node's properties ...

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2399: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean NodeTypes$ReusableNodeDefinitionSet.appliesTo(NodeTypes,Name,Set)` of un-annotated interface `org.modeshape.jcr.NodeTypes$ReusableNodeDefinitionSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  2397.           checkSession();
  2398.           checkForLock();
  2399. >         checkForCheckedOut();
  2400.           session.checkPermission(this, ModeShapePermissions.SET_PROPERTY);
  2401.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2400: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.setPrimaryType(String)` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2398.           checkForLock();
  2399.           checkForCheckedOut();
  2400. >         session.checkPermission(this, ModeShapePermissions.SET_PROPERTY);
  2401.   
  2402.           if (isRoot()) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2398: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.setPrimaryType(String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2396.   
  2397.           checkSession();
  2398. >         checkForLock();
  2399.           checkForCheckedOut();
  2400.           session.checkPermission(this, ModeShapePermissions.SET_PROPERTY);

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrSystemNode.setPrimaryType(String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1064: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void SessionNode.setProperties(SessionCache,Iterable)` indirectly mutates container `changes.addedStrong` via call to `put` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1062.               changedProperties.put(name, property);
  1063.               if (!isNew) removedProperties.remove(name);
  1064. >             processPropertyChange(cache, name, null);
  1065.           }
  1066.       }

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1061: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Name Property.getName()` of un-annotated interface `org.modeshape.jcr.value.Property`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1059.           writableSession(cache).assertInSession(this);
  1060.           for (Property property : properties) {
  1061. >             Name name = property.getName();
  1062.               changedProperties.put(name, property);
  1063.               if (!isNew) removedProperties.remove(name);

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1077: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void SessionNode.setProperties(SessionCache,Iterator)` indirectly mutates container `changes.addedStrong` via call to `put` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1075.               changedProperties.put(name, property);
  1076.               if (!isNew) removedProperties.remove(name);
  1077. >             processPropertyChange(cache, name, null);
  1078.           }
  1079.       }

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1074: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Name Property.getName()` of un-annotated interface `org.modeshape.jcr.value.Property`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1072.           while (properties.hasNext()) {
  1073.               Property property = properties.next();
  1074. >             Name name = property.getName();
  1075.               changedProperties.put(name, property);
  1076.               if (!isNew) removedProperties.remove(name);

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:101: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Property AbstractJcrNode.setProperty(String,boolean)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  99.    * The abstract base class for all {@link Node} implementations.
  100.    */
  101. > @ThreadSafe
  102.   abstract class AbstractJcrNode extends AbstractJcrItem implements Node {
  103.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1586: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(String,boolean)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1584.           checkSession();
  1585.           // don't skip constraint checks or protected checks
  1586. >         return setProperty(nameFrom(name), valueFrom(PropertyType.BOOLEAN, value), false, false, false, false);
  1587.       }
  1588.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty JcrSystemNode.setProperty(String,boolean)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:101: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Property AbstractJcrNode.setProperty(String,double)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  99.    * The abstract base class for all {@link Node} implementations.
  100.    */
  101. > @ThreadSafe
  102.   abstract class AbstractJcrNode extends AbstractJcrItem implements Node {
  103.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1596: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(String,double)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1594.           checkSession();
  1595.           // don't skip constraint checks or protected checks
  1596. >         return setProperty(nameFrom(name), valueFrom(PropertyType.DOUBLE, value), false, false, false, false);
  1597.       }
  1598.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty JcrSystemNode.setProperty(String,double)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:101: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Property AbstractJcrNode.setProperty(String,java.lang.String[])` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  99.    * The abstract base class for all {@link Node} implementations.
  100.    */
  101. > @ThreadSafe
  102.   abstract class AbstractJcrNode extends AbstractJcrItem implements Node {
  103.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1500: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(String,java.lang.String[])` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1498.           CheckArg.isNotNull(name, "name");
  1499.           checkSession();
  1500. >         if (values == null) return removeExistingProperty(nameFrom(name));
  1501.           return setProperty(nameFrom(name), valuesFrom(PropertyType.STRING, values), PropertyType.UNDEFINED, false, false, false,
  1502.                              false);

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1501: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(String,java.lang.String[])` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1499.           checkSession();
  1500.           if (values == null) return removeExistingProperty(nameFrom(name));
  1501. >         return setProperty(nameFrom(name), valuesFrom(PropertyType.STRING, values), PropertyType.UNDEFINED, false, false, false,
  1502.                              false);
  1503.       }

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty JcrSystemNode.setProperty(String,java.lang.String[])` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:101: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Property AbstractJcrNode.setProperty(String,java.lang.String[],int)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  99.    * The abstract base class for all {@link Node} implementations.
  100.    */
  101. > @ThreadSafe
  102.   abstract class AbstractJcrNode extends AbstractJcrItem implements Node {
  103.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1522: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(String,java.lang.String[],int)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1520.           CheckArg.isNotNull(name, "name");
  1521.           checkSession();
  1522. >         if (values == null) return removeExistingProperty(nameFrom(name));
  1523.           return setProperty(nameFrom(name), valuesFrom(type, values), PropertyType.UNDEFINED, false);
  1524.       }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1523: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(String,java.lang.String[],int)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1521.           checkSession();
  1522.           if (values == null) return removeExistingProperty(nameFrom(name));
  1523. >         return setProperty(nameFrom(name), valuesFrom(type, values), PropertyType.UNDEFINED, false);
  1524.       }
  1525.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty JcrSystemNode.setProperty(String,java.lang.String[],int)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:101: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Property AbstractJcrNode.setProperty(String,javax.jcr.Value[])` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  99.    * The abstract base class for all {@link Node} implementations.
  100.    */
  101. > @ThreadSafe
  102.   abstract class AbstractJcrNode extends AbstractJcrItem implements Node {
  103.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1452: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(String,javax.jcr.Value[])` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1450.           CheckArg.isNotNull(name, "name");
  1451.           checkSession();
  1452. >         if (values == null) return removeExistingProperty(nameFrom(name));
  1453.   
  1454.           if (values.length == 0) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1466: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(String,javax.jcr.Value[])` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1464.           }
  1465.   
  1466. >         return setProperty(nameFrom(name), values, PropertyType.UNDEFINED, false);
  1467.       }
  1468.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty JcrSystemNode.setProperty(String,javax.jcr.Value[])` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:101: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Property AbstractJcrNode.setProperty(String,javax.jcr.Value[],int)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  99.    * The abstract base class for all {@link Node} implementations.
  100.    */
  101. > @ThreadSafe
  102.   abstract class AbstractJcrNode extends AbstractJcrItem implements Node {
  103.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1476: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(String,javax.jcr.Value[],int)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1474.           CheckArg.isNotNull(name, "name");
  1475.           checkSession();
  1476. >         if (values == null) return removeExistingProperty(nameFrom(name));
  1477.   
  1478.           if (values.length == 0) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1491: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(String,javax.jcr.Value[],int)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1489.   
  1490.           // Set the value, perhaps to an empty array ...
  1491. >         return setProperty(nameFrom(name), values, type, false);
  1492.       }
  1493.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty JcrSystemNode.setProperty(String,javax.jcr.Value[],int)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:101: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Property AbstractJcrNode.setProperty(String,long)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  99.    * The abstract base class for all {@link Node} implementations.
  100.    */
  101. > @ThreadSafe
  102.   abstract class AbstractJcrNode extends AbstractJcrItem implements Node {
  103.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1616: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(String,long)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1614.           checkSession();
  1615.           // don't skip constraint checks or protected checks
  1616. >         return setProperty(nameFrom(name), valueFrom(PropertyType.LONG, value), false, false, false, false);
  1617.       }
  1618.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty JcrSystemNode.setProperty(String,long)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:101: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Property AbstractJcrNode.setProperty(String,InputStream)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  99.    * The abstract base class for all {@link Node} implementations.
  100.    */
  101. > @ThreadSafe
  102.   abstract class AbstractJcrNode extends AbstractJcrItem implements Node {
  103.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1564: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(String,InputStream)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1562.           CheckArg.isNotNull(name, "name");
  1563.           checkSession();
  1564. >         if (value == null) return removeExistingProperty(nameFrom(name));
  1565.           // don't skip constraint checks or protected checks
  1566.           return setProperty(nameFrom(name), valueFrom(value), false, false, false, false);

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1566: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(String,InputStream)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1564.           if (value == null) return removeExistingProperty(nameFrom(name));
  1565.           // don't skip constraint checks or protected checks
  1566. >         return setProperty(nameFrom(name), valueFrom(value), false, false, false, false);
  1567.       }
  1568.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty JcrSystemNode.setProperty(String,InputStream)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:101: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Property AbstractJcrNode.setProperty(String,String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  99.    * The abstract base class for all {@link Node} implementations.
  100.    */
  101. > @ThreadSafe
  102.   abstract class AbstractJcrNode extends AbstractJcrItem implements Node {
  103.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1532: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(String,String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1530.           CheckArg.isNotNull(name, "name");
  1531.           checkSession();
  1532. >         if (value == null) return removeExistingProperty(nameFrom(name));
  1533.           return setProperty(nameFrom(name), valueFrom(PropertyType.STRING, value), false, false, false, false);
  1534.       }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1533: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(String,String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1531.           checkSession();
  1532.           if (value == null) return removeExistingProperty(nameFrom(name));
  1533. >         return setProperty(nameFrom(name), valueFrom(PropertyType.STRING, value), false, false, false, false);
  1534.       }
  1535.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty JcrSystemNode.setProperty(String,String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:101: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Property AbstractJcrNode.setProperty(String,String,int)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  99.    * The abstract base class for all {@link Node} implementations.
  100.    */
  101. > @ThreadSafe
  102.   abstract class AbstractJcrNode extends AbstractJcrItem implements Node {
  103.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1553: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(String,String,int)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1551.           CheckArg.isNotNull(name, "name");
  1552.           checkSession();
  1553. >         if (value == null) return removeExistingProperty(nameFrom(name));
  1554.           // don't skip constraint checks or protected checks
  1555.           return setProperty(nameFrom(name), valueFrom(type, value), false, false, false, false);

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1555: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(String,String,int)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1553.           if (value == null) return removeExistingProperty(nameFrom(name));
  1554.           // don't skip constraint checks or protected checks
  1555. >         return setProperty(nameFrom(name), valueFrom(type, value), false, false, false, false);
  1556.       }
  1557.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty JcrSystemNode.setProperty(String,String,int)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:101: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Property AbstractJcrNode.setProperty(String,BigDecimal)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  99.    * The abstract base class for all {@link Node} implementations.
  100.    */
  101. > @ThreadSafe
  102.   abstract class AbstractJcrNode extends AbstractJcrItem implements Node {
  103.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1606: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(String,BigDecimal)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1604.           checkSession();
  1605.           // don't skip constraint checks or protected checks
  1606. >         return setProperty(nameFrom(name), valueFrom(PropertyType.DECIMAL, value), false, false, false, false);
  1607.       }
  1608.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty JcrSystemNode.setProperty(String,BigDecimal)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:101: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Property AbstractJcrNode.setProperty(String,Calendar)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  99.    * The abstract base class for all {@link Node} implementations.
  100.    */
  101. > @ThreadSafe
  102.   abstract class AbstractJcrNode extends AbstractJcrItem implements Node {
  103.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1625: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(String,Calendar)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1623.           CheckArg.isNotNull(name, "name");
  1624.           checkSession();
  1625. >         if (value == null) return removeExistingProperty(nameFrom(name));
  1626.           // don't skip constraint checks or protected checks
  1627.           return setProperty(nameFrom(name), valueFrom(value), false, false, false, false);

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1627: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(String,Calendar)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1625.           if (value == null) return removeExistingProperty(nameFrom(name));
  1626.           // don't skip constraint checks or protected checks
  1627. >         return setProperty(nameFrom(name), valueFrom(value), false, false, false, false);
  1628.       }
  1629.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty JcrSystemNode.setProperty(String,Calendar)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:101: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Property AbstractJcrNode.setProperty(String,Binary)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  99.    * The abstract base class for all {@link Node} implementations.
  100.    */
  101. > @ThreadSafe
  102.   abstract class AbstractJcrNode extends AbstractJcrItem implements Node {
  103.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1576: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(String,Binary)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1574.           checkSession();
  1575.           // don't skip constraint checks or protected checks
  1576. >         return setProperty(nameFrom(name), valueFrom(PropertyType.BINARY, value), false, false, false, false);
  1577.       }
  1578.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty JcrSystemNode.setProperty(String,Binary)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:101: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Property AbstractJcrNode.setProperty(String,Node)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  99.    * The abstract base class for all {@link Node} implementations.
  100.    */
  101. > @ThreadSafe
  102.   abstract class AbstractJcrNode extends AbstractJcrItem implements Node {
  103.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1638: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(String,Node)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1636.           if (value == null) return removeExistingProperty(nameFrom(name));
  1637.           // don't skip constraint checks or protected checks
  1638. >         return setProperty(nameFrom(name), valueFrom(value), false, false, false, false);
  1639.       }
  1640.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1636: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(String,Node)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1634.           CheckArg.isNotNull(name, "name");
  1635.           checkSession();
  1636. >         if (value == null) return removeExistingProperty(nameFrom(name));
  1637.           // don't skip constraint checks or protected checks
  1638.           return setProperty(nameFrom(name), valueFrom(value), false, false, false, false);

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty JcrSystemNode.setProperty(String,Node)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:101: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Property AbstractJcrNode.setProperty(String,Value)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  99.    * The abstract base class for all {@link Node} implementations.
  100.    */
  101. > @ThreadSafe
  102.   abstract class AbstractJcrNode extends AbstractJcrItem implements Node {
  103.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1420: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(String,Value)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1418.           CheckArg.isNotNull(name, "name");
  1419.           checkSession();
  1420. >         if (value == null) return removeExistingProperty(nameFrom(name));
  1421.           JcrValue jcrValue = (JcrValue)value;
  1422.           if (jcrValue.value() == null) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1425: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(String,Value)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1423.               throw new ValueFormatException(JcrI18n.valueMayNotContainNull.text(name));
  1424.           }
  1425. >         return setProperty(nameFrom(name), jcrValue, false, false, false, false); // don't skip constraint checks or protected
  1426.                                                                                     // checks
  1427.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty JcrSystemNode.setProperty(String,Value)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:101: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Property AbstractJcrNode.setProperty(String,Value,int)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  99.    * The abstract base class for all {@link Node} implementations.
  100.    */
  101. > @ThreadSafe
  102.   abstract class AbstractJcrNode extends AbstractJcrItem implements Node {
  103.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1437: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(String,Value,int)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1435.           CheckArg.isNotNull(name, "name");
  1436.           checkSession();
  1437. >         if (value == null) return removeExistingProperty(nameFrom(name));
  1438.           JcrValue jcrValue = (JcrValue)value;
  1439.           if (jcrValue.value() == null) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1443: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(String,Value,int)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1441.           }
  1442.           // don't skip constraint checks or protected checks
  1443. >         return setProperty(nameFrom(name), jcrValue.asType(type), false, false, false, false);
  1444.       }
  1445.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty JcrSystemNode.setProperty(String,Value,int)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:819: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void SessionNode.setProperty(SessionCache,Property)` indirectly mutates container `changes.addedStrong` via call to `put` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  817.           changedProperties.put(name, property);
  818.           if (!isNew) removedProperties.remove(name);
  819. >         processPropertyChange(cache, name, null);
  820.       }
  821.   

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:816: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Name Property.getName()` of un-annotated interface `org.modeshape.jcr.value.Property`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  814.                                Property property ) {
  815.           writableSession(cache).assertInSession(this);
  816. >         Name name = property.getName();
  817.           changedProperties.put(name, property);
  818.           if (!isNew) removedProperties.remove(name);

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1826: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(Name,javax.jcr.Value[],int,boolean)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1824.                                              boolean skipReferenceValidation )
  1825.           throws VersionException, LockException, ConstraintViolationException, RepositoryException {
  1826. >         return setProperty(name, values, jcrPropertyType, false, skipReferenceValidation, false, false);
  1827.       }
  1828.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1955: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(Name,javax.jcr.Value[],int,boolean,boolean,boolean,boolean)` indirectly writes to field `defn.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1953.           if (!skipReferenceValidation && (requiredType == PropertyType.REFERENCE || requiredType == PropertyType.WEAKREFERENCE)) {
  1954.               // Check that the REFERENCE value satisfies the constraints ...
  1955. >             if (!defn.canCastToTypeAndSatisfyConstraints(values, session)) {
  1956.                   // The REFERENCE value did not satisfy the constraints ...
  1957.                   String propName = readable(name);

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1861: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(Name,javax.jcr.Value[],int,boolean,boolean,boolean,boolean)` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1859.   
  1860.           if (!skipPermissionsCheck) {
  1861. >             session.checkPermission(this, ModeShapePermissions.SET_PROPERTY);
  1862.           }
  1863.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1890: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(Name,javax.jcr.Value[],int,boolean,boolean,boolean,boolean)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1888.   
  1889.           // Check for an existing JCR property object; note that this will load the internal property if necessary ...
  1890. >         AbstractJcrProperty existing = getProperty(name);
  1891.           if (existing != null) {
  1892.               // Found an existing property, and per the JavaDoc for the multi-valued javax.jcr.Node#setProperty(...),

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1856: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean NodeTypes$ReusableNodeDefinitionSet.appliesTo(NodeTypes,Name,Set)` of un-annotated interface `org.modeshape.jcr.NodeTypes$ReusableNodeDefinitionSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1854.           checkForLock();
  1855.           if (!skipVersioningValidation) {
  1856. >             checkForCheckedOut();
  1857.           }
  1858.           checkNodeTypeCanBeModified();

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1854: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(Name,javax.jcr.Value[],int,boolean,boolean,boolean,boolean)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1852.           throws VersionException, LockException, ConstraintViolationException, RepositoryException {
  1853.           assert values != null;
  1854. >         checkForLock();
  1855.           if (!skipVersioningValidation) {
  1856.               checkForCheckedOut();

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1899: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(Name,javax.jcr.Value[],int,boolean,boolean,boolean,boolean)` indirectly reads without synchronization from `definition.checker`. Potentially races with write in method `AbstractJcrNode.setProperty(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1897.                   throw new javax.jcr.ValueFormatException(msg.text(readable(name), location(), workspaceName()));
  1898.               }
  1899. >             if (existing.getDefinition().getRequiredType() == jcrPropertyType) {
  1900.                   try {
  1901.                       // set the property via the public method, so that additional checks are performed

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1694: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(Name,JcrValue,boolean,boolean,boolean,boolean)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1692.   
  1693.           // Check for an existing JCR property object; note that this will load the internal property if necessary ...
  1694. >         AbstractJcrProperty existing = getProperty(name);
  1695.           if (existing != null) {
  1696.               // Found an existing property ...

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1690: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(Name,JcrValue,boolean,boolean,boolean,boolean)` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1688.   
  1689.           if (!skipPermissionCheck) {
  1690. >             session.checkPermission(this, ModeShapePermissions.SET_PROPERTY);
  1691.           }
  1692.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1703: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(Name,JcrValue,boolean,boolean,boolean,boolean)` indirectly reads without synchronization from `definition.checker`. Potentially races with write in method `AbstractJcrNode.setProperty(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1701.               }
  1702.   
  1703. >             JcrPropertyDefinition propertyDefinition = existing.getDefinition();
  1704.   
  1705.               if (!skipProtectedValidation && propertyDefinition.isProtected()) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1767: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(Name,JcrValue,boolean,boolean,boolean,boolean)` indirectly writes to field `defn.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1765.           if (requiredType == PropertyType.REFERENCE || requiredType == PropertyType.WEAKREFERENCE) {
  1766.               // Check that the REFERENCE value satisfies the constraints ...
  1767. >             if (!skipReferenceValidation && !defn.canCastToTypeAndSatisfyConstraints(value, session)) {
  1768.                   // The REFERENCE value did not satisfy the constraints ...
  1769.                   String propName = readable(name);

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1685: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(Name,JcrValue,boolean,boolean,boolean,boolean)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1683.           assert value != null;
  1684.           assert value.value() != null;
  1685. >         checkForLock();
  1686.           // checked-out status is checked later, when we have the property definition ...
  1687.           checkNodeTypeCanBeModified();

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1778: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean NodeTypes$ReusableNodeDefinitionSet.appliesTo(NodeTypes,Name,Set)` of un-annotated interface `org.modeshape.jcr.NodeTypes$ReusableNodeDefinitionSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1776.           }
  1777.   
  1778. >         if (!skipVersioningValidation && !isCheckedOut()) {
  1779.               // Node is not checked out, so changing property is only allowed if OPV of property is 'ignore' ...
  1780.               if (defn.getOnParentVersion() != OnParentVersionAction.IGNORE) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1710: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setProperty(Name,JcrValue,boolean,boolean,boolean,boolean)` indirectly writes to field `propertyDefinition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1708.               }
  1709.   
  1710. >             if (!propertyDefinition.canCastToTypeAndSatisfyConstraints(value, session)) {
  1711.                   String defnName = propertyDefinition.getName();
  1712.                   String nodeTypeName = propertyDefinition.getDeclaringNodeType().getName();

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1050: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `SchematicEntry DocumentStore.get(String)` of un-annotated interface `org.modeshape.jcr.cache.document.DocumentStore`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1048.           Name propertyName = property.getName();
  1049.           boolean isModified = changedProperties.containsKey(propertyName)
  1050. >                              && (isNew || isPropertyInWorkspaceCache(cache, propertyName));
  1051.           if (!isModified) {
  1052.               setProperty(cache, property);

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1052: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void SessionNode.setPropertyIfUnchanged(SessionCache,Property)` indirectly mutates container `changes.addedStrong` via call to `put` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1050.                                && (isNew || isPropertyInWorkspaceCache(cache, propertyName));
  1051.           if (!isModified) {
  1052. >             setProperty(cache, property);
  1053.           }
  1054.       }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1510: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setPropertyInAccessControlScope(String,java.lang.String[])` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1508.           CheckArg.isNotNull(name, "name");
  1509.           checkSession();
  1510. >         if (values == null) return removeExistingProperty(nameFrom(name));
  1511.           return setProperty(nameFrom(name), valuesFrom(PropertyType.STRING, values), PropertyType.UNDEFINED, true, true, true,
  1512.                              false);

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1511: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setPropertyInAccessControlScope(String,java.lang.String[])` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1509.           checkSession();
  1510.           if (values == null) return removeExistingProperty(nameFrom(name));
  1511. >         return setProperty(nameFrom(name), valuesFrom(PropertyType.STRING, values), PropertyType.UNDEFINED, true, true, true,
  1512.                              false);
  1513.       }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1541: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setPropertyInAccessControlScope(String,String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1539.           CheckArg.isNotNull(name, "name");
  1540.           checkSession();
  1541. >         if (value == null) return removeExistingProperty(nameFrom(name));
  1542.           // don't skip constraint checks or protected checks
  1543.           return setProperty(nameFrom(name), valueFrom(PropertyType.STRING, value), false, true, false, true);

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1543: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrProperty AbstractJcrNode.setPropertyInAccessControlScope(String,String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1541.           if (value == null) return removeExistingProperty(nameFrom(name));
  1542.           // don't skip constraint checks or protected checks
  1543. >         return setProperty(nameFrom(name), valueFrom(PropertyType.STRING, value), false, true, false, true);
  1544.       }
  1545.   

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:832: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void SessionNode.setReference(SessionCache,Property,SessionCache)` indirectly mutates container `changes.addedStrong` via call to `put` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  830.           changedProperties.put(name, property);
  831.           if (!isNew) removedProperties.remove(name);
  832. >         processPropertyChange(cache, name, systemCache);
  833.       }
  834.   

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:829: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Name Property.getName()` of un-annotated interface `org.modeshape.jcr.value.Property`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  827.   
  828.           writableSession(cache).assertInSession(this);
  829. >         Name name = property.getName();
  830.           changedProperties.put(name, property);
  831.           if (!isNew) removedProperties.remove(name);

src/main/java/org/modeshape/jcr/JcrObservationManager.java:213: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrObservationManager.setUserData(String)` indirectly writes to field `this.session.context` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  211.       public void setUserData( String userData ) {
  212.           // User data value may be null
  213. >         this.session.addContextData(OBSERVATION_USER_DATA_KEY, userData);
  214.       }
  215.   

src/main/java/org/modeshape/jcr/JcrRepository.java:1674: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JcrRepository$RunningState.shutdown()` reads without synchronization from container `this.internalSessions` via call to `isEmpty`. Potentially races with write in method `JcrRepository$RunningState.removeSession(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1672.   
  1673.               // Now wait until all the internal sessions are gone ...
  1674. >             if (!internalSessions.isEmpty()) {
  1675.                   try {
  1676.                       int counter = 200; // this will block at most for 10 sec (200*50ms)

src/main/java/org/modeshape/jcr/clustering/ClusteringService.java:574: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean ClusteringService$ForkedClusteringService.shutdown()` indirectly reads with synchronization from `this.channel`. Potentially races with unsynchronized write in method `ClusteringService$ForkedClusteringService.init()`.
 Reporting because a superclass `class org.modeshape.jcr.clustering.ClusteringService` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  572.           @Override
  573.           public synchronized boolean shutdown() {
  574. >             if (super.shutdown()) {
  575.                   String mainChannelName = mainChannel.getName();
  576.                   List<String> forksForChannel = FORK_STACKS_BY_CHANNEL_NAME.get(mainChannelName);

src/main/java/org/modeshape/jcr/clustering/ClusteringService.java:576: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean ClusteringService$ForkedClusteringService.shutdown()` reads with synchronization from container `clustering.ClusteringService$ForkedClusteringService.FORK_STACKS_BY_CHANNEL_NAME` via call to `get`. Potentially races with unsynchronized write in method `ClusteringService$ForkedClusteringService.init()`.
 Reporting because a superclass `class org.modeshape.jcr.clustering.ClusteringService` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  574.               if (super.shutdown()) {
  575.                   String mainChannelName = mainChannel.getName();
  576. >                 List<String> forksForChannel = FORK_STACKS_BY_CHANNEL_NAME.get(mainChannelName);
  577.                   if (forksForChannel != null) {
  578.                       forksForChannel.remove(clusterName);

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:188: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void InfinispanBinaryStore.shutdown()` reads without synchronization from `this.cacheContainer`. Potentially races with write in method `InfinispanBinaryStore.shutdown()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  186.           try {
  187.               if (dedicatedCacheContainer) {
  188. >                 cacheContainer.stop();
  189.               }
  190.           } finally {

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:192: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void InfinispanBinaryStore.shutdown()` writes to field `this.metadataCache` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  190.           } finally {
  191.               cacheContainer = null;
  192. >             metadataCache = null;
  193.               blobCache = null;
  194.           }

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:191: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void InfinispanBinaryStore.shutdown()` writes to field `this.cacheContainer` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  189.               }
  190.           } finally {
  191. >             cacheContainer = null;
  192.               metadataCache = null;
  193.               blobCache = null;

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:193: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void InfinispanBinaryStore.shutdown()` writes to field `this.blobCache` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  191.               cacheContainer = null;
  192.               metadataCache = null;
  193. >             blobCache = null;
  194.           }
  195.       }

src/main/java/org/modeshape/jcr/LocalEnvironment.java:176: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void CacheContainer.stop()` of un-annotated interface `org.infinispan.manager.CacheContainer`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.Environment` is annotated `@ThreadSafe`.
  174.   
  175.       protected void shutdown( CacheContainer container ) {
  176. >         container.stop();
  177.       }
  178.   

src/main/java/org/modeshape/jcr/cache/document/SessionChildReferences.java:58: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `long ChildReferences.size()` of un-annotated interface `org.modeshape.jcr.cache.ChildReferences`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  56.       @Override
  57.       public long size() {
  58. >         return persisted.size() + (appended != null ? appended.size() : 0) - (changedChildren != null ? changedChildren.removalCount() : 0);
  59.       }
  60.   

src/main/java/org/modeshape/jcr/journal/ClusteredJournal.java:101: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ClusteredJournal.start()` indirectly reads without synchronization from `this.localJournal.journalId`. Potentially races with write in method `ClusteredJournal.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  99.           JournalRecord lastRecord = lastRecord();
  100.           Long lastChangeSetTimeMillis = lastRecord != null ? lastRecord.getChangeTimeMillis() : null;
  101. >         DeltaMessage request = DeltaMessage.request(journalId(), lastChangeSetTimeMillis);
  102.           if (LOGGER.isDebugEnabled()) {
  103.               LOGGER.debug("Sending delta request: {0}", request);

src/main/java/org/modeshape/jcr/journal/ClusteredJournal.java:96: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ClusteredJournal.start()` writes to field `this.reconciliationLatch` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  94.           // we'll process all responses eventually, but we only block for the first one
  95.           int numberOfRequiredResponses = 1;
  96. >         this.reconciliationLatch = new CountDownLatch(numberOfRequiredResponses);
  97.           
  98.           // send the request

src/main/java/org/modeshape/jcr/journal/ClusteredJournal.java:99: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ClusteredJournal.start()` indirectly reads without synchronization from `this.localJournal.records`. Potentially races with write in method `ClusteredJournal.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  97.           
  98.           // send the request
  99. >         JournalRecord lastRecord = lastRecord();
  100.           Long lastChangeSetTimeMillis = lastRecord != null ? lastRecord.getChangeTimeMillis() : null;
  101.           DeltaMessage request = DeltaMessage.request(journalId(), lastChangeSetTimeMillis);

src/main/java/org/modeshape/jcr/journal/ClusteredJournal.java:100: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `long DateTime.getMillisecondsInUtc()` of un-annotated interface `org.modeshape.jcr.api.value.DateTime`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  98.           // send the request
  99.           JournalRecord lastRecord = lastRecord();
  100. >         Long lastChangeSetTimeMillis = lastRecord != null ? lastRecord.getChangeTimeMillis() : null;
  101.           DeltaMessage request = DeltaMessage.request(journalId(), lastChangeSetTimeMillis);
  102.           if (LOGGER.isDebugEnabled()) {

src/main/java/org/modeshape/jcr/journal/ClusteredJournal.java:106: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ClusteredJournal.start()` indirectly reads without synchronization from `this.reconciliationLatch`. Potentially races with write in method `ClusteredJournal.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  104.           }
  105.           this.clusteringService.sendMessage(request);
  106. >         waitForReconciliationToComplete();
  107.       }
  108.   

src/main/java/org/modeshape/jcr/value/binary/CassandraBinaryStore.java:262: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void CassandraBinaryStore.start()` writes to field `this.session` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  260.           }
  261.   
  262. >         session = cluster.connect();
  263.           try {
  264.               session.execute("CREATE KEYSPACE modeshape WITH replication "

src/main/java/org/modeshape/jcr/value/binary/CassandraBinaryStore.java:264: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void CassandraBinaryStore.start()` reads without synchronization from `this.session`. Potentially races with write in method `CassandraBinaryStore.start()`.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  262.           session = cluster.connect();
  263.           try {
  264. >             session.execute("CREATE KEYSPACE modeshape WITH replication "
  265.                               + "= {'class':'SimpleStrategy', 'replication_factor':3};");
  266.           } catch (AlreadyExistsException e) {

src/main/java/org/modeshape/jcr/value/binary/DatabaseBinaryStore.java:146: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DatabaseBinaryStore.start()` indirectly writes to field `this.dataSource` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  144.   
  145.           if (!StringUtil.isBlank(datasourceJNDILocation)) {
  146. >             lookupDataSource();
  147.           } else {
  148.               lookupDriver();

src/main/java/org/modeshape/jcr/value/binary/DatabaseBinaryStore.java:151: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void DatabaseBinaryStore.start()` indirectly reads without synchronization from `this.dataSource`. Potentially races with write in method `DatabaseBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  149.           }
  150.   
  151. >         database();
  152.       }
  153.   

src/main/java/org/modeshape/jcr/value/binary/MongodbBinaryStore.java:346: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void MongodbBinaryStore.start()` indirectly writes to field `this.db` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  344.           }
  345.   
  346. >         initMongoDatabase();
  347.   
  348.           // authenticate if required

src/main/java/org/modeshape/jcr/value/binary/MongodbBinaryStore.java:350: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MongodbBinaryStore.start()` reads without synchronization from `this.db`. Potentially races with write in method `MongodbBinaryStore.start()`.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  348.           // authenticate if required
  349.           if (!StringUtil.isBlank(username) && !StringUtil.isBlank(password)) {
  350. >             if (!db.authenticate(username, password.toCharArray())) {
  351.                   throw new RuntimeException("Invalid username/password");
  352.               }

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:172: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void InfinispanBinaryStore.start()` reads without synchronization from `this.metadataCache`. Potentially races with write in method `InfinispanBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  170.       public void start() {
  171.           logger.debug("start()");
  172. >         if (metadataCache != null) {
  173.               logger.debug("Already started.");
  174.               return;

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:179: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void InfinispanBinaryStore.start()` writes to field `this.metadataCache` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  177.               cacheContainer.start();
  178.           }
  179. >         metadataCache = cacheContainer.getCache(metadataCacheName);
  180.           blobCache = cacheContainer.getCache(blobCacheName);
  181.           lockFactory = new LockFactory(metadataCache);

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:181: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void InfinispanBinaryStore.start()` writes to field `this.lockFactory` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  179.           metadataCache = cacheContainer.getCache(metadataCacheName);
  180.           blobCache = cacheContainer.getCache(blobCacheName);
  181. >         lockFactory = new LockFactory(metadataCache);
  182.       }
  183.   

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:177: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void InfinispanBinaryStore.start()` reads without synchronization from `this.cacheContainer`. Potentially races with write in method `InfinispanBinaryStore.shutdown()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  175.           }
  176.           if (dedicatedCacheContainer) {
  177. >             cacheContainer.start();
  178.           }
  179.           metadataCache = cacheContainer.getCache(metadataCacheName);

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:180: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void InfinispanBinaryStore.start()` writes to field `this.blobCache` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  178.           }
  179.           metadataCache = cacheContainer.getCache(metadataCacheName);
  180. >         blobCache = cacheContainer.getCache(blobCacheName);
  181.           lockFactory = new LockFactory(metadataCache);
  182.       }

src/main/java/org/modeshape/jcr/RepositoryStatistics.java:180: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `long DurationActivity.getDuration(TimeUnit)` of un-annotated interface `org.modeshape.jcr.api.monitor.DurationActivity`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  178.           this.minutesStartTime.compareAndSet(null, now);
  179.           this.secondsStartTime.compareAndSet(null, now);
  180. >         rollup();
  181.   
  182.           // Then schedule the rollup to be done at a fixed rate ...

src/main/java/org/modeshape/jcr/clustering/ClusteringService.java:314: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `ClusteringService ClusteringService.startForked(Channel)` indirectly mutates container `clustering.ClusteringService$ForkedClusteringService.FORK_STACKS_BY_CHANNEL_NAME` via call to `put` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  312.           }
  313.           ClusteringService clusteringService = new ForkedClusteringService(mainChannel);
  314. >         clusteringService.init();
  315.           return clusteringService;
  316.       }

src/main/java/org/modeshape/jcr/journal/ClusteredJournal.java:174: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean ClusteredJournal.started()` indirectly reads without synchronization from `this.reconciliationLatch`. Potentially races with write in method `ClusteredJournal.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  172.       @Override
  173.       public boolean started() {
  174. >         return localJournal.started() && reconciliationCompleted();
  175.       }
  176.   

src/main/java/org/modeshape/jcr/RepositoryStatistics.java:733: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `int Statistics.getCount()` of un-annotated interface `org.modeshape.jcr.api.monitor.Statistics`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  731.           for (Statistics stat : statistics) {
  732.               if (stat == null) continue;
  733. >             count += stat.getCount();
  734.               max = Math.max(max, stat.getMaximum());
  735.               min = Math.min(min, stat.getMinimum());

src/main/java/org/modeshape/jcr/value/binary/CassandraBinaryStore.java:99: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void CassandraBinaryStore.storeExtractedText(BinaryValue,String)` reads without synchronization from `this.session`. Potentially races with write in method `CassandraBinaryStore.start()`.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  97.                                       String extractedText ) throws BinaryStoreException {
  98.           try {
  99. >             session.execute("UPDATE modeshape.binary SET ext_text='" + extractedText + "' where cid='" + source.getKey() + "';");
  100.           } catch (RuntimeException e) {
  101.               throw new BinaryStoreException(e);

src/main/java/org/modeshape/jcr/value/binary/DatabaseBinaryStore.java:302: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void DatabaseBinaryStore.storeExtractedText(BinaryValue,String)` indirectly reads without synchronization from `this.dataSource`. Potentially races with write in method `DatabaseBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  300.       public void storeExtractedText( final BinaryValue source,
  301.                                       final String extractedText ) throws BinaryStoreException {
  302. >         dbCall(new DBCallable<Void>() {
  303.               @Override
  304.               public Void execute( Connection connection ) throws Exception {

src/main/java/org/modeshape/jcr/value/binary/FileSystemBinaryStore.java:566: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `BinaryKey BinaryValue.getKey()` of un-annotated interface `org.modeshape.jcr.value.BinaryValue`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  564.                                          String extractedText ) throws BinaryStoreException {
  565.           // Look for an existing file ...
  566. >         if (!binaryValueExists(source)) {
  567.               return;
  568.           }

src/main/java/org/modeshape/jcr/value/binary/MongodbBinaryStore.java:297: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Object DBObject.get(String)` of un-annotated interface `com.mongodb.DBObject`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`.
  295.           }
  296.           DBCollection content = db.getCollection(source.getKey().toString());
  297. >         setAttribute(content, FIELD_EXTRACTED_TEXT, extractedText);
  298.       }
  299.   

src/main/java/org/modeshape/jcr/value/binary/MongodbBinaryStore.java:293: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MongodbBinaryStore.storeExtractedText(BinaryValue,String)` reads without synchronization from `this.db`. Potentially races with write in method `MongodbBinaryStore.start()`.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  291.       public void storeExtractedText( BinaryValue source,
  292.                                       String extractedText ) throws BinaryStoreException {
  293. >         if (!db.collectionExists(source.getKey().toString())) {
  294.               throw new BinaryStoreException(JcrI18n.unableToFindBinaryValue.text(source.getKey(), db.getName()));
  295.           }

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:546: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void InfinispanBinaryStore.storeExtractedText(BinaryValue,String)` reads with synchronization from `this.metadataCache`. Potentially races with unsynchronized write in method `InfinispanBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  544.           try {
  545.               final String metadataKey = metadataKeyFrom(key);
  546. >             final Metadata metadata = metadataCache.get(metadataKey);
  547.               if (metadata == null) {
  548.                   String msg = JcrI18n.unableToFindBinaryValueInCache.text(key, metadataCache.getName());

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:555: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void InfinispanBinaryStore.storeExtractedText(BinaryValue,String)` reads with synchronization from `this.blobCache`. Potentially races with unsynchronized write in method `InfinispanBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  553.               ChunkOutputStream chunkOutputStream = null;
  554.               try {
  555. >                 chunkOutputStream = new ChunkOutputStream(blobCache, textKey, chunkSize);
  556.                   chunkOutputStream.write(extractedText.getBytes("UTF-8"));
  557.               } finally {

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:542: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `BinaryKey BinaryValue.getKey()` of un-annotated interface `org.modeshape.jcr.value.BinaryValue`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  540.       public void storeExtractedText( final BinaryValue binary,
  541.                                       String extractedText ) throws BinaryStoreException {
  542. >         final BinaryKey key = binary.getKey();
  543.           Lock lock = lockFactory.writeLock(lockKeyFrom(key));
  544.           try {

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:543: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void InfinispanBinaryStore.storeExtractedText(BinaryValue,String)` reads without synchronization from `this.lockFactory`. Potentially races with write in method `InfinispanBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  541.                                       String extractedText ) throws BinaryStoreException {
  542.           final BinaryKey key = binary.getKey();
  543. >         Lock lock = lockFactory.writeLock(lockKeyFrom(key));
  544.           try {
  545.               final String metadataKey = metadataKeyFrom(key);

src/main/java/org/modeshape/jcr/value/binary/CassandraBinaryStore.java:89: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void CassandraBinaryStore.storeMimeType(BinaryValue,String)` reads without synchronization from `this.session`. Potentially races with write in method `CassandraBinaryStore.start()`.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  87.                                     String mimeType ) throws BinaryStoreException {
  88.           try {
  89. >             session.execute("UPDATE modeshape.binary SET mime_type='" + mimeType + "' where cid='" + source.getKey() + "';");
  90.           } catch (RuntimeException e) {
  91.               throw new BinaryStoreException(e);

src/main/java/org/modeshape/jcr/value/binary/DatabaseBinaryStore.java:275: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void DatabaseBinaryStore.storeMimeType(BinaryValue,String)` indirectly reads without synchronization from `this.dataSource`. Potentially races with write in method `DatabaseBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  273.       protected void storeMimeType( final BinaryValue source,
  274.                                     final String mimeType ) throws BinaryStoreException {
  275. >         dbCall(new DBCallable<Void>() {
  276.               @Override
  277.               public Void execute( Connection connection ) throws Exception {

src/main/java/org/modeshape/jcr/value/binary/FileSystemBinaryStore.java:601: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `BinaryKey BinaryValue.getKey()` of un-annotated interface `org.modeshape.jcr.value.BinaryValue`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  599.       protected void storeMimeType( BinaryValue binaryValue,
  600.                                     String mimeType ) throws BinaryStoreException {
  601. >         if (!binaryValueExists(binaryValue)) {
  602.               return;
  603.           }

src/main/java/org/modeshape/jcr/value/binary/MongodbBinaryStore.java:273: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MongodbBinaryStore.storeMimeType(BinaryValue,String)` reads without synchronization from `this.db`. Potentially races with write in method `MongodbBinaryStore.start()`.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  271.       protected void storeMimeType( BinaryValue source,
  272.                                     String mimeType ) throws BinaryStoreException {
  273. >         if (db.collectionExists(source.getKey().toString())) {
  274.               DBCollection content = db.getCollection(source.getKey().toString());
  275.               setAttribute(content, FIELD_MIME_TYPE, mimeType);

src/main/java/org/modeshape/jcr/value/binary/MongodbBinaryStore.java:275: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Object DBObject.get(String)` of un-annotated interface `com.mongodb.DBObject`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`.
  273.           if (db.collectionExists(source.getKey().toString())) {
  274.               DBCollection content = db.getCollection(source.getKey().toString());
  275. >             setAttribute(content, FIELD_MIME_TYPE, mimeType);
  276.           } else {
  277.               throw new BinaryStoreException(JcrI18n.unableToFindBinaryValue.text(source.getKey(), db.getName()));

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:499: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `BinaryKey BinaryValue.getKey()` of un-annotated interface `org.modeshape.jcr.value.BinaryValue`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  497.       protected void storeMimeType( final BinaryValue binary,
  498.                                     String mimeType ) throws BinaryStoreException {
  499. >         final BinaryKey key = binary.getKey();
  500.           Lock lock = lockFactory.writeLock(lockKeyFrom(key));
  501.           try {

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:500: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void InfinispanBinaryStore.storeMimeType(BinaryValue,String)` reads without synchronization from `this.lockFactory`. Potentially races with write in method `InfinispanBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  498.                                     String mimeType ) throws BinaryStoreException {
  499.           final BinaryKey key = binary.getKey();
  500. >         Lock lock = lockFactory.writeLock(lockKeyFrom(key));
  501.           try {
  502.               final String metadataKeyStr = metadataKeyFrom(key);

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:503: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void InfinispanBinaryStore.storeMimeType(BinaryValue,String)` reads with synchronization from `this.metadataCache`. Potentially races with unsynchronized write in method `InfinispanBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  501.           try {
  502.               final String metadataKeyStr = metadataKeyFrom(key);
  503. >             Metadata metadata = metadataCache.get(metadataKeyStr);
  504.               if (metadata == null) {
  505.                   String msg = JcrI18n.unableToFindBinaryValueInCache.text(key, metadataCache.getName());

src/main/java/org/modeshape/jcr/value/binary/CassandraBinaryStore.java:131: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `BinaryValue CassandraBinaryStore.storeValue(InputStream,boolean)` indirectly reads with synchronization from `this.session`. Potentially races with unsynchronized write in method `CassandraBinaryStore.start()`.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  129.   
  130.               // check for duplicate content
  131. >             if (this.contentExists(key, ALIVE)) {
  132.                   return new StoredBinaryValue(this, key, temp.getSize());
  133.               }

src/main/java/org/modeshape/jcr/value/binary/CompositeBinaryStore.java:145: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `BinaryValue CompositeBinaryStore.storeValue(InputStream,boolean)` indirectly writes to field `this.defaultBinaryStore` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.BinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  143.       @Override
  144.       public BinaryValue storeValue( InputStream stream, boolean markAsUnused ) throws BinaryStoreException {
  145. >         return storeValue(stream, DEFAULT_STRATEGY_HINT, markAsUnused);
  146.       }
  147.   

src/main/java/org/modeshape/jcr/value/binary/DatabaseBinaryStore.java:173: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `BinaryValue DatabaseBinaryStore.storeValue(InputStream,boolean)` indirectly reads with synchronization from `this.dataSource`. Potentially races with unsynchronized write in method `DatabaseBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  171.           final BinaryValue temp = cache.storeValue(stream, markAsUnused);
  172.           try {
  173. >             return dbCall(new DBCallable<BinaryValue>() {
  174.                   @Override
  175.                   public BinaryValue execute( Connection connection ) throws Exception {

src/main/java/org/modeshape/jcr/value/binary/MongodbBinaryStore.java:207: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `BinaryValue MongodbBinaryStore.storeValue(InputStream,boolean)` reads with synchronization from `this.db`. Potentially races with unsynchronized write in method `MongodbBinaryStore.start()`.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.AbstractBinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  205.   
  206.               // check for duplicate records
  207. >             if (db.collectionExists(key.toString())) {
  208.                   return new StoredBinaryValue(this, key, temp.getSize());
  209.               }

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:238: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `BinaryValue InfinispanBinaryStore.storeValue(InputStream,boolean)` indirectly reads without synchronization from `metadata.unusedSince`. Potentially races with write in method `InfinispanBinaryStore.storeValue(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  236.                   logger.debug("Binary value already exist.");
  237.                   // in case of an unused entry, this entry is from now used
  238. >                 if (metadata.isUnused() && !markAsUnused) {
  239.                       metadata.markAsUsed();
  240.                       putMetadata(metadataKey, metadata);

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:234: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `BinaryValue InfinispanBinaryStore.storeValue(InputStream,boolean)` reads without synchronization from `this.metadataCache`. Potentially races with write in method `InfinispanBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  232.               // check if binary data already exists
  233.               final String metadataKey = metadataKeyFrom(binaryKey);
  234. >             Metadata metadata = metadataCache.get(metadataKey);
  235.               if (metadata != null) {
  236.                   logger.debug("Binary value already exist.");

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:256: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `BinaryValue InfinispanBinaryStore.storeValue(InputStream,boolean)` reads without synchronization from `this.lockFactory`. Potentially races with write in method `InfinispanBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  254.               IoUtil.write(new FileInputStream(tmpFile), chunkOutputStream, bufferSize);
  255.   
  256. >             Lock lock = lockFactory.writeLock(lockKeyFrom(binaryKey));
  257.               try {
  258.                   // now store metadata

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:253: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `BinaryValue InfinispanBinaryStore.storeValue(InputStream,boolean)` reads without synchronization from `this.blobCache`. Potentially races with write in method `InfinispanBinaryStore.start()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  251.               final long fileLength = tmpFile.length();
  252.               int bufferSize = bestBufferSize(fileLength);
  253. >             ChunkOutputStream chunkOutputStream = new ChunkOutputStream(blobCache, dataKey, chunkSize);
  254.               IoUtil.write(new FileInputStream(tmpFile), chunkOutputStream, bufferSize);
  255.   

src/main/java/org/modeshape/jcr/value/binary/infinispan/InfinispanBinaryStore.java:239: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `BinaryValue InfinispanBinaryStore.storeValue(InputStream,boolean)` indirectly writes to field `metadata.unusedSince` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  237.                   // in case of an unused entry, this entry is from now used
  238.                   if (metadata.isUnused() && !markAsUnused) {
  239. >                     metadata.markAsUsed();
  240.                       putMetadata(metadataKey, metadata);
  241.                   }

src/main/java/org/modeshape/jcr/value/binary/CompositeBinaryStore.java:152: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `BinaryKey BinaryValue.getKey()` of un-annotated interface `org.modeshape.jcr.value.BinaryValue`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.BinaryStore` is annotated `@ThreadSafe`.
  150.           BinaryStore binaryStore = selectBinaryStore(hint);
  151.           BinaryValue bv = binaryStore.storeValue(stream, markAsUnused);
  152. >         logger.debug("Stored binary " + bv.getKey() + " into binary store " + binaryStore + " used=" + markAsUnused);
  153.           return bv;
  154.       }

src/main/java/org/modeshape/jcr/value/binary/CompositeBinaryStore.java:150: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `BinaryValue CompositeBinaryStore.storeValue(InputStream,String,boolean)` indirectly writes to field `this.defaultBinaryStore` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.value.binary.BinaryStore` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  148.       @Override
  149.       public BinaryValue storeValue( InputStream stream, String hint, boolean markAsUnused ) throws BinaryStoreException {
  150. >         BinaryStore binaryStore = selectBinaryStore(hint);
  151.           BinaryValue bv = binaryStore.storeValue(stream, markAsUnused);
  152.           logger.debug("Stored binary " + bv.getKey() + " into binary store " + binaryStore + " used=" + markAsUnused);

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3519: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `String AbstractJcrNode.toString()` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3517.       public String toString() {
  3518.           try {
  3519. >             PropertyIterator iter = this.getProperties();
  3520.               StringBuilder propertyBuff = new StringBuilder();
  3521.               while (iter.hasNext()) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3521: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean PropertyIterator.hasNext()` of un-annotated interface `javax.jcr.PropertyIterator`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  3519.               PropertyIterator iter = this.getProperties();
  3520.               StringBuilder propertyBuff = new StringBuilder();
  3521. >             while (iter.hasNext()) {
  3522.                   AbstractJcrProperty prop = (AbstractJcrProperty)iter.nextProperty();
  3523.                   propertyBuff.append(prop);

src/main/java/org/modeshape/jcr/JcrNodeType.java:613: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getString(NamespaceRegistry)` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  611.       @Override
  612.       public String toString() {
  613. >         return getName();
  614.       }
  615.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `String JcrSystemNode.toString()` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:392: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String JcrVersionHistoryNode.toString()` indirectly reads without synchronization from `nodeKey.workspaceKey`. Potentially races with write in method `JcrVersionHistoryNode.addVersionLabel(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  390.               StringBuilder sb = new StringBuilder();
  391.               String versionableId = getVersionableIdentifier();
  392. >             sb.append("Version history for " + session.getNonSystemNodeByIdentifier(versionableId).location() + " ("
  393.                         + versionableId + ") stored at " + location() + ":\n");
  394.               VersionIterator iter = getAllLinearVersions();

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:394: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `String JcrVersionHistoryNode.toString()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  392.               sb.append("Version history for " + session.getNonSystemNodeByIdentifier(versionableId).location() + " ("
  393.                         + versionableId + ") stored at " + location() + ":\n");
  394. >             VersionIterator iter = getAllLinearVersions();
  395.               while (iter.hasNext()) {
  396.                   Version v = iter.nextVersion();

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:391: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `String JcrVersionHistoryNode.toString()` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  389.           try {
  390.               StringBuilder sb = new StringBuilder();
  391. >             String versionableId = getVersionableIdentifier();
  392.               sb.append("Version history for " + session.getNonSystemNodeByIdentifier(versionableId).location() + " ("
  393.                         + versionableId + ") stored at " + location() + ":\n");

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:397: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Version.getName()` of un-annotated interface `javax.jcr.version.Version`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  395.               while (iter.hasNext()) {
  396.                   Version v = iter.nextVersion();
  397. >                 sb.append(" - " + v.getName() + "\n");
  398.               }
  399.               return sb.toString();

src/main/java/org/modeshape/jcr/cache/change/RecordingChanges.java:372: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String RecordingChanges.toString()` reads without synchronization from `this.nodeKeys`. Potentially races with write in method `RecordingChanges.setChangedNodes(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  370.               sb.append("  ").append(change).append("\n");
  371.           }
  372. >         sb.append("changed ").append(nodeKeys.size()).append(" nodes:\n");
  373.           for (NodeKey key : nodeKeys) {
  374.               sb.append("  ").append(key).append("\n");

src/main/java/org/modeshape/jcr/cache/change/RecordingChanges.java:361: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String RecordingChanges.toString()` reads without synchronization from `this.userData`. Potentially races with write in method `RecordingChanges.freeze(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  359.           StringBuilder sb = new StringBuilder();
  360.           sb.append("Save by '").append(getUserId()).append("' at ").append(getTimestamp()).append(" with user data = ")
  361. >           .append(userData).append(" in repository with key '").append(repositoryKey).append("' and workspace '")
  362.             .append(workspaceName);
  363.   

src/main/java/org/modeshape/jcr/cache/change/RecordingChanges.java:360: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String RecordingChanges.toString()` indirectly reads without synchronization from `this.timestamp`. Potentially races with write in method `RecordingChanges.freeze(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  358.       public String toString() {
  359.           StringBuilder sb = new StringBuilder();
  360. >         sb.append("Save by '").append(getUserId()).append("' at ").append(getTimestamp()).append(" with user data = ")
  361.             .append(userData).append(" in repository with key '").append(repositoryKey).append("' and workspace '")
  362.             .append(workspaceName);

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:1647: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getString(NamespaceRegistry)` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1645.       @Override
  1646.       public String toString() {
  1647. >         return getString(null);
  1648.       }
  1649.   

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:1728: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `String Name.getString(NamespaceRegistry)` of un-annotated interface `org.modeshape.jcr.value.Name`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1726.               }
  1727.               sb.append("\n ");
  1728. >             sb.append(changes.getString(reg));
  1729.           }
  1730.           return sb.toString();

src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java:1723: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String WritableSessionCache.toString()` reads without synchronization from `this.changedNodes`. Potentially races with write in method `WritableSessionCache.save()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  1721.           sb.append("Session ").append(context().getId()).append(" to workspace '").append(workspaceName());
  1722.           for (NodeKey key : changedNodesInOrder) {
  1723. >             SessionNode changes = changedNodes.get(key);
  1724.               if (changes == null) {
  1725.                   continue;

src/main/java/org/modeshape/jcr/clustering/ClusteringService.java:285: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String ClusteringService.toString()` indirectly reads without synchronization from `this.channel`. Potentially races with write in method `ClusteringService.restart()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  283.       public String toString() {
  284.           final StringBuilder sb = new StringBuilder("ClusteringService[cluster_name='");
  285. >         sb.append(clusterName()).append("', address=").append(getChannel().getAddress()).append("]");
  286.           return sb.toString();
  287.       }

src/main/java/org/modeshape/jcr/cache/document/BucketedChildReferences.java:261: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `StringBuilder BucketedChildReferences.toString(StringBuilder)` reads without synchronization from container `this.rangeBucketsById` via call to `values`. Potentially races with write in method `BucketedChildReferences.getChildCount(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  259.       public StringBuilder toString( StringBuilder sb ) {
  260.           sb.append("BucketedChildReferences[");
  261. >         for (Bucket bucket : rangeBucketsById.values()) {
  262.               sb.append(bucket).append(System.getProperty("line.separator"));
  263.           }

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3330: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.unlock()` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3328.           RepositoryException {
  3329.           // Session's liveness will be checked in 'lockManager()' ...
  3330. >         session.lockManager().unlock(this);
  3331.       }
  3332.   

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrSystemNode.unlock()` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/JcrLockManager.java:284: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrLockManager.unlock(String)` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  282.           throws PathNotFoundException, LockException, AccessDeniedException, InvalidItemStateException, RepositoryException {
  283.           AbstractJcrNode node = session.node(session.absolutePathFor(absPath));
  284. >         unlock(node);
  285.       }
  286.   

src/main/java/org/modeshape/jcr/JcrLockManager.java:283: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrLockManager.unlock(String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  281.       public void unlock( String absPath )
  282.           throws PathNotFoundException, LockException, AccessDeniedException, InvalidItemStateException, RepositoryException {
  283. >         AbstractJcrNode node = session.node(session.absolutePathFor(absPath));
  284.           unlock(node);
  285.       }

src/main/java/org/modeshape/jcr/JcrLockManager.java:306: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void SessionCache.destroy(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  304.   
  305.           // Remove the lock ...
  306. >         String lockToken = lockManager.unlock(session, node.key());
  307.           lockTokens.remove(lockToken);
  308.       }

src/main/java/org/modeshape/jcr/JcrLockManager.java:298: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrLockManager.unlock(AbstractJcrNode)` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  296.               // Someone else holds the lock, so see if the user has the permission to break someone else's lock ...
  297.               try {
  298. >                 session.checkPermission(session.workspaceName(), node.path(), ModeShapePermissions.UNLOCK_ANY);
  299.               } catch (AccessDeniedException e) {
  300.                   //expected by the TCK

src/main/java/org/modeshape/jcr/RepositoryLockManager.java:423: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void SessionCache.destroy(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  421.               throw new LockException(JcrI18n.notLocked.text(location));
  422.           }
  423. >         unlock(session, Collections.singleton(existing));
  424.           return existing.getLockToken();
  425.       }

src/main/java/org/modeshape/jcr/RepositoryIndexManager.java:342: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean IndexWriter.canBeSkipped()` of un-annotated interface `org.modeshape.jcr.spi.index.IndexWriter`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  340.   
  341.           // Refresh the index writer ...
  342. >         refreshIndexWriter();
  343.       }
  344.   

src/main/java/org/modeshape/jcr/RepositoryIndexManager.java:339: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void RepositoryIndexManager.unregister(String)` indirectly mutates container `indexes` via call to `add` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  337.   
  338.           // Re-read the index definitions in case there were disabled index definitions that used the now-available provider ...
  339. >         readIndexDefinitions();
  340.   
  341.           // Refresh the index writer ...

src/main/java/org/modeshape/jcr/SystemNamespaceRegistry.java:215: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean SystemNamespaceRegistry.unregister(String)` indirectly reads with synchronization from `this.context`. Potentially races with unsynchronized write in method `SystemNamespaceRegistry.setContext(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  213.               boolean found = this.cache.unregister(namespaceUri);
  214.               // Then from the source ...
  215. >             SystemContent systemContent = systemContent(false);
  216.               boolean foundPersistent = systemContent.unregisterNamespace(namespaceUri);
  217.               systemContent.save();

src/main/java/org/modeshape/jcr/RepositoryIndexManager.java:544: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `void SessionCache.destroy(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  542.                   throw new NoSuchIndexException(JcrI18n.indexDoesNotExist.text(indexName, repository.name()));
  543.               }
  544. >             system.remove(defn);
  545.           }
  546.           system.save();

src/main/java/org/modeshape/jcr/RepositoryIndexManager.java:549: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void RepositoryIndexManager.unregisterIndexes(java.lang.String[])` indirectly mutates container `indexes` via call to `add` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  547.   
  548.           // Refresh the immutable snapshot ...
  549. >         this.indexes = readIndexDefinitions();
  550.       }
  551.   

src/main/java/org/modeshape/jcr/RepositoryNodeTypeManager.java:200: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void RepositoryNodeTypeManager.unregisterNodeType(Collection,boolean)` indirectly writes to field `mutableTable.extraColumns` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  198.               // Search the content graph to make sure that this type isn't being used
  199.               for (Name nodeTypeName : nodeTypeNames) {
  200. >                 if (isNodeTypeInUse(nodeTypeName)) {
  201.                       String name = nodeTypeName.getString(context.getNamespaceRegistry());
  202.                       throw new InvalidNodeTypeDefinitionException(JcrI18n.cannotUnregisterInUseType.text(name));

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2964: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.update(String)` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2962.           CheckArg.isNotNull(srcWorkspace, "srcWorkspace");
  2963.   
  2964. >         session().getWorkspace().validateCrossWorkspaceAction(srcWorkspace);
  2965.   
  2966.           if (workspaceName().equalsIgnoreCase(srcWorkspace)) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2987: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AbstractJcrNode.update(String)` indirectly reads without synchronization from `nodeKey.workspaceKey`. Potentially races with write in method `AbstractJcrNode.addNode(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2985.           */
  2986.           JcrSession sourceSession = session.spawnSession(srcWorkspace, true);
  2987. >         AbstractJcrNode sourceNode = sourceSession.node(srcPath);
  2988.           if (session.lockManager().isLocked(sourceNode)
  2989.               && !session.lockManager().hasLockToken(sourceNode.getLock().getLockToken())) {

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2974: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean NodeTypes$ReusableNodeDefinitionSet.appliesTo(NodeTypes,Name,Set)` of un-annotated interface `org.modeshape.jcr.NodeTypes$ReusableNodeDefinitionSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  2972.           }
  2973.   
  2974. >         checkNotProtected();
  2975.   
  2976.           Path srcPath = null;

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:3003: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.update(String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  3001.           // create an inner session for cloning
  3002.           JcrSession cloneSession = session.spawnSession(false);
  3003. >         getSession().getWorkspace().deepClone(sourceSession, sourceNode.key(), cloneSession, key());
  3004.   
  3005.           session().refresh(false);

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2978: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.update(String)` indirectly writes to field `key.identifier` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2976.           Path srcPath = null;
  2977.           try {
  2978. >             srcPath = correspondingNodePath(srcWorkspace);
  2979.           } catch (ItemNotFoundException infe) {
  2980.               return;

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:2989: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractJcrNode.update(String)` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  2987.           AbstractJcrNode sourceNode = sourceSession.node(srcPath);
  2988.           if (session.lockManager().isLocked(sourceNode)
  2989. >             && !session.lockManager().hasLockToken(sourceNode.getLock().getLockToken())) {
  2990.               throw new LockException(srcPath.toString());
  2991.           }

src/main/java/org/modeshape/jcr/JcrSystemNode.java:25: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrSystemNode.update(String)` indirectly writes to field `definition.checker` outside of synchronization.
 Reporting because a superclass `class org.modeshape.jcr.JcrNode` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  23.    * A Node implementation that is used to represent all nodes within the "/jcr:system" subgraph.
  24.    */
  25. > public class JcrSystemNode extends JcrNode {
  26.   
  27.       JcrSystemNode( JcrSession session,

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:1265: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `boolean NodeTypes$ReusableNodeDefinitionSet.appliesTo(NodeTypes,Name,Set)` of un-annotated interface `org.modeshape.jcr.NodeTypes$ReusableNodeDefinitionSet`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  1263.           }
  1264.   
  1265. >         NodeDefinitionSet childDefns = nodeTypes.findChildNodeDefinitions(primaryTypeName, mixins);
  1266.           JcrNodeDefinition childDefn = childDefns.findBestDefinitionForChild(childName, childPrimaryNodeTypeName, skipProtected,
  1267.                                                                               siblingCounter);

src/main/java/org/modeshape/jcr/JcrWorkspace.java:533: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JcrWorkspace.validateCrossWorkspaceAction(String)` indirectly mutates container `ace.privileges` via call to `addAll` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  531.   
  532.           session.checkLive();
  533. >         session.checkWorkspacePermission(srcWorkspace, ModeShapePermissions.READ);
  534.           session.checkWorkspacePermission(getName(), ModeShapePermissions.READ);
  535.   

src/main/java/org/modeshape/jcr/AbstractJcrNode.java:598: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `CachedNode SessionCache.getNode(NodeKey)` of un-annotated interface `org.modeshape.jcr.cache.SessionCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  596.           AbstractJcrNode node = (AbstractJcrNode)value;
  597.           if (!this.isInTheSameProcessAs(node.session().context().getProcessId())) {
  598. >             throw new RepositoryException(JcrI18n.nodeNotInTheSameSession.text(node.path()));
  599.           }
  600.           NodeKey key = ((AbstractJcrNode)value).key();

src/main/java/org/modeshape/jcr/JcrVersionHistoryNode.java:77: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractJcrNode JcrVersionHistoryNode.versionLabels()` indirectly writes to field `nodeKey.workspaceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  75.        */
  76.       protected final AbstractJcrNode versionLabels() throws RepositoryException {
  77. >         return childNode(JcrLexicon.VERSION_LABELS, Type.NODE);
  78.       }
  79.   

src/main/java/org/modeshape/jcr/JcrWorkspace.java:668: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `JcrVersionManager JcrWorkspace.versionManager()` reads without synchronization from `this.versionManager`. Potentially races with write in method `JcrWorkspace.versionManager()`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  666.   
  667.       final JcrVersionManager versionManager() {
  668. >         if (versionManager == null) {
  669.               try {
  670.                   lock.lock();

src/main/java/org/modeshape/jcr/JcrNodeType.java:640: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `JcrNodeType JcrNodeType.with(ExecutionContext,JcrSession)` indirectly writes to field `this.key.sourceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  638.       final JcrNodeType with( ExecutionContext context,
  639.                               JcrSession session ) {
  640. >         return new JcrNodeType(this.key, context, session, this.nodeTypeManager, this.name, this.declaredSupertypes,
  641.                                  this.primaryItemName, this.childNodeDefinitions, this.propertyDefinitions, this.mixin,
  642.                                  this.isAbstract, this.queryable, this.orderableChildNodes);

src/main/java/org/modeshape/jcr/RepositoryIndexManager.java:553: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `RepositoryIndexManager RepositoryIndexManager.with(JcrRepository$RunningState)` indirectly reads with synchronization from container `byProvider` via call to `get`. Potentially races with unsynchronized write in method `RepositoryIndexManager.registerIndexes(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  551.   
  552.       RepositoryIndexManager with( JcrRepository.RunningState repository ) {
  553. >         return new RepositoryIndexManager(repository, config);
  554.       }
  555.   

src/main/java/org/modeshape/jcr/RepositoryNodeTypeManager.java:126: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `Collection Multimap.get(Object)` of un-annotated interface `org.modeshape.common.collection.Multimap`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  124.           Path nodeTypesPath = pathFactory.createAbsolutePath(JcrLexicon.SYSTEM, JcrLexicon.NODE_TYPES);
  125.           assert this.nodeTypesPath.equals(nodeTypesPath);
  126. >         RepositoryNodeTypeManager result = new RepositoryNodeTypeManager(repository, includeColumnsForInheritedProperties,
  127.                                                                            includePseudoColumnsInSelectStar);
  128.           // Now copy the node types from this cache into the new manager's cache ...

src/main/java/org/modeshape/jcr/RepositoryLockManager.java:112: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `int Document.getInteger(String,int)` of un-annotated interface `org.infinispan.schematic.document.Document`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  110.           Path locksPath = pathFactory.create(pathFactory.createRootPath(), JcrLexicon.SYSTEM, ModeShapeLexicon.LOCKS);
  111.           assert this.locksPath.equals(locksPath);
  112. >         return new RepositoryLockManager(repository, gcConfig);
  113.       }
  114.   

src/main/java/org/modeshape/jcr/JcrNodeType.java:625: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `JcrNodeType JcrNodeType.with(RepositoryNodeTypeManager)` indirectly writes to field `this.key.sourceKey` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  623.        */
  624.       final JcrNodeType with( RepositoryNodeTypeManager nodeTypeManager ) {
  625. >         return new JcrNodeType(this.key, this.context, this.session, nodeTypeManager, this.name, this.declaredSupertypes,
  626.                                  this.primaryItemName, this.childNodeDefinitions, this.propertyDefinitions, this.mixin,
  627.                                  this.isAbstract, this.queryable, this.orderableChildNodes);

src/main/java/org/modeshape/jcr/journal/LocalJournal.java:324: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `LocalJournal LocalJournal.withSearchTimeDelta(long)` writes to field `this.searchTimeDelta` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  322.   
  323.       protected LocalJournal withSearchTimeDelta( final long searchTimeDelta ) {
  324. >         this.searchTimeDelta = searchTimeDelta;
  325.           return this;
  326.       }

src/main/java/org/modeshape/jcr/Connectors.java:954: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Connectors$Snapshot Connectors$Snapshot.withoutConnectors(Iterable)` indirectly reads without synchronization from container `this.sourceKeyToConnectorMap` via call to `values`. Potentially races with write in method `Connectors$Snapshot.shutdownConnectors()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  952.               }
  953.               if (modified) {
  954. >                 checkForReadonlyConnectors();
  955.               }
  956.               return modified ? clone : this;

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:299: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `NodeCache NodeCache.unwrap()` of un-annotated interface `org.modeshape.jcr.cache.NodeCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  297.   
  298.       protected final WorkspaceCache workspace( NodeCache cache ) {
  299. >         return ((DocumentCache)cache.unwrap()).workspaceCache();
  300.       }
  301.   

src/main/java/org/modeshape/jcr/cache/document/LazyCachedNode.java:105: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `NodeCache NodeCache.unwrap()` of un-annotated interface `org.modeshape.jcr.cache.NodeCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  103.   
  104.       protected final WorkspaceCache workspaceCache( NodeCache cache ) {
  105. >         return ((DocumentCache)cache.unwrap()).workspaceCache();
  106.       }
  107.   

src/main/java/org/modeshape/jcr/cache/document/SessionNode.java:291: warning: INTERFACE_NOT_THREAD_SAFE
  Unprotected call to method `NodeCache NodeCache.unwrap()` of un-annotated interface `org.modeshape.jcr.cache.NodeCache`. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.
 Reporting because the current class is annotated `@ThreadSafe`.
  289.   
  290.       protected final WritableSessionCache writableSession( NodeCache cache ) {
  291. >         return (WritableSessionCache)cache.unwrap();
  292.       }
  293.   

Summary of the reports

    THREAD_SAFETY_VIOLATION: 676
  INTERFACE_NOT_THREAD_SAFE: 497
           NULL_DEREFERENCE: 84
              RESOURCE_LEAK: 17